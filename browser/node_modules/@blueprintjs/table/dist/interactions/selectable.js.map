{"version":3,"sources":["../src/interactions/selectable.tsx"],"names":[],"mappings":"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","file":"selectable.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { Utils as BlueprintUtils } from \"@blueprintjs/core\";\nimport * as PureRender from \"pure-render-decorator\";\nimport * as React from \"react\";\nimport { IFocusedCellCoordinates } from \"../common/cell\";\nimport * as FocusedCellUtils from \"../common/internal/focusedCellUtils\";\nimport { Utils } from \"../common/utils\";\nimport { DragEvents } from \"../interactions/dragEvents\";\nimport { Draggable, ICoordinateData, IDraggableProps } from \"../interactions/draggable\";\nimport { IRegion, Regions } from \"../regions\";\n\nexport type ISelectedRegionTransform = (region: IRegion, event: MouseEvent, coords?: ICoordinateData) => IRegion;\n\nexport interface ISelectableProps {\n    /**\n     * If `false`, only a single region of a single column/row/cell may be\n     * selected at one time. Using `ctrl` or `meta` key will have no effect,\n     * and a mouse drag will select the current column/row/cell only.\n     * @default false\n     */\n    allowMultipleSelection?: boolean;\n\n    /**\n     * The currently focused cell.\n     */\n    focusedCell?: IFocusedCellCoordinates;\n\n    /**\n     * When the user focuses something, this callback is called with new\n     * focused cell coordinates. This should be considered the new focused cell\n     * state for the entire table.\n     */\n    onFocus: (focusedCell: IFocusedCellCoordinates) => void;\n\n    /**\n     * When the user selects something, this callback is called with a new\n     * array of `Region`s. This array should be considered the new selection\n     * state for the entire table.\n     */\n    onSelection: (regions: IRegion[]) => void;\n\n    /**\n     * An additional convenience callback invoked when the user releases the\n     * mouse from either a click or a drag, indicating that the selection\n     * interaction has ended.\n     */\n    onSelectionEnd?: (regions: IRegion[]) => void;\n\n    /**\n     * An array containing the table's selection Regions.\n     * @default []\n     */\n    selectedRegions?: IRegion[];\n\n    /**\n     * An optional transform function that will be applied to the located\n     * `Region`.\n     *\n     * This allows you to, for example, convert cell `Region`s into row\n     * `Region`s while maintaining the existing multi-select and meta-click\n     * functionality.\n     */\n    selectedRegionTransform?: ISelectedRegionTransform;\n}\n\nexport interface IDragSelectableProps extends ISelectableProps {\n    /**\n     * A list of CSS selectors that should _not_ trigger selection when a `mousedown` occurs inside of them.\n     */\n    ignoredSelectors?: string[];\n\n    /**\n     * Whether the selection behavior is disabled.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * A callback that determines a `Region` for the single `MouseEvent`. If\n     * no valid region can be found, `null` may be returned.\n     */\n    locateClick: (event: MouseEvent) => IRegion;\n\n    /**\n     * A callback that determines a `Region` for the `MouseEvent` and\n     * coordinate data representing a drag. If no valid region can be found,\n     * `null` may be returned.\n     */\n    locateDrag: (event: MouseEvent, coords: ICoordinateData, returnEndOnly?: boolean) => IRegion;\n}\n\n@PureRender\nexport class DragSelectable extends React.Component<IDragSelectableProps, {}> {\n    public static defaultProps: Partial<IDragSelectableProps> = {\n        allowMultipleSelection: false,\n        disabled: false,\n        selectedRegions: [],\n    };\n\n    private didExpandSelectionOnActivate = false;\n\n    public render() {\n        const draggableProps = this.getDraggableProps();\n        return (\n            <Draggable {...draggableProps} preventDefault={false}>\n                {this.props.children}\n            </Draggable>\n        );\n    }\n\n    private getDraggableProps(): IDraggableProps {\n        return this.props.onSelection == null ? {} : {\n            onActivate: this.handleActivate,\n            onClick: this.handleClick,\n            onDragEnd: this.handleDragEnd,\n            onDragMove: this.handleDragMove,\n        };\n    }\n\n    private handleActivate = (event: MouseEvent) => {\n        const { locateClick, selectedRegions, selectedRegionTransform } = this.props;\n        if (this.shouldIgnoreMouseDown(event)) {\n            return false;\n        }\n\n        let region = locateClick(event);\n\n        if (!Regions.isValid(region)) {\n            return false;\n        }\n\n        if (selectedRegionTransform != null) {\n            region = selectedRegionTransform(region, event);\n        }\n\n        const foundIndex = Regions.findMatchingRegion(selectedRegions, region);\n        const matchesExistingSelection = foundIndex !== -1;\n\n        if (matchesExistingSelection) {\n            this.handleUpdateExistingSelection(foundIndex, event);\n            // no need to listen for subsequent drags\n            return false;\n        } else if (this.shouldExpandSelection(event)) {\n            this.handleExpandSelection(region);\n        } else if (this.shouldAddDisjointSelection(event)) {\n            this.handleAddDisjointSelection(region);\n        } else {\n            this.handleReplaceSelection(region);\n        }\n\n        return true;\n    }\n\n    private handleDragMove = (event: MouseEvent, coords: ICoordinateData) => {\n        const {\n            allowMultipleSelection,\n            focusedCell,\n            locateClick,\n            locateDrag,\n            selectedRegions,\n            selectedRegionTransform,\n        } = this.props;\n\n        let region = allowMultipleSelection\n            ? locateDrag(event, coords, /* returnEndOnly? */ this.didExpandSelectionOnActivate)\n            : locateClick(event);\n\n        if (!Regions.isValid(region)) {\n            return;\n        } else if (selectedRegionTransform != null) {\n            region = selectedRegionTransform(region, event, coords);\n        }\n\n        const nextSelectedRegions = this.didExpandSelectionOnActivate\n            ? this.expandSelectedRegions(selectedRegions, region, focusedCell)\n            : Regions.update(selectedRegions, region);\n\n        this.maybeInvokeSelectionCallback(nextSelectedRegions);\n\n        if (!allowMultipleSelection) {\n            // move the focused cell with the selected region\n            const lastIndex = nextSelectedRegions.length - 1;\n            const mostRecentRegion = nextSelectedRegions[lastIndex];\n            this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);\n        }\n    }\n\n    private handleDragEnd = () => {\n        this.finishInteraction();\n    }\n\n    private handleClick = () => {\n        this.finishInteraction();\n    }\n\n    // Boolean checks\n    // ==============\n\n    private shouldExpandSelection = (event: MouseEvent) => {\n        const { allowMultipleSelection } = this.props;\n        return allowMultipleSelection && event.shiftKey;\n    }\n\n    private shouldAddDisjointSelection = (event: MouseEvent) => {\n        const { allowMultipleSelection } = this.props;\n        return allowMultipleSelection && DragEvents.isAdditive(event);\n    }\n\n    private shouldIgnoreMouseDown(event: MouseEvent) {\n        const { ignoredSelectors = [] } = this.props;\n        const element = event.target as HTMLElement;\n        return !Utils.isLeftClick(event)\n            || this.props.disabled\n            || ignoredSelectors.some((selector: string) => element.closest(selector) != null);\n    }\n\n    // Update logic\n    // ============\n\n    private handleUpdateExistingSelection = (selectedRegionIndex: number, event: MouseEvent) => {\n        const { onSelection, selectedRegions } = this.props;\n\n        if (DragEvents.isAdditive(event)) {\n            // remove just the clicked region, leaving other selected regions in place\n            const nextSelectedRegions = selectedRegions.slice();\n            nextSelectedRegions.splice(selectedRegionIndex, 1);\n            onSelection(nextSelectedRegions);\n\n            // if there are still any selections, move the focused cell to the\n            // most recent selection. otherwise, don't update it.\n            if (nextSelectedRegions.length > 0) {\n                const lastIndex = nextSelectedRegions.length - 1;\n                this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);\n            }\n        } else {\n            // clear all selections, but don't update the focused cell\n            onSelection([]);\n        }\n    }\n\n    private handleExpandSelection = (region: IRegion) => {\n        const { focusedCell, onSelection, selectedRegions } = this.props;\n        this.didExpandSelectionOnActivate = true;\n\n        // there should be only one selected region after expanding. do not\n        // update the focused cell.\n        const nextSelectedRegions = this.expandSelectedRegions(selectedRegions, region, focusedCell);\n        onSelection(nextSelectedRegions);\n\n        // move the focused cell into the new region if there were no selections before\n        if (selectedRegions == null || selectedRegions.length === 0) {\n            this.invokeOnFocusCallbackForRegion(region);\n        }\n    }\n\n    private handleAddDisjointSelection = (region: IRegion) => {\n        const { onSelection, selectedRegions } = this.props;\n\n        // add the new region to the existing selections\n        const nextSelectedRegions = Regions.add(selectedRegions, region);\n        onSelection(nextSelectedRegions);\n\n        // put the focused cell in the new region\n        this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);\n    }\n\n    private handleReplaceSelection = (region: IRegion) => {\n        const { onSelection } = this.props;\n\n        // clear all selections and retain only the new one\n        const nextSelectedRegions = [region];\n        onSelection(nextSelectedRegions);\n\n        // move the focused cell into the new selection\n        this.invokeOnFocusCallbackForRegion(region);\n    }\n\n    // Callbacks\n    // =========\n\n    private maybeInvokeSelectionCallback(nextSelectedRegions: IRegion[]) {\n        const { onSelection, selectedRegions } = this.props;\n        // invoke only if the selection changed. this is useful only on\n        // mousemove; there's special handling for mousedown interactions that\n        // target an already-selected region.\n        if (!Utils.deepCompareKeys(selectedRegions, nextSelectedRegions)) {\n            onSelection(nextSelectedRegions);\n        }\n    }\n\n    private invokeOnFocusCallbackForRegion = (focusRegion: IRegion, focusSelectionIndex = 0) => {\n        const { onFocus } = this.props;\n        const focusedCellCoords = Regions.getFocusCellCoordinatesFromRegion(focusRegion);\n        onFocus(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));\n    }\n\n    // Other\n    // =====\n\n    private finishInteraction = () => {\n        BlueprintUtils.safeInvoke(this.props.onSelectionEnd, this.props.selectedRegions);\n        this.didExpandSelectionOnActivate = false;\n    }\n\n    private expandSelectedRegions(regions: IRegion[], region: IRegion, focusedCell?: IFocusedCellCoordinates) {\n        if (regions.length === 0) {\n            return [region];\n        } else if (focusedCell != null) {\n            const expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);\n            return Regions.update(regions, expandedRegion);\n        } else {\n            const expandedRegion = Regions.expandRegion(regions[regions.length - 1], region);\n            return Regions.update(regions, expandedRegion);\n        }\n    }\n}\n"]}