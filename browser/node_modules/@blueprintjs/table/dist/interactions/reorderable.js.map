{"version":3,"sources":["../src/interactions/reorderable.tsx"],"names":[],"mappings":"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","file":"reorderable.js","sourcesContent":["/**\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as PureRender from \"pure-render-decorator\";\nimport * as React from \"react\";\nimport { IFocusedCellCoordinates } from \"../common/cell\";\nimport { Utils } from \"../common/utils\";\nimport { Draggable, ICoordinateData, IDraggableProps } from \"../interactions/draggable\";\nimport { IRegion, RegionCardinality, Regions } from \"../regions\";\n\nexport interface IReorderableProps {\n    /**\n     * A callback that is called while the user is dragging to reorder.\n     *\n     * @param oldIndex the original index of the element or set of elements\n     * @param newIndex the new index of the element or set of elements\n     * @param length the number of contiguous elements that were moved\n     */\n    onReordering: (oldIndex: number, newIndex: number, length: number) => void;\n\n    /**\n     * A callback that is called when the user is done dragging to reorder.\n     *\n     * @param oldIndex the original index of the element or set of elements\n     * @param newIndex the new index of the element or set of elements\n     * @param length the number of contiguous elements that were moved\n     */\n    onReordered: (oldIndex: number, newIndex: number, length: number) => void;\n\n    /**\n     * When the user reorders something, this callback is called with a new\n     * array of `Region`s. This array should be considered the new selection\n     * state for the entire table.\n     */\n    onSelection: (regions: IRegion[]) => void;\n\n    /**\n     * When the user reorders something, this callback is called with the new\n     * focus cell for the newly selected set of regions.\n     */\n    onFocus: (focusedCell: IFocusedCellCoordinates) => void;\n\n    /**\n     * An array containing the table's selection Regions.\n     * @default []\n     */\n    selectedRegions?: IRegion[];\n}\n\nexport interface IDragReorderable extends IReorderableProps {\n    /**\n     * Whether the reordering behavior is disabled.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * A callback that determines a `Region` for the single `MouseEvent`. If\n     * no valid region can be found, `null` may be returned.\n     */\n    locateClick: (event: MouseEvent) => IRegion;\n\n    /**\n     * A callback that determines the index at which to show the preview guide.\n     * This is equivalent to the absolute index in the old ordering where the\n     * reordered element will move.\n     */\n    locateDrag: (event: MouseEvent, coords: ICoordinateData) => number;\n\n    /**\n     * A callback that converts the provided index into a region. The returned\n     * region will be used to update the current selection after drag-reordering.\n     */\n    toRegion: (index1: number, index2?: number) => IRegion;\n}\n\n@PureRender\nexport class DragReorderable extends React.Component<IDragReorderable, {}> {\n    public static defaultProps: Partial<IDragReorderable> = {\n        selectedRegions: [],\n    };\n\n    private selectedRegionStartIndex: number;\n    private selectedRegionLength: number;\n\n    public render() {\n        const draggableProps = this.getDraggableProps();\n        return (\n            <Draggable {...draggableProps} preventDefault={false}>\n                {this.props.children}\n            </Draggable>\n        );\n    }\n\n    private getDraggableProps(): IDraggableProps {\n        return this.props.onReordered == null ? {} : {\n            onActivate: this.handleActivate,\n            onDragEnd: this.handleDragEnd,\n            onDragMove: this.handleDragMove,\n        };\n    }\n\n    private handleActivate = (event: MouseEvent) => {\n        if (!Utils.isLeftClick(event) || this.props.disabled) {\n            return false;\n        }\n\n        const region = this.props.locateClick(event);\n        if (!Regions.isValid(region)) {\n            return false;\n        }\n\n        const cardinality = Regions.getRegionCardinality(region);\n        const isColumnHeader = cardinality === RegionCardinality.FULL_COLUMNS;\n        const isRowHeader = cardinality === RegionCardinality.FULL_ROWS;\n\n        if (!isColumnHeader && !isRowHeader) {\n            return false;\n        }\n\n        const { selectedRegions } = this.props;\n\n        const selectedRegionIndex = Regions.findContainingRegion(selectedRegions, region);\n        if (selectedRegionIndex >= 0) {\n            const selectedRegion = selectedRegions[selectedRegionIndex];\n            if (Regions.getRegionCardinality(selectedRegion) !== cardinality) {\n                // ignore FULL_TABLE selections\n                return false;\n            }\n\n            // cache for easy access later in the lifecycle\n            const selectedInterval = isRowHeader ? selectedRegion.rows : selectedRegion.cols;\n            this.selectedRegionStartIndex = selectedInterval[0];\n            // add 1 because the selected interval is inclusive, which simple subtraction doesn't\n            // account for (e.g. in a FULL_COLUMNS range from 3 to 6, 6 - 3 = 3, but the selection\n            // actually includes four columns: 3, 4, 5, and 6)\n            this.selectedRegionLength = selectedInterval[1] - selectedInterval[0] + 1;\n        } else {\n            // select the new region to avoid complex and unintuitive UX w/r/t the existing selection\n            this.maybeSelectRegion(region);\n\n            const regionRange = isRowHeader ? region.rows : region.cols;\n            this.selectedRegionStartIndex = regionRange[0];\n            this.selectedRegionLength = regionRange[1] - regionRange[0] + 1;\n        }\n\n        return true;\n    }\n\n    private handleDragMove = (event: MouseEvent, coords: ICoordinateData) => {\n        const oldIndex = this.selectedRegionStartIndex;\n        const guideIndex = this.props.locateDrag(event, coords);\n        const length = this.selectedRegionLength;\n        const reorderedIndex = Utils.guideIndexToReorderedIndex(oldIndex, guideIndex, length);\n        this.props.onReordering(oldIndex, reorderedIndex, length);\n    }\n\n    private handleDragEnd = (event: MouseEvent, coords: ICoordinateData) => {\n        const oldIndex = this.selectedRegionStartIndex;\n        const guideIndex = this.props.locateDrag(event, coords);\n        const length = this.selectedRegionLength;\n\n        const reorderedIndex = Utils.guideIndexToReorderedIndex(oldIndex, guideIndex, length);\n        this.props.onReordered(oldIndex, reorderedIndex, length);\n\n        // the newly reordered region becomes the only selection\n        const newRegion = this.props.toRegion(reorderedIndex, reorderedIndex + length - 1);\n        this.maybeSelectRegion(newRegion);\n\n        // resetting is not strictly required, but it's cleaner\n        this.selectedRegionStartIndex = undefined;\n        this.selectedRegionLength = undefined;\n    }\n\n    private maybeSelectRegion(region: IRegion) {\n        const nextSelectedRegions = [region];\n\n        if (!Utils.deepCompareKeys(nextSelectedRegions, this.props.selectedRegions)) {\n            this.props.onSelection(nextSelectedRegions);\n\n            // move the focused cell into the newly selected region\n            this.props.onFocus({\n                ...Regions.getFocusCellCoordinatesFromRegion(region),\n                focusSelectionIndex: 0,\n            });\n        }\n    }\n}\n"]}