/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var PureRender = require("pure-render-decorator");
var React = require("react");
var FocusedCellUtils = require("../common/internal/focusedCellUtils");
var utils_1 = require("../common/utils");
var dragEvents_1 = require("../interactions/dragEvents");
var draggable_1 = require("../interactions/draggable");
var regions_1 = require("../regions");
var DragSelectable = (function (_super) {
    tslib_1.__extends(DragSelectable, _super);
    function DragSelectable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.didExpandSelectionOnActivate = false;
        _this.handleActivate = function (event) {
            var _a = _this.props, locateClick = _a.locateClick, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
            if (_this.shouldIgnoreMouseDown(event)) {
                return false;
            }
            var region = locateClick(event);
            if (!regions_1.Regions.isValid(region)) {
                return false;
            }
            if (selectedRegionTransform != null) {
                region = selectedRegionTransform(region, event);
            }
            var foundIndex = regions_1.Regions.findMatchingRegion(selectedRegions, region);
            var matchesExistingSelection = foundIndex !== -1;
            if (matchesExistingSelection) {
                _this.handleUpdateExistingSelection(foundIndex, event);
                // no need to listen for subsequent drags
                return false;
            }
            else if (_this.shouldExpandSelection(event)) {
                _this.handleExpandSelection(region);
            }
            else if (_this.shouldAddDisjointSelection(event)) {
                _this.handleAddDisjointSelection(region);
            }
            else {
                _this.handleReplaceSelection(region);
            }
            return true;
        };
        _this.handleDragMove = function (event, coords) {
            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, focusedCell = _a.focusedCell, locateClick = _a.locateClick, locateDrag = _a.locateDrag, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
            var region = allowMultipleSelection
                ? locateDrag(event, coords, /* returnEndOnly? */ _this.didExpandSelectionOnActivate)
                : locateClick(event);
            if (!regions_1.Regions.isValid(region)) {
                return;
            }
            else if (selectedRegionTransform != null) {
                region = selectedRegionTransform(region, event, coords);
            }
            var nextSelectedRegions = _this.didExpandSelectionOnActivate
                ? _this.expandSelectedRegions(selectedRegions, region, focusedCell)
                : regions_1.Regions.update(selectedRegions, region);
            _this.maybeInvokeSelectionCallback(nextSelectedRegions);
            if (!allowMultipleSelection) {
                // move the focused cell with the selected region
                var lastIndex = nextSelectedRegions.length - 1;
                var mostRecentRegion = nextSelectedRegions[lastIndex];
                _this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);
            }
        };
        _this.handleDragEnd = function () {
            _this.finishInteraction();
        };
        _this.handleClick = function () {
            _this.finishInteraction();
        };
        // Boolean checks
        // ==============
        _this.shouldExpandSelection = function (event) {
            var allowMultipleSelection = _this.props.allowMultipleSelection;
            return allowMultipleSelection && event.shiftKey;
        };
        _this.shouldAddDisjointSelection = function (event) {
            var allowMultipleSelection = _this.props.allowMultipleSelection;
            return allowMultipleSelection && dragEvents_1.DragEvents.isAdditive(event);
        };
        // Update logic
        // ============
        _this.handleUpdateExistingSelection = function (selectedRegionIndex, event) {
            var _a = _this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
            if (dragEvents_1.DragEvents.isAdditive(event)) {
                // remove just the clicked region, leaving other selected regions in place
                var nextSelectedRegions = selectedRegions.slice();
                nextSelectedRegions.splice(selectedRegionIndex, 1);
                onSelection(nextSelectedRegions);
                // if there are still any selections, move the focused cell to the
                // most recent selection. otherwise, don't update it.
                if (nextSelectedRegions.length > 0) {
                    var lastIndex = nextSelectedRegions.length - 1;
                    _this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);
                }
            }
            else {
                // clear all selections, but don't update the focused cell
                onSelection([]);
            }
        };
        _this.handleExpandSelection = function (region) {
            var _a = _this.props, focusedCell = _a.focusedCell, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
            _this.didExpandSelectionOnActivate = true;
            // there should be only one selected region after expanding. do not
            // update the focused cell.
            var nextSelectedRegions = _this.expandSelectedRegions(selectedRegions, region, focusedCell);
            onSelection(nextSelectedRegions);
            // move the focused cell into the new region if there were no selections before
            if (selectedRegions == null || selectedRegions.length === 0) {
                _this.invokeOnFocusCallbackForRegion(region);
            }
        };
        _this.handleAddDisjointSelection = function (region) {
            var _a = _this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
            // add the new region to the existing selections
            var nextSelectedRegions = regions_1.Regions.add(selectedRegions, region);
            onSelection(nextSelectedRegions);
            // put the focused cell in the new region
            _this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);
        };
        _this.handleReplaceSelection = function (region) {
            var onSelection = _this.props.onSelection;
            // clear all selections and retain only the new one
            var nextSelectedRegions = [region];
            onSelection(nextSelectedRegions);
            // move the focused cell into the new selection
            _this.invokeOnFocusCallbackForRegion(region);
        };
        _this.invokeOnFocusCallbackForRegion = function (focusRegion, focusSelectionIndex) {
            if (focusSelectionIndex === void 0) { focusSelectionIndex = 0; }
            var onFocus = _this.props.onFocus;
            var focusedCellCoords = regions_1.Regions.getFocusCellCoordinatesFromRegion(focusRegion);
            onFocus(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));
        };
        // Other
        // =====
        _this.finishInteraction = function () {
            core_1.Utils.safeInvoke(_this.props.onSelectionEnd, _this.props.selectedRegions);
            _this.didExpandSelectionOnActivate = false;
        };
        return _this;
    }
    DragSelectable.prototype.render = function () {
        var draggableProps = this.getDraggableProps();
        return (React.createElement(draggable_1.Draggable, tslib_1.__assign({}, draggableProps, { preventDefault: false }), this.props.children));
    };
    DragSelectable.prototype.getDraggableProps = function () {
        return this.props.onSelection == null ? {} : {
            onActivate: this.handleActivate,
            onClick: this.handleClick,
            onDragEnd: this.handleDragEnd,
            onDragMove: this.handleDragMove,
        };
    };
    DragSelectable.prototype.shouldIgnoreMouseDown = function (event) {
        var _a = this.props.ignoredSelectors, ignoredSelectors = _a === void 0 ? [] : _a;
        var element = event.target;
        return !utils_1.Utils.isLeftClick(event)
            || this.props.disabled
            || ignoredSelectors.some(function (selector) { return element.closest(selector) != null; });
    };
    // Callbacks
    // =========
    DragSelectable.prototype.maybeInvokeSelectionCallback = function (nextSelectedRegions) {
        var _a = this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
        // invoke only if the selection changed. this is useful only on
        // mousemove; there's special handling for mousedown interactions that
        // target an already-selected region.
        if (!utils_1.Utils.deepCompareKeys(selectedRegions, nextSelectedRegions)) {
            onSelection(nextSelectedRegions);
        }
    };
    DragSelectable.prototype.expandSelectedRegions = function (regions, region, focusedCell) {
        if (regions.length === 0) {
            return [region];
        }
        else if (focusedCell != null) {
            var expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);
            return regions_1.Regions.update(regions, expandedRegion);
        }
        else {
            var expandedRegion = regions_1.Regions.expandRegion(regions[regions.length - 1], region);
            return regions_1.Regions.update(regions, expandedRegion);
        }
    };
    return DragSelectable;
}(React.Component));
DragSelectable.defaultProps = {
    allowMultipleSelection: false,
    disabled: false,
    selectedRegions: [],
};
DragSelectable = tslib_1.__decorate([
    PureRender
], DragSelectable);
exports.DragSelectable = DragSelectable;

//# sourceMappingURL=selectable.js.map
