{"version":3,"sources":["../src/tableBody.tsx"],"names":[],"mappings":"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","file":"tableBody.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { IProps, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as classNames from \"classnames\";\nimport * as React from \"react\";\nimport { emptyCellRenderer, ICellProps, ICellRenderer } from \"./cell/cell\";\nimport { Batcher } from \"./common/batcher\";\nimport { ICellCoordinates } from \"./common/cell\";\nimport * as Classes from \"./common/classes\";\nimport { ContextMenuTargetWrapper } from \"./common/contextMenuTargetWrapper\";\nimport { Grid, IColumnIndices, IRowIndices } from \"./common/grid\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nimport { Utils } from \"./common/utils\";\nimport { ICoordinateData } from \"./interactions/draggable\";\nimport { IContextMenuRenderer, MenuContext } from \"./interactions/menus\";\nimport { DragSelectable, ISelectableProps } from \"./interactions/selectable\";\nimport { ILocator } from \"./locator\";\nimport { IRegion, Regions } from \"./regions\";\n\nexport interface ITableBodyProps extends ISelectableProps, IRowIndices, IColumnIndices, IProps {\n    /**\n     * A cell renderer for the cells in the body.\n     */\n    cellRenderer: ICellRenderer;\n\n    /**\n     * The grid computes sizes of cells, rows, or columns from the\n     * configurable `columnWidths` and `rowHeights`.\n     */\n    grid: Grid;\n\n    /**\n     * If true, all `Cell`s render their loading state except for those who have\n     * their `loading` prop explicitly set to false.\n     */\n    loading: boolean;\n\n    /**\n     * Locates the row/column/cell given a mouse event.\n     */\n    locator: ILocator;\n\n    /**\n     * The number of columns to freeze to the left side of the table, counting from the leftmost column.\n     */\n    numFrozenColumns?: number;\n\n    /**\n     * The number of rows to freeze to the top of the table, counting from the topmost row.\n     */\n    numFrozenRows?: number;\n\n    /**\n     * An optional callback invoked when all cells in view have completely rendered.\n     */\n    onCompleteRender?: () => void;\n\n    /**\n     * The `Rect` bounds of the visible viewport with respect to its parent\n     * scrollable pane.\n     */\n    viewportRect: Rect;\n\n    /**\n     * An optional callback for displaying a context menu when right-clicking\n     * on the table body. The callback is supplied with an `IMenuContext`\n     * containing the `IRegion`s of interest.\n     */\n    renderBodyContextMenu?: IContextMenuRenderer;\n\n    /**\n     * Dictates how cells should be rendered. Supported modes are:\n     * - `RenderMode.BATCH`: renders cells in batches to improve\n     *   performance\n     * - `RenderMode.NONE`: renders cells synchronously all at once\n     * @default RenderMode.BATCH\n     */\n    renderMode?: RenderMode;\n}\n\n/**\n * For perf, we want to ignore changes to the `ISelectableProps` part of the\n * `ITableBodyProps` since those are only used when a context menu is launched.\n */\nconst UPDATE_PROPS_KEYS: Array<keyof ITableBodyProps> = [\n    \"focusedCell\",\n    \"grid\",\n    \"locator\",\n    \"viewportRect\",\n    \"cellRenderer\",\n    \"rowIndexStart\",\n    \"rowIndexEnd\",\n    \"columnIndexStart\",\n    \"columnIndexEnd\",\n    \"selectedRegions\",\n];\n\n/**\n * We don't want to reset the batcher when this set of keys changes. Any other\n * changes should reset the batcher's internal cache.\n */\nconst RESET_CELL_KEYS_BLACKLIST: Array<keyof ITableBodyProps> = [\n    \"columnIndexEnd\",\n    \"columnIndexStart\",\n    \"rowIndexEnd\",\n    \"rowIndexStart\",\n    \"viewportRect\",\n];\n\nexport class TableBody extends React.Component<ITableBodyProps, {}> {\n    public static defaultProps = {\n        loading: false,\n        renderMode: RenderMode.BATCH,\n    };\n\n    /**\n     * Returns the array of class names that must be applied to each table\n     * cell so that we can locate any cell based on its coordinate.\n     */\n    public static cellClassNames(rowIndex: number, columnIndex: number) {\n        return [\n            Classes.rowCellIndexClass(rowIndex),\n            Classes.columnCellIndexClass(columnIndex),\n        ];\n    }\n\n    private static cellReactKey(rowIndex: number, columnIndex: number) {\n        return `cell-${rowIndex}-${columnIndex}`;\n    }\n\n    private activationCell: ICellCoordinates;\n    private batcher = new Batcher<JSX.Element>();\n    private isRenderingBatchedCells = false;\n\n    public componentDidMount() {\n        this.maybeInvokeOnCompleteRender();\n    }\n\n    public shouldComponentUpdate(nextProps: ITableBodyProps) {\n        const propKeysWhitelist = { include: UPDATE_PROPS_KEYS };\n        return !Utils.shallowCompareKeys(this.props, nextProps, propKeysWhitelist);\n    }\n\n    public componentWillUpdate(nextProps?: ITableBodyProps) {\n        const resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };\n        const shouldResetBatcher = !Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);\n        if (shouldResetBatcher) {\n            this.batcher.reset();\n        }\n    }\n\n    public componentDidUpdate() {\n        this.maybeInvokeOnCompleteRender();\n    }\n\n    public componentWillUnmount() {\n        this.batcher.cancelOutstandingCallback();\n    }\n\n    public render() {\n        const {\n            allowMultipleSelection,\n            focusedCell,\n            grid,\n            numFrozenColumns,\n            numFrozenRows,\n            onFocus,\n            onSelection,\n            renderMode,\n            selectedRegions,\n            selectedRegionTransform,\n        } = this.props;\n\n        const cells = (renderMode === RenderMode.BATCH)\n            ? this.renderBatchedCells()\n            : this.renderAllCells();\n\n        const defaultStyle = grid.getRect().sizeStyle();\n\n        const style = {\n            height: (numFrozenRows != null) ? grid.getCumulativeHeightAt(numFrozenRows - 1) : defaultStyle.height,\n            width: (numFrozenColumns != null) ? grid.getCumulativeWidthAt(numFrozenColumns - 1) : defaultStyle.width,\n        };\n\n        return (\n            <DragSelectable\n                allowMultipleSelection={allowMultipleSelection}\n                focusedCell={focusedCell}\n                locateClick={this.locateClick}\n                locateDrag={this.locateDrag}\n                onFocus={onFocus}\n                onSelection={onSelection}\n                onSelectionEnd={this.handleSelectionEnd}\n                selectedRegions={selectedRegions}\n                selectedRegionTransform={selectedRegionTransform}\n            >\n                <ContextMenuTargetWrapper\n                    className={classNames(Classes.TABLE_BODY_VIRTUAL_CLIENT, Classes.TABLE_CELL_CLIENT)}\n                    renderContextMenu={this.renderContextMenu}\n                    style={style}\n                >\n                    {cells}\n                </ContextMenuTargetWrapper>\n            </DragSelectable>\n        );\n    }\n\n    public renderContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        const { grid, onFocus, onSelection, renderBodyContextMenu, selectedRegions } = this.props;\n        const { numRows, numCols } = grid;\n\n        if (renderBodyContextMenu == null) {\n            return undefined;\n        }\n\n        const targetRegion = this.locateClick(e.nativeEvent as MouseEvent);\n\n        let nextSelectedRegions: IRegion[] = selectedRegions;\n\n        // if the event did not happen within a selected region, clear all\n        // selections and select the right-clicked cell.\n        const foundIndex = Regions.findContainingRegion(selectedRegions, targetRegion);\n        if (foundIndex < 0) {\n            nextSelectedRegions = [targetRegion];\n            onSelection(nextSelectedRegions);\n\n            // move the focused cell to the new region.\n            const nextFocusedCell = {\n                ...Regions.getFocusCellCoordinatesFromRegion(targetRegion),\n                focusSelectionIndex: 0,\n            };\n            onFocus(nextFocusedCell);\n        }\n\n        const menuContext = new MenuContext(targetRegion, nextSelectedRegions, numRows, numCols);\n        const contextMenu = renderBodyContextMenu(menuContext);\n\n        return contextMenu == null ? undefined : contextMenu;\n    }\n\n    // Render modes\n    // ============\n\n    private renderBatchedCells() {\n        const {\n            columnIndexEnd,\n            columnIndexStart,\n            rowIndexEnd,\n            rowIndexStart,\n        } = this.props;\n\n        // render cells in batches\n        this.batcher.startNewBatch();\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                this.batcher.addArgsToBatch(rowIndex, columnIndex);\n            }\n        }\n        this.batcher.removeOldAddNew(this.renderNewCell);\n        if (!this.batcher.isDone()) {\n            this.batcher.idleCallback(() => this.forceUpdate());\n        }\n\n        const cells: Array<React.ReactElement<any>> = this.batcher.getList();\n        return cells;\n    }\n\n    private renderAllCells() {\n        const {\n            columnIndexEnd,\n            columnIndexStart,\n            grid,\n            rowIndexEnd,\n            rowIndexStart,\n        } = this.props;\n\n        const cells: Array<React.ReactElement<any>> = [];\n\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                const extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);\n                const isGhost = grid.isGhostIndex(rowIndex, columnIndex);\n                cells.push(this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost));\n            }\n        }\n\n        return cells;\n    }\n\n    // Cell renderers\n    // ==============\n\n    private renderNewCell = (row: number, col: number) => {\n        const {\n            columnIndexEnd,\n            grid,\n            rowIndexEnd,\n        } = this.props;\n        const extremaClasses = grid.getExtremaClasses(row, col, rowIndexEnd, columnIndexEnd);\n        const isGhost = grid.isGhostIndex(row, col);\n        return this.renderCell(row, col, extremaClasses, isGhost);\n    }\n\n    private renderCell = (rowIndex: number, columnIndex: number, extremaClasses: string[], isGhost: boolean) => {\n        const { cellRenderer, loading, grid } = this.props;\n        const baseCell = isGhost ? emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);\n        const className = classNames(\n            TableBody.cellClassNames(rowIndex, columnIndex),\n            extremaClasses,\n            {\n                [Classes.TABLE_CELL_GHOST]: isGhost,\n                [Classes.TABLE_CELL_LEDGER_ODD]: (rowIndex % 2) === 1,\n                [Classes.TABLE_CELL_LEDGER_EVEN]: (rowIndex % 2) === 0,\n            },\n            baseCell.props.className,\n        );\n        const key = TableBody.cellReactKey(rowIndex, columnIndex);\n        const rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);\n        const cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;\n\n        const style = { ...baseCell.props.style, ...Rect.style(rect) };\n        return React.cloneElement(baseCell, { className, key, loading: cellLoading, style } as ICellProps);\n    }\n\n    // Callbacks\n    // =========\n\n    private handleSelectionEnd = () => {\n        this.activationCell = null; // not strictly required, but good practice\n    }\n\n    private locateClick = (event: MouseEvent) => {\n        this.activationCell = this.props.locator.convertPointToCell(event.clientX, event.clientY);\n        return Regions.cell(this.activationCell.row, this.activationCell.col);\n    }\n\n    private locateDrag = (_event: MouseEvent, coords: ICoordinateData, returnEndOnly = false) => {\n        const start = this.activationCell;\n        const end = this.props.locator.convertPointToCell(coords.current[0], coords.current[1]);\n        return returnEndOnly\n            ? Regions.cell(end.row, end.col)\n            : Regions.cell(start.row, start.col, end.row, end.col);\n    }\n\n    private maybeInvokeOnCompleteRender() {\n        const { onCompleteRender, renderMode } = this.props;\n\n        if (renderMode === RenderMode.BATCH\n            && this.isRenderingBatchedCells\n            && this.batcher.isDone()\n        ) {\n            this.isRenderingBatchedCells = false;\n            CoreUtils.safeInvoke(onCompleteRender);\n        } else if (renderMode === RenderMode.NONE) {\n            CoreUtils.safeInvoke(onCompleteRender);\n        }\n    }\n}\n"]}