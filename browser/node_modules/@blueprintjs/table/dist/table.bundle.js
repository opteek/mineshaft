(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else if(typeof define === 'function' && define.amd)
		define(["window", "classNames", "React", "Blueprint.Core", "ReactDOM"], factory);
	else if(typeof exports === 'object')
		exports["Table"] = factory(require("window"), require("classNames"), require("React"), require("Blueprint.Core"), require("ReactDOM"));
	else
		root["Blueprint"] = root["Blueprint"] || {}, root["Blueprint"]["Table"] = factory(root["window"], root["classNames"], root["React"], root["Blueprint.Core"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_15__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	__webpack_require__(1);
	var cell_1 = __webpack_require__(2);
	exports.Cell = cell_1.Cell;
	var editableCell_1 = __webpack_require__(14);
	exports.EditableCell = editableCell_1.EditableCell;
	var jsonFormat_1 = __webpack_require__(18);
	exports.JSONFormat = jsonFormat_1.JSONFormat;
	var truncatedFormat_1 = __webpack_require__(19);
	exports.TruncatedPopoverMode = truncatedFormat_1.TruncatedPopoverMode;
	exports.TruncatedFormat = truncatedFormat_1.TruncatedFormat;
	var column_1 = __webpack_require__(20);
	exports.Column = column_1.Column;
	var index_1 = __webpack_require__(21);
	exports.Clipboard = index_1.Clipboard;
	exports.Grid = index_1.Grid;
	exports.Rect = index_1.Rect;
	exports.RenderMode = index_1.RenderMode;
	exports.Utils = index_1.Utils;
	var draggable_1 = __webpack_require__(16);
	exports.Draggable = draggable_1.Draggable;
	var menus_1 = __webpack_require__(28);
	exports.CopyCellsMenuItem = menus_1.CopyCellsMenuItem;
	var resizeHandle_1 = __webpack_require__(31);
	exports.Orientation = resizeHandle_1.Orientation;
	exports.ResizeHandle = resizeHandle_1.ResizeHandle;
	var selectable_1 = __webpack_require__(32);
	exports.DragSelectable = selectable_1.DragSelectable;
	var columnHeaderCell_1 = __webpack_require__(35);
	exports.ColumnHeaderCell = columnHeaderCell_1.ColumnHeaderCell;
	exports.HorizontalCellDivider = columnHeaderCell_1.HorizontalCellDivider;
	var rowHeaderCell_1 = __webpack_require__(37);
	exports.RowHeaderCell = rowHeaderCell_1.RowHeaderCell;
	var editableName_1 = __webpack_require__(38);
	exports.EditableName = editableName_1.EditableName;
	var regions_1 = __webpack_require__(24);
	exports.ColumnLoadingOption = regions_1.ColumnLoadingOption;
	exports.RegionCardinality = regions_1.RegionCardinality;
	exports.Regions = regions_1.Regions;
	exports.RowLoadingOption = regions_1.RowLoadingOption;
	exports.SelectionModes = regions_1.SelectionModes;
	exports.TableLoadingOption = regions_1.TableLoadingOption;
	var table_1 = __webpack_require__(39);
	exports.Table = table_1.Table;
	
	//# sourceMappingURL=index.js.map


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var core_1 = __webpack_require__(8);
	var loadableContent_1 = __webpack_require__(9);
	exports.emptyCellRenderer = function () { return React.createElement(Cell, null); };
	var Cell = (function (_super) {
	    tslib_1.__extends(Cell, _super);
	    function Cell() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Cell.prototype.shouldComponentUpdate = function (nextProps) {
	        // deeply compare "style," because a new but identical object might have been provided.
	        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: ["style"] })
	            || !utils_1.Utils.deepCompareKeys(this.props.style, nextProps.style);
	    };
	    Cell.prototype.render = function () {
	        var _a = this.props, style = _a.style, intent = _a.intent, interactive = _a.interactive, loading = _a.loading, tooltip = _a.tooltip, truncated = _a.truncated, className = _a.className, wrapText = _a.wrapText;
	        var classes = classNames(Classes.TABLE_CELL, core_1.Classes.intentClass(intent), (_b = {},
	            _b[Classes.TABLE_CELL_INTERACTIVE] = interactive,
	            _b[core_1.Classes.LOADING] = loading,
	            _b[Classes.TABLE_TRUNCATED_CELL] = truncated,
	            _b), className);
	        var textClasses = classNames((_c = {},
	            _c[Classes.TABLE_TRUNCATED_TEXT] = truncated,
	            _c[Classes.TABLE_NO_WRAP_TEXT] = !wrapText,
	            _c));
	        // add width and height to the children, for use in shouldComponentUpdate in truncatedFormat
	        // note: these aren't actually used by truncated format, just in shouldComponentUpdate
	        var modifiedChildren = React.Children.map(this.props.children, function (child) {
	            if (style != null && React.isValidElement(child)) {
	                return React.cloneElement(child, { parentCellHeight: style.height, parentCellWidth: style.width });
	            }
	            return child;
	        });
	        var content = React.createElement("div", { className: textClasses }, modifiedChildren);
	        return (React.createElement("div", { className: classes, style: style, title: tooltip },
	            React.createElement(loadableContent_1.LoadableContent, { loading: loading, variableLength: true }, content)));
	        var _b, _c;
	    };
	    return Cell;
	}(React.Component));
	Cell.defaultProps = {
	    truncated: true,
	    wrapText: false,
	};
	exports.Cell = Cell;
	
	//# sourceMappingURL=cell.js.map


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global global, define, System, Reflect, Promise */
	var __extends;
	var __assign;
	var __rest;
	var __decorate;
	var __param;
	var __metadata;
	var __awaiter;
	var __generator;
	var __exportStar;
	var __values;
	var __read;
	var __spread;
	var __await;
	var __asyncGenerator;
	var __asyncDelegator;
	var __asyncValues;
	(function (factory) {
	    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    else if (typeof module === "object" && typeof module.exports === "object") {
	        factory(createExporter(root, createExporter(module.exports)));
	    }
	    else {
	        factory(createExporter(root));
	    }
	    function createExporter(exports, previous) {
	        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
	    }
	})
	(function (exporter) {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	    __extends = function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	
	    __assign = Object.assign || function (t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	
	    __rest = function (s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
	                t[p[i]] = s[p[i]];
	        return t;
	    };
	
	    __decorate = function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	
	    __param = function (paramIndex, decorator) {
	        return function (target, key) { decorator(target, key, paramIndex); }
	    };
	
	    __metadata = function (metadataKey, metadataValue) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	    };
	
	    __awaiter = function (thisArg, _arguments, P, generator) {
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    };
	
	    __generator = function (thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [0, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    };
	
	    __exportStar = function (m, exports) {
	        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	    };
	
	    __values = function (o) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
	        if (m) return m.call(o);
	        return {
	            next: function () {
	                if (o && i >= o.length) o = void 0;
	                return { value: o && o[i++], done: !o };
	            }
	        };
	    };
	
	    __read = function (o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    };
	
	    __spread = function () {
	        for (var ar = [], i = 0; i < arguments.length; i++)
	            ar = ar.concat(__read(arguments[i]));
	        return ar;
	    };
	
	    __await = function (v) {
	        return this instanceof __await ? (this.v = v, this) : new __await(v);
	    };
	
	    __asyncGenerator = function (thisArg, _arguments, generator) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var g = generator.apply(thisArg, _arguments || []), i, q = [];
	        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
	        function fulfill(value) { resume("next", value); }
	        function reject(value) { resume("throw", value); }
	        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	    };
	
	    __asyncDelegator = function (o) {
	        var i, p;
	        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
	    };
	
	    __asyncValues = function (o) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var m = o[Symbol.asyncIterator];
	        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
	    };
	
	    exporter("__extends", __extends);
	    exporter("__assign", __assign);
	    exporter("__rest", __rest);
	    exporter("__decorate", __decorate);
	    exporter("__param", __param);
	    exporter("__metadata", __metadata);
	    exporter("__awaiter", __awaiter);
	    exporter("__generator", __generator);
	    exporter("__exportStar", __exportStar);
	    exporter("__values", __values);
	    exporter("__read", __read);
	    exporter("__spread", __spread);
	    exporter("__await", __await);
	    exporter("__asyncGenerator", __asyncGenerator);
	    exporter("__asyncDelegator", __asyncDelegator);
	    exporter("__asyncValues", __asyncValues);
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/*
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TABLE_BODY = "bp-table-body";
	exports.TABLE_BODY_SCROLL_CLIENT = "bp-table-body-scroll-client";
	exports.TABLE_BODY_VIRTUAL_CLIENT = "bp-table-body-virtual-client";
	exports.TABLE_BOTTOM_CONTAINER = "bp-table-bottom-container";
	exports.TABLE_CELL = "bp-table-cell";
	exports.TABLE_CELL_CLIENT = "bp-table-cell-client";
	exports.TABLE_CELL_GHOST = "bp-table-cell-ghost";
	exports.TABLE_CELL_INTERACTIVE = "bp-table-cell-interactive";
	exports.TABLE_CELL_LEDGER_EVEN = "bp-table-cell-ledger-even";
	exports.TABLE_CELL_LEDGER_ODD = "bp-table-cell-ledger-odd";
	exports.TABLE_COLUMN_HEADER_TR = "bp-table-column-header-tr";
	exports.TABLE_COLUMN_HEADERS = "bp-table-column-headers";
	exports.TABLE_COLUMN_HEADER_CELL = "bp-table-column-header-cell";
	exports.TABLE_COLUMN_NAME = "bp-table-column-name";
	exports.TABLE_COLUMN_NAME_TEXT = "bp-table-column-name-text";
	exports.TABLE_CONTAINER = "bp-table-container";
	exports.TABLE_DRAGGING = "bp-table-dragging";
	exports.TABLE_EDITABLE_NAME = "bp-table-editable-name";
	exports.TABLE_FOCUS_REGION = "bp-table-focus-region";
	exports.TABLE_HAS_INTERACTION_BAR = "bp-table-has-interaction-bar";
	exports.TABLE_HAS_REORDER_HANDLE = "bp-table-has-reorder-handle";
	exports.TABLE_HEADER = "bp-table-header";
	exports.TABLE_HEADER_ACTIVE = "bp-table-header-active";
	exports.TABLE_HEADER_CONTENT = "bp-table-header-content";
	exports.TABLE_HEADER_REORDERABLE = "bp-table-header-reorderable";
	exports.TABLE_HEADER_SELECTED = "bp-table-header-selected";
	exports.TABLE_HORIZONTAL_CELL_DIVIDER = "bp-table-horizontal-cell-divider";
	exports.TABLE_HORIZONTAL_GUIDE = "bp-table-horizontal-guide";
	exports.TABLE_INTERACTION_BAR = "bp-table-interaction-bar";
	exports.TABLE_LAST_IN_COLUMN = "bp-table-last-in-column";
	exports.TABLE_LAST_IN_ROW = "bp-table-last-in-row";
	exports.TABLE_MENU = "bp-table-menu";
	exports.TABLE_NO_HORIZONTAL_SCROLL = "bp-table-no-horizontal-scroll";
	exports.TABLE_NO_LAYOUT = "bp-table-no-layout";
	exports.TABLE_NO_VERTICAL_SCROLL = "bp-table-no-vertical-scroll";
	exports.TABLE_NO_WRAP_TEXT = "bp-table-no-wrap-text";
	exports.TABLE_NULL = "bp-table-null";
	exports.TABLE_OVERLAY = "bp-table-overlay";
	exports.TABLE_OVERLAY_LAYER = "bp-table-overlay-layer";
	exports.TABLE_POPOVER_WHITESPACE_NORMAL = "bp-table-popover-whitespace-normal";
	exports.TABLE_POPOVER_WHITESPACE_PRE = "bp-table-popover-whitespace-pre";
	exports.TABLE_QUADRANT = "bp-table-quadrant";
	exports.TABLE_QUADRANT_BODY_CONTAINER = "bp-table-quadrant-body-container";
	exports.TABLE_QUADRANT_LEFT = "bp-table-quadrant-left";
	exports.TABLE_QUADRANT_MAIN = "bp-table-quadrant-main";
	exports.TABLE_QUADRANT_SCROLL_CONTAINER = "bp-table-quadrant-scroll-container";
	exports.TABLE_QUADRANT_STACK = "bp-table-quadrant-stack";
	exports.TABLE_QUADRANT_TOP = "bp-table-quadrant-top";
	exports.TABLE_QUADRANT_TOP_LEFT = "bp-table-quadrant-top-left";
	exports.TABLE_REGION = "bp-table-region";
	exports.TABLE_REORDER_HANDLE = "bp-table-reorder-handle";
	exports.TABLE_REORDER_HANDLE_TARGET = "bp-table-reorder-handle-target";
	exports.TABLE_REORDERING = "bp-table-reordering";
	exports.TABLE_RESIZE_GUIDES = "bp-table-resize-guides";
	exports.TABLE_RESIZE_HANDLE = "bp-table-resize-handle";
	exports.TABLE_RESIZE_HANDLE_TARGET = "bp-table-resize-handle-target";
	exports.TABLE_RESIZE_HORIZONTAL = "bp-table-resize-horizontal";
	exports.TABLE_RESIZE_SENSOR = "bp-table-resize-sensor";
	exports.TABLE_RESIZE_SENSOR_EXPAND = "bp-table-resize-sensor-expand";
	exports.TABLE_RESIZE_SENSOR_SHRINK = "bp-table-resize-sensor-shrink";
	exports.TABLE_RESIZE_VERTICAL = "bp-table-resize-vertical";
	exports.TABLE_ROUNDED_LAYOUT = "bp-table-rounded-layout";
	exports.TABLE_ROW_HEADERS = "bp-table-row-headers";
	exports.TABLE_ROW_HEADERS_CELLS_CONTAINER = "bp-table-row-headers-cells-container";
	exports.TABLE_ROW_NAME = "bp-table-row-name";
	exports.TABLE_ROW_NAME_TEXT = "bp-table-row-name-text";
	exports.TABLE_SELECTION_ENABLED = "bp-table-selection-enabled";
	exports.TABLE_SELECTION_REGION = "bp-table-selection-region";
	exports.TABLE_TH_MENU = "bp-table-th-menu";
	exports.TABLE_TH_MENU_CONTAINER = "bp-table-th-menu-container";
	exports.TABLE_TH_MENU_CONTAINER_BACKGROUND = "bp-table-th-menu-container-background";
	exports.TABLE_TH_MENU_OPEN = "bp-table-th-menu-open";
	exports.TABLE_THEAD = "bp-table-thead";
	exports.TABLE_TOP_CONTAINER = "bp-table-top-container";
	exports.TABLE_TRUNCATED_CELL = "bp-table-truncated-cell";
	exports.TABLE_TRUNCATED_FORMAT = "bp-table-truncated-format";
	exports.TABLE_TRUNCATED_FORMAT_TEXT = "bp-table-truncated-format-text";
	exports.TABLE_TRUNCATED_POPOVER = "bp-table-truncated-popover";
	exports.TABLE_TRUNCATED_POPOVER_TARGET = "bp-table-truncated-popover-target";
	exports.TABLE_TRUNCATED_TEXT = "bp-table-truncated-text";
	exports.TABLE_TRUNCATED_VALUE = "bp-table-truncated-value";
	exports.TABLE_VERTICAL_GUIDE = "bp-table-vertical-guide";
	/** Common code for row and column index class generator functions, since they're essentially the same. */
	function dimensionIndexClass(classPrefix, index) {
	    if (index == null) {
	        return undefined;
	    }
	    if (typeof index === "number") {
	        return "" + classPrefix + index;
	    }
	    return index.indexOf(classPrefix) === 0 ? index : "" + classPrefix + index;
	}
	/** Return CSS class for table colummn index, whether or not 'bp-table-col-' prefix is included. */
	function columnIndexClass(columnIndex) {
	    return dimensionIndexClass("bp-table-col-", columnIndex);
	}
	exports.columnIndexClass = columnIndexClass;
	/** Return CSS class for table row index, whether or not 'bp-table-row-' prefix is included. */
	function rowIndexClass(rowIndex) {
	    return dimensionIndexClass("bp-table-row-", rowIndex);
	}
	exports.rowIndexClass = rowIndexClass;
	/** Return CSS class for table colummn cell index, whether or not 'bp-table-cell-col-' prefix is included. */
	function columnCellIndexClass(columnIndex) {
	    return dimensionIndexClass("bp-table-cell-col-", columnIndex);
	}
	exports.columnCellIndexClass = columnCellIndexClass;
	/** Return CSS class for table row cell index, whether or not 'bp-table-cell-row-' prefix is included. */
	function rowCellIndexClass(rowIndex) {
	    return dimensionIndexClass("bp-table-cell-row-", rowIndex);
	}
	exports.rowCellIndexClass = rowCellIndexClass;
	
	//# sourceMappingURL=classes.js.map


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	;
	// tslint:enable
	/**
	 * Since Firefox doesn't provide a computed "font" property, we manually
	 * construct it using the ordered properties that can be specifed in CSS.
	 */
	var CSS_FONT_PROPERTIES = [
	    "font-style",
	    "font-variant",
	    "font-weight",
	    "font-size",
	    "font-family",
	];
	exports.Utils = {
	    /**
	     * Returns a clone of the ReactElement with a className that includes the
	     * element's original className and any other classes passed in with variadic
	     * arguments matching the `classNames` api.
	     */
	    assignClasses: function (elem) {
	        var extendedClasses = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            extendedClasses[_i - 1] = arguments[_i];
	        }
	        var classes = classNames.apply(void 0, [elem.props.className].concat(extendedClasses));
	        return React.cloneElement(elem, { className: classes });
	    },
	    /**
	     * Invokes the callback `n` times, collecting the results in an array, which
	     * is the return value. Similar to _.times
	     */
	    times: function (n, callback) {
	        var result = Array(n);
	        for (var index = 0; index < n; index++) {
	            result[index] = callback(index);
	        }
	        return result;
	    },
	    /**
	     * Takes an array of numbers, returns an array of numbers of the same length in which each
	     * value is the sum of current and previous values in the input array.
	     *
	     * Example input:  [10, 20, 50]
	     *         output: [10, 30, 80]
	     */
	    accumulate: function (numbers) {
	        var result = [];
	        var sum = 0;
	        for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {
	            var num = numbers_1[_i];
	            sum += num;
	            result.push(sum);
	        }
	        return result;
	    },
	    /**
	     * Returns traditional spreadsheet-style column names
	     * e.g. (A, B, ..., Z, AA, AB, ..., ZZ, AAA, AAB, ...).
	     *
	     * Note that this isn't technically mathematically equivalent to base 26 since
	     * there is no zero element.
	     */
	    toBase26Alpha: function (num) {
	        var str = "";
	        while (true) {
	            var letter = num % 26;
	            str = String.fromCharCode(65 + letter) + str;
	            num = num - letter;
	            if (num <= 0) {
	                return str;
	            }
	            num = (num / 26) - 1;
	        }
	    },
	    /**
	     * Returns traditional spreadsheet-style cell names
	     * e.g. (A1, B2, ..., Z44, AA1) with rows 1-indexed.
	     */
	    toBase26CellName: function (rowIndex, columnIndex) {
	        return "" + exports.Utils.toBase26Alpha(columnIndex) + (rowIndex + 1);
	    },
	    /**
	     * Performs the binary search algorithm to find the index of the `value`
	     * parameter in a sorted list of numbers. If `value` is not in the list, the
	     * index where `value` can be inserted to maintain the sort is returned.
	     *
	     * Unlike a typical binary search implementation, we use a `lookup`
	     * callback to access the sorted list of numbers instead of an array. This
	     * avoids additional storage overhead.
	     *
	     * We use this to, for example, find the index of a row/col given its client
	     * coordinate.
	     *
	     * Adapted from lodash https://github.com/lodash/lodash/blob/4.11.2/lodash.js#L3579
	     *
	     * @param value - the query value
	     * @param high - the length of the sorted list of numbers
	     * @param lookup - returns the number from the list at the supplied index
	     */
	    binarySearch: function (value, high, lookup) {
	        var low = 0;
	        while (low < high) {
	            var mid = Math.floor((low + high) / 2.0);
	            var computed = lookup(mid);
	            if (computed < value) {
	                low = mid + 1;
	            }
	            else {
	                high = mid;
	            }
	        }
	        return high;
	    },
	    /**
	     * Returns a copy of the array that will have a length of the supplied parameter.
	     * If the array is too long, it will be truncated. If it is too short, it will be
	     * filled with the suppleid `fillValue` argument.
	     *
	     * @param array - the `Array` to copy and adjust
	     * @param length - the target length of the array
	     * @param fillValue - the value to add to the array if it is too short
	     */
	    arrayOfLength: function (array, length, fillValue) {
	        if (array.length > length) {
	            return array.slice(0, length);
	        }
	        array = array.slice();
	        while (array.length < length) {
	            array.push(fillValue);
	        }
	        return array;
	    },
	    /**
	     * Takes in one full array of values and one sparse array of the same
	     * length and type. Returns a copy of the `defaults` array, where each
	     * value is replaced with the corresponding non-null value at the same
	     * index in `sparseOverrides`.
	     *
	     * @param defaults - the full array of default values
	     * @param sparseOverrides - the sparse array of override values
	     */
	    assignSparseValues: function (defaults, sparseOverrides) {
	        if (sparseOverrides == null || defaults.length !== sparseOverrides.length) {
	            return defaults;
	        }
	        defaults = defaults.slice();
	        for (var i = 0; i < defaults.length; i++) {
	            var override = sparseOverrides[i];
	            if (override != null) {
	                defaults[i] = override;
	            }
	        }
	        return defaults;
	    },
	    /**
	     * Measures the bounds of supplied element's textContent.
	     *
	     * We use the computed font from the supplied element and a non-DOM canvas
	     * context to measure the text.
	     *
	     * Returns a `TextMetrics` object.
	     */
	    measureElementTextContent: function (element) {
	        var context = document.createElement("canvas").getContext("2d");
	        var style = getComputedStyle(element, null);
	        context.font = CSS_FONT_PROPERTIES.map(function (prop) { return style.getPropertyValue(prop); }).join(" ");
	        return context.measureText(element.textContent);
	    },
	    /**
	     * Given a number, returns a value that is clamped within a
	     * minimum/maximum bounded range. The minimum and maximum are optional. If
	     * either is missing, that extrema limit is not applied.
	     *
	     * Assumes max >= min.
	     */
	    clamp: function (value, min, max) {
	        if (min != null && value < min) {
	            value = min;
	        }
	        if (max != null && value > max) {
	            value = max;
	        }
	        return value;
	    },
	    /**
	     * Shallow comparison between objects. If `keys` is provided, just that subset of keys will be
	     * compared; otherwise, all keys will be compared.
	     */
	    shallowCompareKeys: function (objA, objB, keys) {
	        // treat `null` and `undefined` as the same
	        if (objA == null && objB == null) {
	            return true;
	        }
	        else if (objA == null || objB == null) {
	            return false;
	        }
	        else if (Array.isArray(objA) || Array.isArray(objB)) {
	            return false;
	        }
	        else if (keys != null) {
	            return _shallowCompareKeys(objA, objB, keys);
	        }
	        else {
	            // shallowly compare all keys from both objects
	            var keysA = Object.keys(objA);
	            var keysB = Object.keys(objB);
	            return _shallowCompareKeys(objA, objB, { include: keysA })
	                && _shallowCompareKeys(objA, objB, { include: keysB });
	        }
	    },
	    /**
	     * Deep comparison between objects. If `keys` is provided, just that subset of keys will be
	     * compared; otherwise, all keys will be compared.
	     */
	    deepCompareKeys: function (objA, objB, keys) {
	        if (objA === objB) {
	            return true;
	        }
	        else if (objA == null && objB == null) {
	            // treat `null` and `undefined` as the same
	            return true;
	        }
	        else if (objA == null || objB == null) {
	            return false;
	        }
	        else if (Array.isArray(objA) || Array.isArray(objB)) {
	            return exports.Utils.arraysEqual(objA, objB, exports.Utils.deepCompareKeys);
	        }
	        else if (_isSimplePrimitiveType(objA) || _isSimplePrimitiveType(objB)) {
	            return objA === objB;
	        }
	        else if (keys != null) {
	            return _deepCompareKeys(objA, objB, keys);
	        }
	        else if (objA.constructor !== objB.constructor) {
	            return false;
	        }
	        else {
	            var keysA = Object.keys(objA);
	            var keysB = Object.keys(objB);
	            if (keysA == null || keysB == null) {
	                return false;
	            }
	            if (keysA.length === 0 && keysB.length === 0) {
	                return true;
	            }
	            return exports.Utils.arraysEqual(keysA, keysB) && _deepCompareKeys(objA, objB, keysA);
	        }
	    },
	    /**
	     * Returns a descriptive object for each key whose values are shallowly unequal between two
	     * provided objects. Useful for debugging shouldComponentUpdate.
	     */
	    getShallowUnequalKeyValues: function (objA, objB, keys) {
	        // default param values let null values pass through, so we have to take this more thorough approach
	        var definedObjA = (objA == null) ? {} : objA;
	        var definedObjB = (objB == null) ? {} : objB;
	        var filteredKeys = _filterKeys(definedObjA, definedObjB, keys == null ? { exclude: [] } : keys);
	        return _getUnequalKeyValues(definedObjA, definedObjB, filteredKeys, function (a, b, key) { return exports.Utils.shallowCompareKeys(a, b, { include: [key] }); });
	    },
	    /**
	     * Returns a descriptive object for each key whose values are deeply unequal between two
	     * provided objects. Useful for debugging shouldComponentUpdate.
	     */
	    getDeepUnequalKeyValues: function (objA, objB, keys) {
	        var definedObjA = (objA == null) ? {} : objA;
	        var definedObjB = (objB == null) ? {} : objB;
	        var filteredKeys = (keys == null) ? _unionKeys(definedObjA, definedObjB) : keys;
	        return _getUnequalKeyValues(definedObjA, definedObjB, filteredKeys, function (a, b, key) { return exports.Utils.deepCompareKeys(a, b, [key]); });
	    },
	    /**
	     * When reordering a contiguous block of rows or columns to a new index, we show a preview guide
	     * at the absolute index in the original ordering but emit the new index in the reordered list.
	     * This function converts an absolute "guide" index to a relative "reordered" index.
	     *
	     * Example: Say we want to move the first three columns two spots to the right. While we drag, a
	     * vertical guide is shown to preview where we'll be dropping the columns. (In the following
	     * ASCII art, `*` denotes a selected column, `·` denotes a cell border, and `|` denotes a
	     * vertical guide).
	     *
	     *     Before mousedown:
	     *     · 0 · 1 · 2 · 3 · 4 · 5 ·
	     *       *   *   *
	     *
	     *     During mousemove two spots to the right:
	     *     · 0 · 1 · 2 · 3 · 4 | 5 ·
	     *       *   *   *
	     *
	     *     After mouseup:
	     *     · 3 · 4 · 0 · 1 · 2 · 5 ·
	     *               *   *   *
	     *
	     * Note that moving the three columns beyond index 4 effectively moves them two spots rightward.
	     *
	     * In this case, the inputs to this function would be:
	     *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)
	     *     - newIndex: 5 (the index on whose left boundary the guide appears in the original ordering)
	     *     - length: 3 (the number of columns to move)
	     *
	     * The return value will then be 2, the left-most index of the columns in the new ordering.
	     */
	    guideIndexToReorderedIndex: function (oldIndex, newIndex, length) {
	        if (newIndex < oldIndex) {
	            return newIndex;
	        }
	        else if (oldIndex <= newIndex && newIndex < oldIndex + length) {
	            return oldIndex;
	        }
	        else {
	            return Math.max(0, newIndex - length);
	        }
	    },
	    /**
	     * When reordering a contiguous block of rows or columns to a new index, we show a preview guide
	     * at the absolute index in the original ordering but emit the new index in the reordered list.
	     * This function converts a relative "reordered"" index to an absolute "guide" index.
	     *
	     * For the scenario in the example above, the inputs to this function would be:
	     *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)
	     *     - newIndex: 2 (the left-most index of the selected column range in the new ordering)
	     *     - length: 3 (the number of columns to move)
	     *
	     * The return value will then be 5, the index on whose left boundary the guide should appear in
	     * the original ordering.
	     */
	    reorderedIndexToGuideIndex: function (oldIndex, newIndex, length) {
	        return (newIndex <= oldIndex) ? newIndex : newIndex + length;
	    },
	    /**
	     * Returns a copy of the provided array with the `length` contiguous elements starting at the
	     * `from` index reordered to start at the `to` index.
	     *
	     * For example, given the array [A,B,C,D,E,F], reordering the 3 contiguous elements starting at
	     * index 1 (B, C, and D) to start at index 2 would yield [A,E,B,C,D,F].
	     */
	    reorderArray: function (array, from, to, length) {
	        if (length === void 0) { length = 1; }
	        if (length === 0 || length === array.length || from === to) {
	            // return an unchanged copy
	            return array.slice();
	        }
	        if (length < 0 || length > array.length || from + length > array.length) {
	            return undefined;
	        }
	        var before = array.slice(0, from);
	        var within = array.slice(from, from + length);
	        var after = array.slice(from + length);
	        var result = [];
	        var i = 0;
	        var b = 0;
	        var w = 0;
	        var a = 0;
	        while (i < to) {
	            if (b < before.length) {
	                result.push(before[b]);
	                b += 1;
	            }
	            else {
	                result.push(after[a]);
	                a += 1;
	            }
	            i += 1;
	        }
	        while (w < length) {
	            result.push(within[w]);
	            w += 1;
	            i += 1;
	        }
	        while (i < array.length) {
	            if (b < before.length) {
	                result.push(before[b]);
	                b += 1;
	            }
	            else {
	                result.push(after[a]);
	                a += 1;
	            }
	            i += 1;
	        }
	        return result;
	    },
	    /**
	     * Returns true if the mouse event was triggered by the left mouse button.
	     */
	    isLeftClick: function (event) {
	        return event.button === 0;
	    },
	    /**
	     * Returns true if the arrays are equal. Elements will be shallowly compared by default, or they
	     * will be compared using the custom `compare` function if one is provided.
	     */
	    arraysEqual: function (arrA, arrB, compare) {
	        if (compare === void 0) { compare = function (a, b) { return a === b; }; }
	        // treat `null` and `undefined` as the same
	        if (arrA == null && arrB == null) {
	            return true;
	        }
	        else if (arrA == null || arrB == null || arrA.length !== arrB.length) {
	            return false;
	        }
	        else {
	            return arrA.every(function (a, i) { return compare(a, arrB[i]); });
	        }
	    },
	};
	/**
	 * Partial shallow comparison between objects using the given list of keys.
	 */
	function _shallowCompareKeys(objA, objB, keys) {
	    return _filterKeys(objA, objB, keys).every(function (key) {
	        return objA.hasOwnProperty(key) === objB.hasOwnProperty(key)
	            && objA[key] === objB[key];
	    });
	}
	/**
	 * Partial deep comparison between objects using the given list of keys.
	 */
	function _deepCompareKeys(objA, objB, keys) {
	    return keys.every(function (key) {
	        return objA.hasOwnProperty(key) === objB.hasOwnProperty(key)
	            && exports.Utils.deepCompareKeys(objA[key], objB[key]);
	    });
	}
	function _isSimplePrimitiveType(value) {
	    return typeof value === "number"
	        || typeof value === "string"
	        || typeof value === "boolean";
	}
	function _filterKeys(objA, objB, keys) {
	    if (isWhitelist(keys)) {
	        return keys.include;
	    }
	    else {
	        var keysA = Object.keys(objA);
	        var keysB = Object.keys(objB);
	        // merge keys from both objects into a big set for quick access
	        var keySet_1 = _arrayToObject(keysA.concat(keysB));
	        // delete blacklisted keys from the key set
	        keys.exclude.forEach(function (key) { return delete keySet_1[key]; });
	        // return the remaining keys as an array
	        return Object.keys(keySet_1);
	    }
	}
	function isWhitelist(keys) {
	    return keys != null && keys.include != null;
	}
	function _arrayToObject(arr) {
	    return arr.reduce(function (obj, element) {
	        obj[element] = true;
	        return obj;
	    }, {});
	}
	function _getUnequalKeyValues(objA, objB, keys, compareFn) {
	    var unequalKeys = keys.filter(function (key) { return !compareFn(objA, objB, key); });
	    var unequalKeyValues = unequalKeys.map(function (key) { return ({
	        key: key,
	        valueA: objA[key],
	        valueB: objB[key],
	    }); });
	    return unequalKeyValues;
	}
	function _unionKeys(objA, objB) {
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    var concatKeys = keysA.concat(keysB);
	    var keySet = _arrayToObject(concatKeys);
	    return Object.keys(keySet);
	}
	
	//# sourceMappingURL=utils.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = Blueprint.Core;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var core_1 = __webpack_require__(8);
	// This class expects a single, non-string child.
	var LoadableContent = (function (_super) {
	    tslib_1.__extends(LoadableContent, _super);
	    function LoadableContent(props) {
	        var _this = _super.call(this, props) || this;
	        _this.style = _this.calculateStyle(props.variableLength);
	        return _this;
	    }
	    LoadableContent.prototype.componentWillReceiveProps = function (nextProps) {
	        if (!this.props.loading && nextProps.loading || this.props.variableLength !== nextProps.variableLength) {
	            this.style = this.calculateStyle(nextProps.variableLength);
	        }
	    };
	    LoadableContent.prototype.render = function () {
	        if (this.props.loading) {
	            return React.createElement("div", { className: core_1.Classes.SKELETON, style: this.style });
	        }
	        return React.Children.only(this.props.children);
	    };
	    LoadableContent.prototype.calculateStyle = function (variableLength) {
	        var skeletonLength = variableLength ? 75 - Math.floor(Math.random() * 11) * 5 : 100;
	        return { width: skeletonLength + "%" };
	    };
	    return LoadableContent;
	}(React.Component));
	LoadableContent = tslib_1.__decorate([
	    PureRender
	], LoadableContent);
	exports.LoadableContent = LoadableContent;
	
	//# sourceMappingURL=loadableContent.js.map


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @author Félix Girault <felix.girault@gmail.com>
	 * @license MIT
	 */
	'use strict';
	
	var warning = __webpack_require__(11);
	var shallowEqual = __webpack_require__(13);
	
	
	
	/**
	 * Tells if a component should update given it's next props
	 * and state.
	 *
	 * @param object nextProps Next props.
	 * @param object nextState Next state.
	 */
	function shouldComponentUpdate(nextProps, nextState) {
	  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
	}
	
	/**
	 * Returns a text description of the component that can be
	 * used to identify it in error messages.
	 *
	 * @see https://github.com/facebook/react/blob/v15.4.0-rc.3/src/renderers/shared/stack/reconciler/ReactCompositeComponent.js#L1143
	 * @param {function} component The component.
	 * @return {string} The name of the component.
	 */
	function getComponentName(component) {
	  var constructor = component.prototype && component.prototype.constructor;
	
	  return (
	    component.displayName
	    || (constructor && constructor.displayName)
	    || component.name
	    || (constructor && constructor.name)
	    || 'a component'
	  );
	}
	
	/**
	 * Makes the given component "pure".
	 *
	 * @param object component Component.
	 */
	function pureRenderDecorator(component) {
	  if (component.prototype.shouldComponentUpdate !== undefined) {
	    // We're not using the condition mecanism of warning()
	    // here to avoid useless calls to getComponentName().
	    warning(
	      false,
	      'Cannot decorate `%s` with @pureRenderDecorator, '
	      + 'because it already implements `shouldComponentUpdate().',
	      getComponentName(component)
	    )
	  }
	
	  component.prototype.shouldComponentUpdate = shouldComponentUpdate;
	  return component;
	}
	
	
	
	module.exports = pureRenderDecorator;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(12);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (false) {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(5);
	var ReactDOM = __webpack_require__(15);
	var core_1 = __webpack_require__(8);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var draggable_1 = __webpack_require__(16);
	var cell_1 = __webpack_require__(2);
	var EditableCell = (function (_super) {
	    tslib_1.__extends(EditableCell, _super);
	    function EditableCell(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.handleEdit = function () {
	            _this.setState({ isEditing: true, dirtyValue: _this.state.savedValue });
	        };
	        _this.handleCancel = function (value) {
	            // don't strictly need to clear the dirtyValue, but it's better hygiene
	            _this.setState({ isEditing: false, dirtyValue: undefined });
	            _this.invokeCallback(_this.props.onCancel, value);
	        };
	        _this.handleChange = function (value) {
	            _this.setState({ dirtyValue: value });
	            _this.invokeCallback(_this.props.onChange, value);
	        };
	        _this.handleConfirm = function (value) {
	            _this.setState({ isEditing: false, savedValue: value, dirtyValue: undefined });
	            _this.invokeCallback(_this.props.onConfirm, value);
	        };
	        _this.handleCellActivate = function (_event) {
	            // Cancel edit of active cell when clicking away
	            if (!_this.state.isEditing && document.activeElement instanceof HTMLElement && document.activeElement.blur) {
	                document.activeElement.blur();
	            }
	            return true;
	        };
	        _this.handleCellDoubleClick = function (_event) {
	            var cellElement = ReactDOM.findDOMNode(_this);
	            if (cellElement == null) {
	                return;
	            }
	            var focusable = cellElement.querySelector(".pt-editable-text");
	            if (focusable.focus != null) {
	                focusable.focus();
	            }
	        };
	        _this.state = {
	            isEditing: false,
	            savedValue: props.value,
	        };
	        return _this;
	    }
	    EditableCell.prototype.shouldComponentUpdate = function (nextProps, nextState) {
	        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: ["style"] })
	            || !utils_1.Utils.shallowCompareKeys(this.state, nextState)
	            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, ["style"]);
	    };
	    EditableCell.prototype.componentWillReceiveProps = function (nextProps) {
	        var value = nextProps.value;
	        this.setState({ savedValue: value, dirtyValue: value });
	    };
	    EditableCell.prototype.render = function () {
	        var _a = this.props, onCancel = _a.onCancel, onChange = _a.onChange, onConfirm = _a.onConfirm, spreadableProps = tslib_1.__rest(_a, ["onCancel", "onChange", "onConfirm"]);
	        var _b = this.state, isEditing = _b.isEditing, dirtyValue = _b.dirtyValue, savedValue = _b.savedValue;
	        var interactive = spreadableProps.interactive || isEditing;
	        return (React.createElement(cell_1.Cell, tslib_1.__assign({}, spreadableProps, { truncated: false, interactive: interactive }),
	            React.createElement(draggable_1.Draggable, { onActivate: this.handleCellActivate, onDoubleClick: this.handleCellDoubleClick, preventDefault: !interactive, stopPropagation: interactive },
	                React.createElement(core_1.EditableText, { className: Classes.TABLE_EDITABLE_NAME, intent: spreadableProps.intent, minWidth: null, onCancel: this.handleCancel, onChange: this.handleChange, onConfirm: this.handleConfirm, onEdit: this.handleEdit, placeholder: "", selectAllOnFocus: true, value: isEditing ? dirtyValue : savedValue }))));
	    };
	    EditableCell.prototype.invokeCallback = function (callback, value) {
	        // pass through the row and column indices if they were provided as props by the consumer
	        var _a = this.props, rowIndex = _a.rowIndex, columnIndex = _a.columnIndex;
	        core_1.Utils.safeInvoke(callback, value, rowIndex, columnIndex);
	    };
	    return EditableCell;
	}(React.Component));
	exports.EditableCell = EditableCell;
	
	//# sourceMappingURL=editableCell.js.map


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_15__;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var ReactDOM = __webpack_require__(15);
	var utils_1 = __webpack_require__(7);
	var dragEvents_1 = __webpack_require__(17);
	var REATTACH_PROPS_KEYS = [
	    "stopPropagation",
	    "preventDefault",
	];
	/**
	 * This component provides a simple interface for combined drag and/or click
	 * events.
	 *
	 * Since the mouse interactions for drag and click are overloaded, here are
	 * the events that will fire in these cases:
	 *
	 * A Click Interaction
	 * 1. The user presses down on the render element, triggering the onActivate
	 *    callback.
	 * 2. The user releases the mouse button without moving it, triggering the
	 *    onClick callback.
	 *
	 * A Drag Interaction
	 * 1. The user presses down on the render element, triggering the onActivate
	 *    callback.
	 * 2. The user moves the mouse, triggering the onDragMove callback.
	 * 3. The user moves the mouse, triggering the onDragMove callback.
	 * 4. The user moves the mouse, triggering the onDragMove callback.
	 * 5. The user releases the mouse button, triggering a final onDragMove
	 *    callback as well as an onDragEnd callback.
	 *
	 * If `false` is returned from the onActivate callback, no further events
	 * will be fired until the next activation.
	 */
	var Draggable = (function (_super) {
	    tslib_1.__extends(Draggable, _super);
	    function Draggable() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Draggable.prototype.render = function () {
	        return React.Children.only(this.props.children);
	    };
	    Draggable.prototype.componentWillReceiveProps = function (nextProps) {
	        var propsWhitelist = { include: REATTACH_PROPS_KEYS };
	        if (this.events && !utils_1.Utils.shallowCompareKeys(this.props, nextProps, propsWhitelist)) {
	            this.events.attach(ReactDOM.findDOMNode(this), nextProps);
	        }
	    };
	    Draggable.prototype.componentDidMount = function () {
	        this.events = new dragEvents_1.DragEvents();
	        this.events.attach(ReactDOM.findDOMNode(this), this.props);
	    };
	    Draggable.prototype.componentWillUnmount = function () {
	        this.events.detach();
	        delete this.events;
	    };
	    return Draggable;
	}(React.Component));
	Draggable.defaultProps = {
	    preventDefault: true,
	    stopPropagation: false,
	};
	Draggable = tslib_1.__decorate([
	    PureRender
	], Draggable);
	exports.Draggable = Draggable;
	
	//# sourceMappingURL=draggable.js.map


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var DragEvents = (function () {
	    function DragEvents() {
	        var _this = this;
	        this.handleMouseDown = function (event) {
	            _this.initCoordinateData(event);
	            if (_this.handler != null && _this.handler.onActivate != null) {
	                var exitCode = _this.handler.onActivate(event);
	                if (exitCode === false) {
	                    return;
	                }
	            }
	            _this.isActivated = true;
	            _this.maybeAlterEventChain(event);
	            // It is possible that the mouseup would not be called after the initial
	            // mousedown (for example if the mouse is moved out of the window). So,
	            // we preemptively detach to avoid duplicate listeners.
	            _this.detachDocumentEventListeners();
	            _this.attachDocumentEventListeners();
	        };
	        this.handleMouseMove = function (event) {
	            _this.maybeAlterEventChain(event);
	            if (_this.isActivated) {
	                _this.isDragging = true;
	            }
	            if (_this.isDragging) {
	                var coords = _this.updateCoordinateData(event);
	                if (_this.handler != null && _this.handler.onDragMove != null) {
	                    _this.handler.onDragMove(event, coords);
	                }
	            }
	        };
	        this.handleMouseUp = function (event) {
	            _this.maybeAlterEventChain(event);
	            if (_this.handler != null) {
	                if (_this.isDragging) {
	                    var coords = _this.updateCoordinateData(event);
	                    if (_this.handler.onDragMove != null) {
	                        _this.handler.onDragMove(event, coords);
	                    }
	                    if (_this.handler.onDragEnd != null) {
	                        _this.handler.onDragEnd(event, coords);
	                    }
	                }
	                else if (_this.isActivated) {
	                    if (_this.handler.onDoubleClick != null) {
	                        if (_this.doubleClickTimeoutToken == null) {
	                            // if this the first click of a possible double-click,
	                            // we delay the firing of the click event by the
	                            // timeout.
	                            _this.doubleClickTimeoutToken = setTimeout(function () {
	                                delete _this.doubleClickTimeoutToken;
	                                if (_this.handler.onClick != null) {
	                                    _this.handler.onClick(event);
	                                }
	                            }, DragEvents.DOUBLE_CLICK_TIMEOUT_MSEC);
	                        }
	                        else {
	                            // otherwise, this is the second click in the double-
	                            // click so we cancel the single-click timeout and
	                            // fire the double-click event.
	                            clearTimeout(_this.doubleClickTimeoutToken);
	                            delete _this.doubleClickTimeoutToken;
	                            _this.handler.onDoubleClick(event);
	                        }
	                    }
	                    else if (_this.handler.onClick != null) {
	                        _this.handler.onClick(event);
	                    }
	                }
	            }
	            _this.isActivated = false;
	            _this.isDragging = false;
	            _this.detachDocumentEventListeners();
	        };
	    }
	    /**
	     * Returns true if the event includes a modifier key that often adds the result of the drag
	     * event to any existing state. For example, holding CTRL before dragging may select another
	     * region in addition to an existing one, while the absence of a modifier key may clear the
	     * existing selection first.
	     * @param event the mouse event for the drag interaction
	     */
	    DragEvents.isAdditive = function (event) {
	        return event.ctrlKey || event.metaKey;
	    };
	    DragEvents.prototype.attach = function (element, handler) {
	        this.detach();
	        this.handler = handler;
	        this.element = element;
	        if (this.isValidDragHandler(handler)) {
	            this.element.addEventListener("mousedown", this.handleMouseDown);
	        }
	        return this;
	    };
	    DragEvents.prototype.detach = function () {
	        if (this.element != null) {
	            this.element.removeEventListener("mousedown", this.handleMouseDown);
	            this.detachDocumentEventListeners();
	        }
	    };
	    DragEvents.prototype.isValidDragHandler = function (handler) {
	        return handler != null && (handler.onActivate != null
	            || handler.onDragMove != null
	            || handler.onDragEnd != null
	            || handler.onClick != null
	            || handler.onDoubleClick != null);
	    };
	    DragEvents.prototype.attachDocumentEventListeners = function () {
	        document.addEventListener("mousemove", this.handleMouseMove);
	        document.addEventListener("mouseup", this.handleMouseUp);
	    };
	    DragEvents.prototype.detachDocumentEventListeners = function () {
	        document.removeEventListener("mousemove", this.handleMouseMove);
	        document.removeEventListener("mouseup", this.handleMouseUp);
	    };
	    DragEvents.prototype.initCoordinateData = function (event) {
	        this.activationCoordinates = [event.clientX, event.clientY];
	        this.lastCoordinates = this.activationCoordinates;
	    };
	    DragEvents.prototype.updateCoordinateData = function (event) {
	        var currentCoordinates = [event.clientX, event.clientY];
	        var deltaCoordinates = [
	            currentCoordinates[0] - this.lastCoordinates[0],
	            currentCoordinates[1] - this.lastCoordinates[1],
	        ];
	        var offsetCoordinates = [
	            currentCoordinates[0] - this.activationCoordinates[0],
	            currentCoordinates[1] - this.activationCoordinates[1],
	        ];
	        var data = {
	            activation: this.activationCoordinates,
	            current: currentCoordinates,
	            delta: deltaCoordinates,
	            last: this.lastCoordinates,
	            offset: offsetCoordinates,
	        };
	        this.lastCoordinates = [event.clientX, event.clientY];
	        return data;
	    };
	    DragEvents.prototype.maybeAlterEventChain = function (event) {
	        if (this.handler.preventDefault) {
	            event.preventDefault();
	        }
	        if (this.handler.stopPropagation) {
	            event.stopPropagation();
	        }
	    };
	    return DragEvents;
	}());
	DragEvents.DOUBLE_CLICK_TIMEOUT_MSEC = 500;
	exports.DragEvents = DragEvents;
	
	//# sourceMappingURL=dragEvents.js.map


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var truncatedFormat_1 = __webpack_require__(19);
	var JSONFormat = (function (_super) {
	    tslib_1.__extends(JSONFormat, _super);
	    function JSONFormat() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    JSONFormat.prototype.render = function () {
	        var _a = this.props, children = _a.children, omitQuotesOnStrings = _a.omitQuotesOnStrings, stringify = _a.stringify;
	        var showPopover = this.props.showPopover;
	        // always hide popover if value is nully
	        var isNully = children == null;
	        if (isNully) {
	            showPopover = truncatedFormat_1.TruncatedPopoverMode.NEVER;
	        }
	        var className = classNames(this.props.className, (_b = {},
	            _b[Classes.TABLE_NULL] = isNully,
	            _b));
	        var displayValue = "";
	        if (omitQuotesOnStrings && typeof children === "string") {
	            displayValue = children;
	        }
	        else {
	            displayValue = stringify(children);
	        }
	        return (React.createElement(truncatedFormat_1.TruncatedFormat, tslib_1.__assign({}, this.props, { className: className, showPopover: showPopover }), displayValue));
	        var _b;
	    };
	    return JSONFormat;
	}(React.Component));
	JSONFormat.defaultProps = {
	    detectTruncation: true,
	    omitQuotesOnStrings: true,
	    showPopover: truncatedFormat_1.TruncatedPopoverMode.WHEN_TRUNCATED,
	    stringify: function (obj) { return (JSON.stringify(obj, null, 2)); },
	};
	exports.JSONFormat = JSONFormat;
	
	//# sourceMappingURL=jsonFormat.js.map


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	// amount in pixels that the content div width changes when truncated vs when
	// not truncated. Note: could be modified by styles
	// Note 2: this doesn't come from the width of the popover element, but the "right" style
	// on the div, which comes from styles
	var CONTENT_DIV_WIDTH_DELTA = 25;
	var TruncatedPopoverMode;
	(function (TruncatedPopoverMode) {
	    TruncatedPopoverMode[TruncatedPopoverMode["ALWAYS"] = 0] = "ALWAYS";
	    TruncatedPopoverMode[TruncatedPopoverMode["NEVER"] = 1] = "NEVER";
	    TruncatedPopoverMode[TruncatedPopoverMode["WHEN_TRUNCATED"] = 2] = "WHEN_TRUNCATED";
	})(TruncatedPopoverMode = exports.TruncatedPopoverMode || (exports.TruncatedPopoverMode = {}));
	var TruncatedFormat = (function (_super) {
	    tslib_1.__extends(TruncatedFormat, _super);
	    function TruncatedFormat() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = { isTruncated: false };
	        _this.handleContentDivRef = function (ref) { return _this.contentDiv = ref; };
	        return _this;
	    }
	    TruncatedFormat.prototype.render = function () {
	        var _a = this.props, children = _a.children, detectTruncation = _a.detectTruncation, preformatted = _a.preformatted, truncateLength = _a.truncateLength, truncationSuffix = _a.truncationSuffix;
	        var content = "" + children;
	        var cellContent = content;
	        if (!detectTruncation && truncateLength > 0 && cellContent.length > truncateLength) {
	            cellContent = cellContent.substring(0, truncateLength) + truncationSuffix;
	        }
	        if (this.shouldShowPopover(content)) {
	            var popoverClasses = classNames(Classes.TABLE_TRUNCATED_POPOVER, preformatted ? Classes.TABLE_POPOVER_WHITESPACE_PRE : Classes.TABLE_POPOVER_WHITESPACE_NORMAL);
	            var popoverContent = React.createElement("div", { className: popoverClasses }, children);
	            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT);
	            var constraints = [{
	                    attachment: "together",
	                    to: "window",
	                }];
	            return (React.createElement("div", { className: className },
	                React.createElement("div", { className: Classes.TABLE_TRUNCATED_VALUE, ref: this.handleContentDivRef }, cellContent),
	                React.createElement(core_1.Popover, { className: Classes.TABLE_TRUNCATED_POPOVER_TARGET, tetherOptions: { constraints: constraints }, content: popoverContent, position: core_1.Position.BOTTOM, useSmartArrowPositioning: true },
	                    React.createElement(core_1.Icon, { iconName: "more" }))));
	        }
	        else {
	            var className = classNames(this.props.className, Classes.TABLE_TRUNCATED_FORMAT_TEXT);
	            return React.createElement("div", { className: className, ref: this.handleContentDivRef }, cellContent);
	        }
	    };
	    TruncatedFormat.prototype.componentDidMount = function () {
	        this.setTruncationState();
	    };
	    TruncatedFormat.prototype.componentDidUpdate = function () {
	        this.setTruncationState();
	    };
	    TruncatedFormat.prototype.shouldShowPopover = function (content) {
	        var _a = this.props, detectTruncation = _a.detectTruncation, showPopover = _a.showPopover, truncateLength = _a.truncateLength;
	        switch (showPopover) {
	            case TruncatedPopoverMode.ALWAYS:
	                return true;
	            case TruncatedPopoverMode.NEVER:
	                return false;
	            case TruncatedPopoverMode.WHEN_TRUNCATED:
	                return detectTruncation
	                    ? this.state.isTruncated
	                    : (truncateLength > 0 && content.length > truncateLength);
	            default:
	                return false;
	        }
	    };
	    TruncatedFormat.prototype.setTruncationState = function () {
	        if (!this.props.detectTruncation || this.props.showPopover !== TruncatedPopoverMode.WHEN_TRUNCATED) {
	            return;
	        }
	        if (this.contentDiv === undefined) {
	            this.setState({ isTruncated: false });
	            return;
	        }
	        var isTruncated = this.state.isTruncated;
	        // take all measurements at once to avoid excessive DOM reflows.
	        var _a = this.contentDiv, containerHeight = _a.clientHeight, containerWidth = _a.clientWidth, actualContentHeight = _a.scrollHeight, contentWidth = _a.scrollWidth;
	        // if the content is truncated, then a popover handle will be present as a
	        // sibling of the content. we don't want to consider that handle when
	        // calculating the width of the actual content, so subtract it.
	        var actualContentWidth = isTruncated
	            ? contentWidth - CONTENT_DIV_WIDTH_DELTA
	            : contentWidth;
	        // we of course truncate the content if it doesn't fit in the container. but we
	        // also aggressively truncate if they're the same size with truncation enabled;
	        // this addresses browser-crashing stack-overflow bugs at various zoom levels.
	        // (see: https://github.com/palantir/blueprint/pull/1519)
	        var shouldTruncate = (isTruncated && actualContentWidth === containerWidth)
	            || actualContentWidth > containerWidth
	            || actualContentHeight > containerHeight;
	        this.setState({ isTruncated: shouldTruncate });
	    };
	    return TruncatedFormat;
	}(React.Component));
	TruncatedFormat.defaultProps = {
	    detectTruncation: true,
	    preformatted: false,
	    showPopover: TruncatedPopoverMode.WHEN_TRUNCATED,
	    truncateLength: 80,
	    truncationSuffix: "...",
	};
	TruncatedFormat = tslib_1.__decorate([
	    PureRender
	], TruncatedFormat);
	exports.TruncatedFormat = TruncatedFormat;
	
	//# sourceMappingURL=truncatedFormat.js.map


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var cell_1 = __webpack_require__(2);
	var Column = (function (_super) {
	    tslib_1.__extends(Column, _super);
	    function Column() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return Column;
	}(React.Component));
	Column.defaultProps = {
	    renderCell: cell_1.emptyCellRenderer,
	};
	Column = tslib_1.__decorate([
	    PureRender
	], Column);
	exports.Column = Column;
	
	//# sourceMappingURL=column.js.map


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var clipboard_1 = __webpack_require__(22);
	exports.Clipboard = clipboard_1.Clipboard;
	var grid_1 = __webpack_require__(23);
	exports.Grid = grid_1.Grid;
	var rect_1 = __webpack_require__(25);
	exports.Rect = rect_1.Rect;
	var renderMode_1 = __webpack_require__(26);
	exports.RenderMode = renderMode_1.RenderMode;
	var roundSize_1 = __webpack_require__(27);
	exports.RoundSize = roundSize_1.RoundSize;
	var utils_1 = __webpack_require__(7);
	exports.Utils = utils_1.Utils;
	// NOTE: The following are not exported in the public API:
	// - Errors
	// - internal/
	
	//# sourceMappingURL=index.js.map


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/* istanbul ignore next */
	exports.Clipboard = {
	    /**
	     * Overrides the inherited CSS of the element to make sure it is
	     * selectable. This method also makes the element pseudo-invisible.
	     */
	    applySelectableStyles: function (elem) {
	        elem.style.overflow = "hidden";
	        elem.style.height = "0px";
	        elem.style.setProperty("-webkit-user-select", "all");
	        elem.style.setProperty("-moz-user-select", "all");
	        elem.style.setProperty("-ms-user-select", "all");
	        elem.style.setProperty("user-select", "all");
	        return elem;
	    },
	    /**
	     * Copies table cells to the clipboard. The parameter is a row-major
	     * 2-dimensional `Array` of strings and can contain nulls. We assume all
	     * rows are the same length. If not, the cells will still be copied, but
	     * the columns may not align. Returns a boolean indicating whether the
	     * copy succeeded.
	     *
	     * See `Clipboard.copy`
	     */
	    copyCells: function (cells) {
	        var table = document.createElement("table");
	        exports.Clipboard.applySelectableStyles(table);
	        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {
	            var row = cells_1[_i];
	            var tr = table.appendChild(document.createElement("tr"));
	            for (var _a = 0, row_1 = row; _a < row_1.length; _a++) {
	                var cell = row_1[_a];
	                var td = tr.appendChild(document.createElement("td"));
	                td.textContent = cell;
	            }
	        }
	        var tsv = cells.map(function (row) { return row.join("\t"); }).join("\n");
	        return exports.Clipboard.copyElement(table, tsv);
	    },
	    /**
	     * Copies the text to the clipboard. Returns a boolean
	     * indicating whether the copy succeeded.
	     *
	     * See `Clipboard.copy`
	     */
	    copyString: function (value) {
	        var text = document.createElement("textarea");
	        exports.Clipboard.applySelectableStyles(text);
	        text.value = value;
	        return exports.Clipboard.copyElement(text, value);
	    },
	    /**
	     * Copies the element and its children to the clipboard. Returns a boolean
	     * indicating whether the copy succeeded.
	     *
	     * If a plaintext argument is supplied, we add both the text/html and
	     * text/plain mime types to the clipboard. This preserves the built in
	     * semantics of copying elements to the clipboard while allowing custom
	     * plaintext output for programs that can't cope with HTML data in the
	     * clipboard.
	     *
	     * Verified on Firefox 47, Chrome 51.
	     *
	     * Note: Sometimes the copy does not succeed. Presumably, in order to
	     * prevent memory issues, browsers will limit the total amount of data you
	     * can copy to the clipboard. Based on ad hoc testing, we found an
	     * inconsistent limit at about 300KB or 40,000 cells. Depending on the on
	     * the content of cells, your limits may vary.
	     */
	    copyElement: function (elem, plaintext) {
	        if (!exports.Clipboard.isCopySupported()) {
	            return false;
	        }
	        // must be document.body instead of document.documentElement for firefox
	        document.body.appendChild(elem);
	        try {
	            window.getSelection().selectAllChildren(elem);
	            if (plaintext != null) {
	                // add plaintext fallback
	                // http://stackoverflow.com/questions/23211018/copy-to-clipboard-with-jquery-js-in-chrome
	                elem.addEventListener("copy", function (e) {
	                    e.preventDefault();
	                    var clipboardData = e.clipboardData || window.clipboardData;
	                    if (clipboardData != null) {
	                        clipboardData.setData("text/html", elem.outerHTML);
	                        clipboardData.setData("text/plain", plaintext);
	                    }
	                });
	            }
	            return document.execCommand("copy");
	        }
	        catch (err) {
	            return false;
	        }
	        finally {
	            document.body.removeChild(elem);
	        }
	    },
	    /**
	     * Returns a boolean indicating whether the current browser nominally
	     * supports the `copy` operation using the `execCommand` API.
	     */
	    isCopySupported: function () {
	        return document.queryCommandSupported != null && document.queryCommandSupported("copy");
	    },
	};
	
	//# sourceMappingURL=clipboard.js.map


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var regions_1 = __webpack_require__(24);
	var Classes = __webpack_require__(6);
	var rect_1 = __webpack_require__(25);
	var utils_1 = __webpack_require__(7);
	/**
	 * This class manages the sizes of grid cells using arrays of individual row/column sizes.
	 */
	var Grid = (function () {
	    /**
	     * This constructor accumulates the heights and widths in `O(n)`, saving
	     * time in later calculations.
	     *
	     * @param bleed - The number of rows/cols that we expand beyond the
	     *     viewport (on all sides). This helps avoid displaying an empty
	     *     viewport when the user scrolls quickly.
	     */
	    function Grid(rowHeights, columnWidths, bleed, ghostHeight, ghostWidth) {
	        if (bleed === void 0) { bleed = Grid.DEFAULT_BLEED; }
	        if (ghostHeight === void 0) { ghostHeight = Grid.DEFAULT_GHOST_HEIGHT; }
	        if (ghostWidth === void 0) { ghostWidth = Grid.DEFAULT_GHOST_WIDTH; }
	        var _this = this;
	        this.getCumulativeWidthBefore = function (index) {
	            return (index === 0) ? 0 : _this.getCumulativeWidthAt(index - 1);
	        };
	        this.getCumulativeWidthAt = function (index) {
	            if (_this.numCols === 0) {
	                return _this.ghostWidth * index;
	            }
	            else if (index >= _this.numCols) {
	                return _this.cumulativeColumnWidths[_this.numCols - 1] + _this.ghostWidth * (index - _this.numCols + 1);
	            }
	            else {
	                return _this.cumulativeColumnWidths[index];
	            }
	        };
	        this.getCumulativeHeightBefore = function (index) {
	            return (index === 0) ? 0 : _this.getCumulativeHeightAt(index - 1);
	        };
	        this.getCumulativeHeightAt = function (index) {
	            if (_this.numRows === 0) {
	                return _this.ghostHeight * index;
	            }
	            else if (index >= _this.numRows) {
	                return _this.cumulativeRowHeights[_this.numRows - 1] + _this.ghostHeight * (index - _this.numRows + 1);
	            }
	            else {
	                return _this.cumulativeRowHeights[index];
	            }
	        };
	        this.columnWidths = columnWidths;
	        this.rowHeights = rowHeights;
	        this.cumulativeColumnWidths = utils_1.Utils.accumulate(columnWidths);
	        this.cumulativeRowHeights = utils_1.Utils.accumulate(rowHeights);
	        this.numCols = columnWidths.length;
	        this.numRows = rowHeights.length;
	        this.bleed = bleed;
	        this.ghostHeight = ghostHeight;
	        this.ghostWidth = ghostWidth;
	    }
	    /**
	     * Returns the `Rect` bounds of a cell in scrollpane client space.
	     *
	     * Scrollpane client coordinate space uses the origin of the scrollpane
	     * client (the inside part that you're moving around).
	     *
	     * For example, let's say you're scrolling around a block of 1000 x 1000
	     * cells. Regardless where you've scrolled, the first cell is always at
	     * 0,0 in scrollpane client space. the cell to the right of it is always
	     * at, e.g., 100,0.
	     */
	    Grid.prototype.getCellRect = function (rowIndex, columnIndex) {
	        var height = this.rowHeights[rowIndex];
	        var top = this.cumulativeRowHeights[rowIndex] - height;
	        var width = this.columnWidths[columnIndex];
	        var left = this.cumulativeColumnWidths[columnIndex] - width;
	        return new rect_1.Rect(left, top, width, height);
	    };
	    /**
	     * Returns the `Rect` bounds of a cell in scrollpane client space.
	     *
	     * If the cell is beyond the bounds of the user-defined table cells, it is
	     * considered a "ghost" cell. If a width/height is not defined for that
	     * row/column, we use the default width/height.
	     */
	    Grid.prototype.getGhostCellRect = function (rowIndex, columnIndex) {
	        var left = 0;
	        var top = 0;
	        var width = 0;
	        var height = 0;
	        if (rowIndex >= this.rowHeights.length) {
	            height = this.ghostHeight;
	            top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);
	        }
	        else {
	            height = this.rowHeights[rowIndex];
	            top = this.cumulativeRowHeights[rowIndex] - height;
	        }
	        if (columnIndex >= this.columnWidths.length) {
	            width = this.ghostWidth;
	            left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);
	        }
	        else {
	            width = this.columnWidths[columnIndex];
	            left = this.cumulativeColumnWidths[columnIndex] - width;
	        }
	        return new rect_1.Rect(left, top, width, height);
	    };
	    /**
	     * Returns the `Rect` with the base coordinate and height of the specified row.
	     */
	    Grid.prototype.getRowRect = function (rowIndex) {
	        var height = this.rowHeights[rowIndex];
	        var top = this.cumulativeRowHeights[rowIndex] - height;
	        return new rect_1.Rect(0, top, this.getWidth(), height);
	    };
	    /**
	     * Returns the `Rect` with the base coordinate and width of the specified column.
	     */
	    Grid.prototype.getColumnRect = function (columnIndex) {
	        var width = this.columnWidths[columnIndex];
	        var left = this.cumulativeColumnWidths[columnIndex] - width;
	        return new rect_1.Rect(left, 0, width, this.getHeight());
	    };
	    /**
	     * Returns the total width of the entire grid
	     */
	    Grid.prototype.getWidth = function () {
	        return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];
	    };
	    /**
	     * Returns the total width of the entire grid
	     */
	    Grid.prototype.getHeight = function () {
	        return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];
	    };
	    /**
	     * Returns the `Rect` bounds of entire grid
	     */
	    Grid.prototype.getRect = function () {
	        return new rect_1.Rect(0, 0, this.getWidth(), this.getHeight());
	    };
	    /**
	     * Maps each cell that intersects with the given `Rect` argument. The
	     * indices of iteration are extended in both directions by the integer
	     * `bleed` class property, then are clamped between 0 and the number of
	     * rows/columns.
	     *
	     * Uses a binary search for each of the 4 edges of the bounds, resulting
	     * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`
	     * iteration of intersecting cells.
	     */
	    Grid.prototype.mapCellsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;
	        var _b = this.getColumnIndicesInRect(rect), columnIndexStart = _b.columnIndexStart, columnIndexEnd = _b.columnIndexEnd;
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	                results.push(callback(rowIndex, columnIndex));
	            }
	        }
	        return results;
	    };
	    /**
	     * Maps each row that intersects with the given `Rect` argument.
	     *
	     * See Grid.mapCellsInRect for more details.
	     */
	    Grid.prototype.mapRowsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            results.push(callback(rowIndex));
	        }
	        return results;
	    };
	    /**
	     * Maps each column that intersects with the given `Rect` argument.
	     *
	     * See Grid.mapCellsInRect for more details.
	     */
	    Grid.prototype.mapColumnsInRect = function (rect, callback) {
	        var results = [];
	        if (rect == null) {
	            return results;
	        }
	        var _a = this.getColumnIndicesInRect(rect), columnIndexStart = _a.columnIndexStart, columnIndexEnd = _a.columnIndexEnd;
	        for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	            results.push(callback(columnIndex));
	        }
	        return results;
	    };
	    /**
	     * Returns the start and end indices of rows that intersect with the given
	     * `Rect` argument.
	     */
	    Grid.prototype.getRowIndicesInRect = function (rect, includeGhostCells, limit) {
	        if (includeGhostCells === void 0) { includeGhostCells = false; }
	        if (limit === void 0) { limit = Grid.DEFAULT_MAX_ROWS; }
	        if (rect == null) {
	            return { rowIndexEnd: 0, rowIndexStart: 0 };
	        }
	        var searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;
	        var _a = this.getIndicesInInterval(rect.top, rect.top + rect.height, searchEnd, !includeGhostCells, this.getCumulativeHeightAt), start = _a.start, end = _a.end;
	        var rowIndexEnd = (limit > 0 && end - start > limit)
	            ? start + limit
	            : end;
	        return {
	            rowIndexEnd: rowIndexEnd,
	            rowIndexStart: start,
	        };
	    };
	    /**
	     * Returns the start and end indices of columns that intersect with the
	     * given `Rect` argument.
	     */
	    Grid.prototype.getColumnIndicesInRect = function (rect, includeGhostCells, limit) {
	        if (includeGhostCells === void 0) { includeGhostCells = false; }
	        if (limit === void 0) { limit = Grid.DEFAULT_MAX_COLUMNS; }
	        if (rect == null) {
	            return { columnIndexEnd: 0, columnIndexStart: 0 };
	        }
	        var searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;
	        var _a = this.getIndicesInInterval(rect.left, rect.left + rect.width, searchEnd, !includeGhostCells, this.getCumulativeWidthAt), start = _a.start, end = _a.end;
	        var columnIndexEnd = (limit > 0 && end - start > limit)
	            ? start + limit
	            : end;
	        return {
	            columnIndexEnd: columnIndexEnd,
	            columnIndexStart: start,
	        };
	    };
	    Grid.prototype.isGhostIndex = function (rowIndex, columnIndex) {
	        return (rowIndex >= this.numRows || columnIndex >= this.numCols);
	    };
	    Grid.prototype.getExtremaClasses = function (rowIndex, columnIndex, rowEnd, columnEnd) {
	        if (rowIndex === rowEnd && columnIndex === columnEnd) {
	            return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];
	        }
	        if (rowIndex === rowEnd) {
	            return [Classes.TABLE_LAST_IN_COLUMN];
	        }
	        if (columnIndex === columnEnd) {
	            return [Classes.TABLE_LAST_IN_ROW];
	        }
	        return [];
	    };
	    Grid.prototype.getRegionStyle = function (region) {
	        var cardinality = regions_1.Regions.getRegionCardinality(region);
	        switch (cardinality) {
	            case regions_1.RegionCardinality.CELLS: {
	                var _a = region.rows, rowStart = _a[0], rowEnd = _a[1];
	                var _b = region.cols, colStart = _b[0], colEnd = _b[1];
	                // if the region is outside the bounds of the table, don't display it
	                if (this.isGhostIndex(rowStart, colStart) || this.isGhostIndex(rowEnd, colEnd)) {
	                    return { display: "none" };
	                }
	                var cellRect0 = this.getCellRect(rowStart, colStart);
	                var cellRect1 = this.getCellRect(rowEnd, colEnd);
	                var offsetLeft = colStart === 0 ? 0 : 1;
	                var offsetTop = rowStart === 0 ? 0 : 1;
	                var rect = cellRect0.union(cellRect1);
	                rect.height += offsetTop;
	                rect.left -= offsetLeft;
	                rect.width += offsetLeft;
	                rect.top -= offsetTop;
	                return tslib_1.__assign({}, rect.style(), { display: "block" });
	            }
	            case regions_1.RegionCardinality.FULL_COLUMNS: {
	                var _c = region.cols, colStart = _c[0], colEnd = _c[1];
	                // if the region is outside the bounds of the table, don't display it
	                if (this.isGhostIndex(0, colStart) || this.isGhostIndex(0, colEnd)) {
	                    return { display: "none" };
	                }
	                var cellRect0 = this.getCellRect(0, colStart);
	                var cellRect1 = this.getCellRect(0, colEnd);
	                var rect = cellRect0.union(cellRect1);
	                var offsetLeft = colStart === 0 ? 0 : 1;
	                return {
	                    bottom: 0,
	                    display: "block",
	                    left: rect.left - offsetLeft,
	                    top: 0,
	                    width: rect.width + offsetLeft,
	                };
	            }
	            case regions_1.RegionCardinality.FULL_ROWS: {
	                var _d = region.rows, rowStart = _d[0], rowEnd = _d[1];
	                // if the region is outside the bounds of the table, don't display it
	                if (this.isGhostIndex(rowStart, 0) || this.isGhostIndex(rowEnd, 0)) {
	                    return { display: "none" };
	                }
	                var cellRect0 = this.getCellRect(rowStart, 0);
	                var cellRect1 = this.getCellRect(rowEnd, 0);
	                var rect = cellRect0.union(cellRect1);
	                var offsetTop = rowStart === 0 ? 0 : 1;
	                return {
	                    display: "block",
	                    height: rect.height + offsetTop,
	                    left: 0,
	                    right: 0,
	                    top: rect.top - offsetTop,
	                };
	            }
	            case regions_1.RegionCardinality.FULL_TABLE:
	                return {
	                    bottom: 0,
	                    display: "block",
	                    left: 0,
	                    right: 0,
	                    top: 0,
	                };
	            default: return { display: "none" };
	        }
	    };
	    Grid.prototype.getIndicesInInterval = function (min, max, count, useEndBleed, lookup) {
	        var start = utils_1.Utils.binarySearch(min, count - 1, lookup);
	        var end = utils_1.Utils.binarySearch(max, count - 1, lookup);
	        // correct exact pixel alignment
	        if (start >= 0 && min === lookup(start)) {
	            start += 1;
	        }
	        // apply bounded bleeds
	        start = Math.max(0, start - this.bleed);
	        if (useEndBleed) {
	            end = Math.min(count - 1, end + this.bleed);
	        }
	        else {
	            end = Math.min(count - 1, end);
	        }
	        return { start: start, end: end };
	    };
	    return Grid;
	}());
	Grid.DEFAULT_BLEED = 3;
	Grid.DEFAULT_MAX_COLUMNS = 50;
	Grid.DEFAULT_MAX_ROWS = 200;
	Grid.DEFAULT_GHOST_HEIGHT = 20;
	Grid.DEFAULT_GHOST_WIDTH = 150;
	exports.Grid = Grid;
	
	//# sourceMappingURL=grid.js.map


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	/**
	 * `Region`s contain sets of cells. Additionally, a distinction is drawn, for
	 * example, between all cells within a column and the whole column itself.
	 * The `RegionCardinality` enum represents these distinct types of `Region`s.
	 */
	var RegionCardinality;
	(function (RegionCardinality) {
	    /**
	     * A region that contains a finite rectangular group of table cells
	     */
	    RegionCardinality[RegionCardinality["CELLS"] = 0] = "CELLS";
	    /**
	     * A region that represents all cells within 1 or more rows.
	     */
	    RegionCardinality[RegionCardinality["FULL_ROWS"] = 1] = "FULL_ROWS";
	    /**
	     * A region that represents all cells within 1 or more columns.
	     */
	    RegionCardinality[RegionCardinality["FULL_COLUMNS"] = 2] = "FULL_COLUMNS";
	    /**
	     * A region that represents all cells in the table.
	     */
	    RegionCardinality[RegionCardinality["FULL_TABLE"] = 3] = "FULL_TABLE";
	})(RegionCardinality = exports.RegionCardinality || (exports.RegionCardinality = {}));
	/**
	 * A convenience object for subsets of `RegionCardinality` that are commonly
	 * used as the `selectionMode` prop of the `<Table>`.
	 */
	exports.SelectionModes = {
	    ALL: [
	        RegionCardinality.FULL_TABLE,
	        RegionCardinality.FULL_COLUMNS,
	        RegionCardinality.FULL_ROWS,
	        RegionCardinality.CELLS,
	    ],
	    COLUMNS_AND_CELLS: [
	        RegionCardinality.FULL_COLUMNS,
	        RegionCardinality.CELLS,
	    ],
	    COLUMNS_ONLY: [
	        RegionCardinality.FULL_COLUMNS,
	    ],
	    NONE: [],
	    ROWS_AND_CELLS: [
	        RegionCardinality.FULL_ROWS,
	        RegionCardinality.CELLS,
	    ],
	    ROWS_ONLY: [
	        RegionCardinality.FULL_ROWS,
	    ],
	};
	exports.ColumnLoadingOption = {
	    CELLS: "cells",
	    HEADER: "column-header",
	};
	exports.RowLoadingOption = {
	    CELLS: "cells",
	    HEADER: "row-header",
	};
	exports.TableLoadingOption = {
	    CELLS: "cells",
	    COLUMN_HEADERS: exports.ColumnLoadingOption.HEADER,
	    ROW_HEADERS: exports.RowLoadingOption.HEADER,
	};
	var Regions = (function () {
	    function Regions() {
	    }
	    /**
	     * Determines the cardinality of a region. We use null values to indicate
	     * an unbounded interval. Therefore, an example of a region containing the
	     * second and third columns would be:
	     *
	     *     {
	     *         rows: null,
	     *         cols: [1, 2]
	     *     }
	     *
	     * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.
	     *
	     * If both rows and columns are unbounded, then the region covers the
	     * entire table. Therefore, a region like this:
	     *
	     *     {
	     *         rows: null,
	     *         cols: null
	     *     }
	     *
	     * will return `RegionCardinality.FULL_TABLE`.
	     *
	     * An example of a region containing a single cell in the table would be:
	     *
	     *     {
	     *         rows: [5, 5],
	     *         cols: [2, 2]
	     *     }
	     *
	     * In this case, this method would return `RegionCardinality.CELLS`.
	     */
	    Regions.getRegionCardinality = function (region) {
	        if (region.cols != null && region.rows != null) {
	            return RegionCardinality.CELLS;
	        }
	        else if (region.cols != null) {
	            return RegionCardinality.FULL_COLUMNS;
	        }
	        else if (region.rows != null) {
	            return RegionCardinality.FULL_ROWS;
	        }
	        else {
	            return RegionCardinality.FULL_TABLE;
	        }
	    };
	    Regions.getFocusCellCoordinatesFromRegion = function (region) {
	        var regionCardinality = Regions.getRegionCardinality(region);
	        switch (regionCardinality) {
	            case RegionCardinality.FULL_TABLE:
	                return { col: 0, row: 0 };
	            case RegionCardinality.FULL_COLUMNS:
	                return { col: region.cols[0], row: 0 };
	            case RegionCardinality.FULL_ROWS:
	                return { col: 0, row: region.rows[0] };
	            case RegionCardinality.CELLS:
	                return { col: region.cols[0], row: region.rows[0] };
	            default:
	                return null;
	        }
	    };
	    /**
	     * Returns a region containing one or more cells.
	     */
	    Regions.cell = function (row, col, row2, col2) {
	        return {
	            cols: this.normalizeInterval(col, col2),
	            rows: this.normalizeInterval(row, row2),
	        };
	    };
	    /**
	     * Returns a region containing one or more full rows.
	     */
	    Regions.row = function (row, row2) {
	        return { rows: this.normalizeInterval(row, row2) };
	    };
	    /**
	     * Returns a region containing one or more full columns.
	     */
	    Regions.column = function (col, col2) {
	        return { cols: this.normalizeInterval(col, col2) };
	    };
	    /**
	     * Returns a region containing the entire table.
	     */
	    Regions.table = function () {
	        return {};
	    };
	    /**
	     * Adds the region to the end of a cloned copy of the supplied region
	     * array.
	     */
	    Regions.add = function (regions, region) {
	        var copy = regions.slice();
	        copy.push(region);
	        return copy;
	    };
	    /**
	     * Replaces the region at the end of a cloned copy of the supplied region
	     * array.
	     */
	    Regions.update = function (regions, region) {
	        var copy = regions.slice();
	        copy.pop();
	        copy.push(region);
	        return copy;
	    };
	    /**
	     * Returns true iff the specified region is equal to the last region in
	     * the region list. This allows us to avoid immediate additive re-selection.
	     */
	    Regions.lastRegionIsEqual = function (regions, region) {
	        if (regions == null || regions.length === 0) {
	            return false;
	        }
	        var lastRegion = regions[regions.length - 1];
	        return Regions.regionsEqual(lastRegion, region);
	    };
	    /**
	     * Returns the index of the region that is equal to the supplied
	     * parameter. Returns -1 if no such region is found.
	     */
	    Regions.findMatchingRegion = function (regions, region) {
	        if (regions == null) {
	            return -1;
	        }
	        for (var i = 0; i < regions.length; i++) {
	            if (Regions.regionsEqual(regions[i], region)) {
	                return i;
	            }
	        }
	        return -1;
	    };
	    /**
	     * Returns the index of the region that wholly contains the supplied
	     * parameter. Returns -1 if no such region is found.
	     */
	    Regions.findContainingRegion = function (regions, region) {
	        if (regions == null) {
	            return -1;
	        }
	        for (var i = 0; i < regions.length; i++) {
	            if (Regions.regionContains(regions[i], region)) {
	                return i;
	            }
	        }
	        return -1;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_COLUMNS
	     * cardinality and contains the specified column index.
	     */
	    Regions.hasFullColumn = function (regions, col) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {
	            var region = regions_1[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	            if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_ROWS
	     * cardinality and contains the specified row index.
	     */
	    Regions.hasFullRow = function (regions, row) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_2 = regions; _i < regions_2.length; _i++) {
	            var region = regions_2[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	            if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions contain a region that has FULL_TABLE cardinality
	     */
	    Regions.hasFullTable = function (regions) {
	        if (regions == null) {
	            return false;
	        }
	        for (var _i = 0, regions_3 = regions; _i < regions_3.length; _i++) {
	            var region = regions_3[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            if (cardinality === RegionCardinality.FULL_TABLE) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * Returns true if the regions fully contain the query region.
	     */
	    Regions.containsRegion = function (regions, query) {
	        return Regions.overlapsRegion(regions, query, false);
	    };
	    /**
	     * Returns true if the regions at least partially overlap the query region.
	     */
	    Regions.overlapsRegion = function (regions, query, allowPartialOverlap) {
	        if (allowPartialOverlap === void 0) { allowPartialOverlap = false; }
	        var intervalCompareFn = allowPartialOverlap ? Regions.intervalOverlaps : Regions.intervalContains;
	        if (regions == null || query == null) {
	            return false;
	        }
	        for (var _i = 0, regions_4 = regions; _i < regions_4.length; _i++) {
	            var region = regions_4[_i];
	            var cardinality = Regions.getRegionCardinality(region);
	            switch (cardinality) {
	                case RegionCardinality.FULL_TABLE:
	                    return true;
	                case RegionCardinality.FULL_COLUMNS:
	                    if (intervalCompareFn(region.cols, query.cols)) {
	                        return true;
	                    }
	                    continue;
	                case RegionCardinality.FULL_ROWS:
	                    if (intervalCompareFn(region.rows, query.rows)) {
	                        return true;
	                    }
	                    continue;
	                case RegionCardinality.CELLS:
	                    if (intervalCompareFn(region.cols, query.cols)
	                        && intervalCompareFn(region.rows, query.rows)) {
	                        return true;
	                    }
	                    continue;
	                default:
	                    break;
	            }
	        }
	        return false;
	    };
	    Regions.eachUniqueFullColumn = function (regions, iteratee) {
	        if (regions == null || regions.length === 0 || iteratee == null) {
	            return;
	        }
	        var seen = {};
	        regions.forEach(function (region) {
	            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {
	                var _a = region.cols, start = _a[0], end = _a[1];
	                for (var col = start; col <= end; col++) {
	                    if (!seen[col]) {
	                        seen[col] = true;
	                        iteratee(col);
	                    }
	                }
	            }
	        });
	    };
	    Regions.eachUniqueFullRow = function (regions, iteratee) {
	        if (regions == null || regions.length === 0 || iteratee == null) {
	            return;
	        }
	        var seen = {};
	        regions.forEach(function (region) {
	            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {
	                var _a = region.rows, start = _a[0], end = _a[1];
	                for (var row = start; row <= end; row++) {
	                    if (!seen[row]) {
	                        seen[row] = true;
	                        iteratee(row);
	                    }
	                }
	            }
	        });
	    };
	    /**
	     * Using the supplied array of non-contiguous `IRegion`s, this method
	     * returns an ordered array of every unique cell that exists in those
	     * regions.
	     */
	    Regions.enumerateUniqueCells = function (regions, numRows, numCols) {
	        if (regions == null || regions.length === 0) {
	            return [];
	        }
	        var seen = {};
	        var list = [];
	        for (var _i = 0, regions_5 = regions; _i < regions_5.length; _i++) {
	            var region = regions_5[_i];
	            Regions.eachCellInRegion(region, numRows, numCols, function (row, col) {
	                // add to list if not seen
	                var key = row + "-" + col;
	                if (seen[key] !== true) {
	                    seen[key] = true;
	                    list.push([row, col]);
	                }
	            });
	        }
	        // sort list by rows then columns
	        list.sort(Regions.rowFirstComparator);
	        return list;
	    };
	    /**
	     * Using the supplied region, returns an "equivalent" region of
	     * type CELLS that define the bounds of the given region
	     */
	    Regions.getCellRegionFromRegion = function (region, numRows, numCols) {
	        var regionCardinality = Regions.getRegionCardinality(region);
	        switch (regionCardinality) {
	            case RegionCardinality.FULL_TABLE:
	                return Regions.cell(0, 0, numRows - 1, numCols - 1);
	            case RegionCardinality.FULL_COLUMNS:
	                return Regions.cell(0, region.cols[0], numRows - 1, region.cols[1]);
	            case RegionCardinality.FULL_ROWS:
	                return Regions.cell(region.rows[0], 0, region.rows[1], numCols - 1);
	            case RegionCardinality.CELLS:
	                return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);
	            default:
	                return null;
	        }
	    };
	    /**
	     * Maps a dense array of cell coordinates to a sparse 2-dimensional array
	     * of cell values.
	     *
	     * We create a new 2-dimensional array representing the smallest single
	     * contiguous `IRegion` that contains all cells in the supplied array. We
	     * invoke the mapper callback only on the cells in the supplied coordinate
	     * array and store the result. Returns the resulting 2-dimensional array.
	     */
	    Regions.sparseMapCells = function (cells, mapper) {
	        var bounds = Regions.getBoundingRegion(cells);
	        if (bounds == null) {
	            return null;
	        }
	        var numRows = bounds.rows[1] + 1 - bounds.rows[0];
	        var numCols = bounds.cols[1] + 1 - bounds.cols[0];
	        var result = utils_1.Utils.times(numRows, function () { return new Array(numCols); });
	        cells.forEach(function (_a) {
	            var row = _a[0], col = _a[1];
	            result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);
	        });
	        return result;
	    };
	    /**
	     * Returns the smallest single contiguous `IRegion` that contains all cells in the
	     * supplied array.
	     */
	    Regions.getBoundingRegion = function (cells) {
	        var minRow;
	        var maxRow;
	        var minCol;
	        var maxCol;
	        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {
	            var _a = cells_1[_i], row = _a[0], col = _a[1];
	            minRow = (minRow == null || row < minRow) ? row : minRow;
	            maxRow = (maxRow == null || row > maxRow) ? row : maxRow;
	            minCol = (minCol == null || col < minCol) ? col : minCol;
	            maxCol = (maxCol == null || col > maxCol) ? col : maxCol;
	        }
	        if (minRow == null) {
	            return null;
	        }
	        return {
	            cols: [minCol, maxCol],
	            rows: [minRow, maxRow],
	        };
	    };
	    Regions.isValid = function (region) {
	        if (region == null) {
	            return false;
	        }
	        if ((region.rows != null) && (region.rows[0] < 0 || region.rows[1] < 0)) {
	            return false;
	        }
	        if ((region.cols != null) && (region.cols[0] < 0 || region.cols[1] < 0)) {
	            return false;
	        }
	        return true;
	    };
	    Regions.isRegionValidForTable = function (region, numRows, numCols) {
	        if (region.rows != null && (region.rows[0] >= numRows || region.rows[1] >= numRows)) {
	            return false;
	        }
	        if (region.cols != null && (region.cols[0] >= numCols || region.cols[1] >= numCols)) {
	            return false;
	        }
	        return true;
	    };
	    Regions.joinStyledRegionGroups = function (selectedRegions, otherRegions, focusedCell) {
	        var regionGroups = [];
	        if (otherRegions != null) {
	            regionGroups = regionGroups.concat(otherRegions);
	        }
	        if (selectedRegions != null && selectedRegions.length > 0) {
	            regionGroups.push({
	                className: Classes.TABLE_SELECTION_REGION,
	                regions: selectedRegions,
	            });
	        }
	        if (focusedCell != null) {
	            regionGroups.push({
	                className: Classes.TABLE_FOCUS_REGION,
	                regions: [Regions.cell(focusedCell.row, focusedCell.col)],
	            });
	        }
	        return regionGroups;
	    };
	    Regions.regionsEqual = function (regionA, regionB) {
	        return Regions.intervalsEqual(regionA.rows, regionB.rows)
	            && Regions.intervalsEqual(regionA.cols, regionB.cols);
	    };
	    /**
	     * Expands an old region to the minimal bounding region that also contains
	     * the new region. If the regions have different cardinalities, then the new
	     * region is returned. Useful for expanding a selected region on
	     * shift+click, for instance.
	     */
	    Regions.expandRegion = function (oldRegion, newRegion) {
	        var oldRegionCardinality = Regions.getRegionCardinality(oldRegion);
	        var newRegionCardinality = Regions.getRegionCardinality(newRegion);
	        if (newRegionCardinality !== oldRegionCardinality) {
	            return newRegion;
	        }
	        switch (newRegionCardinality) {
	            case RegionCardinality.FULL_ROWS: {
	                var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);
	                var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);
	                return Regions.row(rowStart, rowEnd);
	            }
	            case RegionCardinality.FULL_COLUMNS: {
	                var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);
	                var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);
	                return Regions.column(colStart, colEnd);
	            }
	            case RegionCardinality.CELLS: {
	                var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);
	                var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);
	                var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);
	                var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);
	                return Regions.cell(rowStart, colStart, rowEnd, colEnd);
	            }
	            default:
	                return Regions.table();
	        }
	    };
	    /**
	     * Iterates over the cells within an `IRegion`, invoking the callback with
	     * each cell's coordinates.
	     */
	    Regions.eachCellInRegion = function (region, numRows, numCols, iteratee) {
	        var cardinality = Regions.getRegionCardinality(region);
	        switch (cardinality) {
	            case RegionCardinality.FULL_TABLE:
	                for (var row = 0; row < numRows; row++) {
	                    for (var col = 0; col < numCols; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.FULL_COLUMNS:
	                for (var row = 0; row < numRows; row++) {
	                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.FULL_ROWS:
	                for (var row = region.rows[0]; row <= region.rows[1]; row++) {
	                    for (var col = 0; col < numCols; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            case RegionCardinality.CELLS:
	                for (var row = region.rows[0]; row <= region.rows[1]; row++) {
	                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {
	                        iteratee(row, col);
	                    }
	                }
	                break;
	            default:
	                break;
	        }
	    };
	    Regions.regionContains = function (regionA, regionB) {
	        // containsRegion expects an array of regions as the first param
	        return Regions.overlapsRegion([regionA], regionB, false);
	    };
	    Regions.intervalsEqual = function (ivalA, ivalB) {
	        if (ivalA == null) {
	            return ivalB == null;
	        }
	        else if (ivalB == null) {
	            return false;
	        }
	        else {
	            return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];
	        }
	    };
	    Regions.intervalContainsIndex = function (interval, index) {
	        if (interval == null) {
	            return false;
	        }
	        return interval[0] <= index && interval[1] >= index;
	    };
	    Regions.intervalContains = function (ivalA, ivalB) {
	        if (ivalA == null || ivalB == null) {
	            return false;
	        }
	        return ivalA[0] <= ivalB[0] && ivalB[1] <= ivalA[1];
	    };
	    Regions.intervalOverlaps = function (ivalA, ivalB) {
	        if (ivalA == null || ivalB == null) {
	            return false;
	        }
	        if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {
	            return false;
	        }
	        return true;
	    };
	    Regions.rowFirstComparator = function (a, b) {
	        var rowDiff = a[0] - b[0];
	        return rowDiff === 0 ? a[1] - b[1] : rowDiff;
	    };
	    Regions.numericalComparator = function (a, b) {
	        return a - b;
	    };
	    Regions.normalizeInterval = function (coord, coord2) {
	        if (coord2 == null) {
	            coord2 = coord;
	        }
	        var interval = [coord, coord2];
	        interval.sort(Regions.numericalComparator);
	        return interval;
	    };
	    return Regions;
	}());
	exports.Regions = Regions;
	
	//# sourceMappingURL=regions.js.map


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// HACKHACK: workaround for https://github.com/palantir/tslint/issues/1768
	// tslint:disable adjacent-overload-signatures
	/**
	 * A simple object for storing the client bounds of HTMLElements. Since
	 * ClientRects are immutable, this object enables editing and some simple
	 * manipulation methods.
	 */
	var Rect = (function () {
	    function Rect(left, top, width, height) {
	        this.left = left;
	        this.top = top;
	        this.width = width;
	        this.height = height;
	    }
	    /**
	     * Returns the smallest Rect that entirely contains the supplied rects
	     */
	    Rect.union = function (anyRect0, anyRect1) {
	        var rect0 = Rect.wrap(anyRect0);
	        var rect1 = Rect.wrap(anyRect1);
	        var top = Math.min(rect0.top, rect1.top);
	        var left = Math.min(rect0.left, rect1.left);
	        var bottom = Math.max(rect0.top + rect0.height, rect1.top + rect1.height);
	        var right = Math.max(rect0.left + rect0.width, rect1.left + rect1.width);
	        var height = bottom - top;
	        var width = right - left;
	        return new Rect(left, top, width, height);
	    };
	    /**
	     * Returns a new Rect that subtracts the origin of the second argument
	     * from the first.
	     */
	    Rect.subtractOrigin = function (anyRect0, anyRect1) {
	        var rect0 = Rect.wrap(anyRect0);
	        var rect1 = Rect.wrap(anyRect1);
	        return new Rect(rect0.left - rect1.left, rect0.top - rect1.top, rect0.width, rect0.height);
	    };
	    /**
	     * Returns the CSS properties representing the absolute positioning of
	     * this Rect.
	     */
	    Rect.style = function (rect) {
	        return {
	            height: rect.height + "px",
	            left: rect.left + "px",
	            position: "absolute",
	            top: rect.top + "px",
	            width: rect.width + "px",
	        };
	    };
	    /**
	     * Given a ClientRect or Rect object, returns a Rect object.
	     */
	    Rect.wrap = function (rect) {
	        if (rect instanceof Rect) {
	            return rect;
	        }
	        else {
	            return new Rect(rect.left, rect.top, rect.width, rect.height);
	        }
	    };
	    Rect.prototype.subtractOrigin = function (anyRect) {
	        return Rect.subtractOrigin(this, anyRect);
	    };
	    Rect.prototype.union = function (anyRect) {
	        return Rect.union(this, anyRect);
	    };
	    Rect.prototype.style = function () {
	        return Rect.style(this);
	    };
	    Rect.prototype.sizeStyle = function () {
	        return {
	            height: this.height + "px",
	            width: this.width + "px",
	        };
	    };
	    Rect.prototype.containsX = function (clientX) {
	        return clientX >= this.left && clientX <= this.left + this.width;
	    };
	    Rect.prototype.containsY = function (clientY) {
	        return clientY >= this.top && clientY <= this.top + this.height;
	    };
	    Rect.prototype.equals = function (rect) {
	        return rect != null
	            && this.left === rect.left
	            && this.top === rect.top
	            && this.width === rect.width
	            && this.height === rect.height;
	    };
	    return Rect;
	}());
	Rect.ORIGIN = new Rect(0, 0, 0, 0);
	exports.Rect = Rect;
	
	//# sourceMappingURL=rect.js.map


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved. Licensed
	 * under the BSD-3 License as modified (the “License”); you may obtain a copy of
	 * the license at https://github.com/palantir/blueprint/blob/master/LICENSE and
	 * https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var RenderMode;
	(function (RenderMode) {
	    /**
	     * Renders cells in batches across multiple animation frames. This improves
	     * performance by spreading out work to keep a high FPS and avoid blocking
	     * the UI, but it also introduces a noticeable scan-line rendering artifact
	     * as successive batches of cells finish rendering.
	     */
	    RenderMode[RenderMode["BATCH"] = 0] = "BATCH";
	    /**
	     * Disables the batch-rendering behavior, rendering all cells synchronously
	     * at once. This may result in degraded performance on large tables and/or
	     * on tables with complex cells.
	     */
	    RenderMode[RenderMode["NONE"] = 1] = "NONE";
	})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));
	;
	
	//# sourceMappingURL=renderMode.js.map


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	/**
	 * A React component that measures and rounds the size of its only child. This
	 * is necessary due to a Chrome bug that prevents scrolling when the size is
	 * changed to a fractional value. See this JSFiddle for a repro of the issue:
	 * https://jsfiddle.net/2rmz7p1d/5/
	 */
	var RoundSize = (function (_super) {
	    tslib_1.__extends(RoundSize, _super);
	    function RoundSize() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.setInternalRef = function (ref) { return _this.internalElement = ref; };
	        _this.setContainerRef = function (ref) { return _this.containerElement = ref; };
	        return _this;
	    }
	    RoundSize.prototype.render = function () {
	        return (React.createElement("div", { className: Classes.TABLE_ROUNDED_LAYOUT, ref: this.setContainerRef },
	            React.createElement("div", { className: Classes.TABLE_NO_LAYOUT, ref: this.setInternalRef }, React.Children.only(this.props.children))));
	    };
	    RoundSize.prototype.componentDidMount = function () {
	        this.copyRoundedSize();
	    };
	    RoundSize.prototype.componentDidUpdate = function () {
	        this.copyRoundedSize();
	    };
	    RoundSize.prototype.copyRoundedSize = function () {
	        if (this.internalElement == null || this.containerElement == null) {
	            return;
	        }
	        // measure the size of the internal children
	        var width = Math.round(this.internalElement.clientWidth) + "px";
	        var height = Math.round(this.internalElement.clientHeight) + "px";
	        // set the size of the container element with rounded values
	        this.containerElement.style.width = width;
	        this.containerElement.style.height = height;
	    };
	    return RoundSize;
	}(React.Component));
	exports.RoundSize = RoundSize;
	
	//# sourceMappingURL=roundSize.js.map


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(29));
	__export(__webpack_require__(30));
	
	//# sourceMappingURL=index.js.map


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var clipboard_1 = __webpack_require__(22);
	var regions_1 = __webpack_require__(24);
	var CopyCellsMenuItem = (function (_super) {
	    tslib_1.__extends(CopyCellsMenuItem, _super);
	    function CopyCellsMenuItem() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.handleClick = function () {
	            var _a = _this.props, context = _a.context, getCellData = _a.getCellData, onCopy = _a.onCopy;
	            var cells = context.getUniqueCells();
	            var sparse = regions_1.Regions.sparseMapCells(cells, getCellData);
	            var success = clipboard_1.Clipboard.copyCells(sparse);
	            if (onCopy != null) {
	                onCopy(success);
	            }
	        };
	        return _this;
	    }
	    CopyCellsMenuItem.prototype.render = function () {
	        return React.createElement(core_1.MenuItem, tslib_1.__assign({}, this.props, { onClick: this.handleClick }));
	    };
	    return CopyCellsMenuItem;
	}(React.Component));
	CopyCellsMenuItem = tslib_1.__decorate([
	    PureRender
	], CopyCellsMenuItem);
	exports.CopyCellsMenuItem = CopyCellsMenuItem;
	
	//# sourceMappingURL=copyCellsMenuItem.js.map


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var regions_1 = __webpack_require__(24);
	var MenuContext = (function () {
	    function MenuContext(target, selectedRegions, numRows, numCols) {
	        this.target = target;
	        this.selectedRegions = selectedRegions;
	        this.numRows = numRows;
	        this.numCols = numCols;
	        this.regions = regions_1.Regions.overlapsRegion(selectedRegions, target) ? selectedRegions : [target];
	    }
	    MenuContext.prototype.getTarget = function () {
	        return this.target;
	    };
	    MenuContext.prototype.getSelectedRegions = function () {
	        return this.selectedRegions;
	    };
	    MenuContext.prototype.getRegions = function () {
	        return this.regions;
	    };
	    MenuContext.prototype.getUniqueCells = function () {
	        return regions_1.Regions.enumerateUniqueCells(this.regions, this.numRows, this.numCols);
	    };
	    return MenuContext;
	}());
	exports.MenuContext = MenuContext;
	
	//# sourceMappingURL=menuContext.js.map


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var draggable_1 = __webpack_require__(16);
	var Orientation;
	(function (Orientation) {
	    Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
	    Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
	})(Orientation = exports.Orientation || (exports.Orientation = {}));
	var ResizeHandle = (function (_super) {
	    tslib_1.__extends(ResizeHandle, _super);
	    function ResizeHandle() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isDragging: false,
	        };
	        _this.handleActivate = function (event) {
	            _this.setState({ isDragging: true });
	            _this.props.onLayoutLock(true);
	            event.stopPropagation();
	            event.stopImmediatePropagation();
	            return true;
	        };
	        _this.handleDragMove = function (_event, coords) {
	            var orientationIndex = _this.props.orientation;
	            if (_this.props.onResizeMove != null) {
	                _this.props.onResizeMove(coords.offset[orientationIndex], coords.delta[orientationIndex]);
	            }
	        };
	        _this.handleDragEnd = function (_event, coords) {
	            var orientationIndex = _this.props.orientation;
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	            if (_this.props.onResizeMove != null) {
	                _this.props.onResizeMove(coords.offset[orientationIndex], coords.delta[orientationIndex]);
	            }
	            if (_this.props.onResizeEnd != null) {
	                _this.props.onResizeEnd(coords.offset[orientationIndex]);
	            }
	        };
	        _this.handleClick = function (_event) {
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	        };
	        _this.handleDoubleClick = function (_event) {
	            _this.setState({ isDragging: false });
	            _this.props.onLayoutLock(false);
	            if (_this.props.onDoubleClick != null) {
	                _this.props.onDoubleClick();
	            }
	        };
	        return _this;
	    }
	    ResizeHandle.prototype.render = function () {
	        var _a = this.props, onResizeMove = _a.onResizeMove, onResizeEnd = _a.onResizeEnd, onDoubleClick = _a.onDoubleClick, orientation = _a.orientation;
	        if (onResizeMove == null && onResizeEnd == null && onDoubleClick == null) {
	            return undefined;
	        }
	        var targetClasses = classNames(Classes.TABLE_RESIZE_HANDLE_TARGET, (_b = {},
	            _b[Classes.TABLE_DRAGGING] = this.state.isDragging,
	            _b[Classes.TABLE_RESIZE_HORIZONTAL] = orientation === Orientation.HORIZONTAL,
	            _b[Classes.TABLE_RESIZE_VERTICAL] = orientation === Orientation.VERTICAL,
	            _b));
	        var handleClasses = classNames(Classes.TABLE_RESIZE_HANDLE, (_c = {},
	            _c[Classes.TABLE_DRAGGING] = this.state.isDragging,
	            _c));
	        return (React.createElement(draggable_1.Draggable, { onActivate: this.handleActivate, onClick: this.handleClick, onDoubleClick: this.handleDoubleClick, onDragEnd: this.handleDragEnd, onDragMove: this.handleDragMove },
	            React.createElement("div", { className: targetClasses },
	                React.createElement("div", { className: handleClasses }))));
	        var _b, _c;
	    };
	    return ResizeHandle;
	}(React.Component));
	ResizeHandle = tslib_1.__decorate([
	    PureRender
	], ResizeHandle);
	exports.ResizeHandle = ResizeHandle;
	
	//# sourceMappingURL=resizeHandle.js.map


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var FocusedCellUtils = __webpack_require__(33);
	var utils_1 = __webpack_require__(7);
	var dragEvents_1 = __webpack_require__(17);
	var draggable_1 = __webpack_require__(16);
	var regions_1 = __webpack_require__(24);
	var DragSelectable = (function (_super) {
	    tslib_1.__extends(DragSelectable, _super);
	    function DragSelectable() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.didExpandSelectionOnActivate = false;
	        _this.handleActivate = function (event) {
	            var _a = _this.props, locateClick = _a.locateClick, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	            if (_this.shouldIgnoreMouseDown(event)) {
	                return false;
	            }
	            var region = locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                return false;
	            }
	            if (selectedRegionTransform != null) {
	                region = selectedRegionTransform(region, event);
	            }
	            var foundIndex = regions_1.Regions.findMatchingRegion(selectedRegions, region);
	            var matchesExistingSelection = foundIndex !== -1;
	            if (matchesExistingSelection) {
	                _this.handleUpdateExistingSelection(foundIndex, event);
	                // no need to listen for subsequent drags
	                return false;
	            }
	            else if (_this.shouldExpandSelection(event)) {
	                _this.handleExpandSelection(region);
	            }
	            else if (_this.shouldAddDisjointSelection(event)) {
	                _this.handleAddDisjointSelection(region);
	            }
	            else {
	                _this.handleReplaceSelection(region);
	            }
	            return true;
	        };
	        _this.handleDragMove = function (event, coords) {
	            var _a = _this.props, allowMultipleSelection = _a.allowMultipleSelection, focusedCell = _a.focusedCell, locateClick = _a.locateClick, locateDrag = _a.locateDrag, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	            var region = allowMultipleSelection
	                ? locateDrag(event, coords, /* returnEndOnly? */ _this.didExpandSelectionOnActivate)
	                : locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                return;
	            }
	            else if (selectedRegionTransform != null) {
	                region = selectedRegionTransform(region, event, coords);
	            }
	            var nextSelectedRegions = _this.didExpandSelectionOnActivate
	                ? _this.expandSelectedRegions(selectedRegions, region, focusedCell)
	                : regions_1.Regions.update(selectedRegions, region);
	            _this.maybeInvokeSelectionCallback(nextSelectedRegions);
	            if (!allowMultipleSelection) {
	                // move the focused cell with the selected region
	                var lastIndex = nextSelectedRegions.length - 1;
	                var mostRecentRegion = nextSelectedRegions[lastIndex];
	                _this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);
	            }
	        };
	        _this.handleDragEnd = function () {
	            _this.finishInteraction();
	        };
	        _this.handleClick = function () {
	            _this.finishInteraction();
	        };
	        // Boolean checks
	        // ==============
	        _this.shouldExpandSelection = function (event) {
	            var allowMultipleSelection = _this.props.allowMultipleSelection;
	            return allowMultipleSelection && event.shiftKey;
	        };
	        _this.shouldAddDisjointSelection = function (event) {
	            var allowMultipleSelection = _this.props.allowMultipleSelection;
	            return allowMultipleSelection && dragEvents_1.DragEvents.isAdditive(event);
	        };
	        // Update logic
	        // ============
	        _this.handleUpdateExistingSelection = function (selectedRegionIndex, event) {
	            var _a = _this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
	            if (dragEvents_1.DragEvents.isAdditive(event)) {
	                // remove just the clicked region, leaving other selected regions in place
	                var nextSelectedRegions = selectedRegions.slice();
	                nextSelectedRegions.splice(selectedRegionIndex, 1);
	                onSelection(nextSelectedRegions);
	                // if there are still any selections, move the focused cell to the
	                // most recent selection. otherwise, don't update it.
	                if (nextSelectedRegions.length > 0) {
	                    var lastIndex = nextSelectedRegions.length - 1;
	                    _this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);
	                }
	            }
	            else {
	                // clear all selections, but don't update the focused cell
	                onSelection([]);
	            }
	        };
	        _this.handleExpandSelection = function (region) {
	            var _a = _this.props, focusedCell = _a.focusedCell, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
	            _this.didExpandSelectionOnActivate = true;
	            // there should be only one selected region after expanding. do not
	            // update the focused cell.
	            var nextSelectedRegions = _this.expandSelectedRegions(selectedRegions, region, focusedCell);
	            onSelection(nextSelectedRegions);
	            // move the focused cell into the new region if there were no selections before
	            if (selectedRegions == null || selectedRegions.length === 0) {
	                _this.invokeOnFocusCallbackForRegion(region);
	            }
	        };
	        _this.handleAddDisjointSelection = function (region) {
	            var _a = _this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
	            // add the new region to the existing selections
	            var nextSelectedRegions = regions_1.Regions.add(selectedRegions, region);
	            onSelection(nextSelectedRegions);
	            // put the focused cell in the new region
	            _this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);
	        };
	        _this.handleReplaceSelection = function (region) {
	            var onSelection = _this.props.onSelection;
	            // clear all selections and retain only the new one
	            var nextSelectedRegions = [region];
	            onSelection(nextSelectedRegions);
	            // move the focused cell into the new selection
	            _this.invokeOnFocusCallbackForRegion(region);
	        };
	        _this.invokeOnFocusCallbackForRegion = function (focusRegion, focusSelectionIndex) {
	            if (focusSelectionIndex === void 0) { focusSelectionIndex = 0; }
	            var onFocus = _this.props.onFocus;
	            var focusedCellCoords = regions_1.Regions.getFocusCellCoordinatesFromRegion(focusRegion);
	            onFocus(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));
	        };
	        // Other
	        // =====
	        _this.finishInteraction = function () {
	            core_1.Utils.safeInvoke(_this.props.onSelectionEnd, _this.props.selectedRegions);
	            _this.didExpandSelectionOnActivate = false;
	        };
	        return _this;
	    }
	    DragSelectable.prototype.render = function () {
	        var draggableProps = this.getDraggableProps();
	        return (React.createElement(draggable_1.Draggable, tslib_1.__assign({}, draggableProps, { preventDefault: false }), this.props.children));
	    };
	    DragSelectable.prototype.getDraggableProps = function () {
	        return this.props.onSelection == null ? {} : {
	            onActivate: this.handleActivate,
	            onClick: this.handleClick,
	            onDragEnd: this.handleDragEnd,
	            onDragMove: this.handleDragMove,
	        };
	    };
	    DragSelectable.prototype.shouldIgnoreMouseDown = function (event) {
	        var _a = this.props.ignoredSelectors, ignoredSelectors = _a === void 0 ? [] : _a;
	        var element = event.target;
	        return !utils_1.Utils.isLeftClick(event)
	            || this.props.disabled
	            || ignoredSelectors.some(function (selector) { return element.closest(selector) != null; });
	    };
	    // Callbacks
	    // =========
	    DragSelectable.prototype.maybeInvokeSelectionCallback = function (nextSelectedRegions) {
	        var _a = this.props, onSelection = _a.onSelection, selectedRegions = _a.selectedRegions;
	        // invoke only if the selection changed. this is useful only on
	        // mousemove; there's special handling for mousedown interactions that
	        // target an already-selected region.
	        if (!utils_1.Utils.deepCompareKeys(selectedRegions, nextSelectedRegions)) {
	            onSelection(nextSelectedRegions);
	        }
	    };
	    DragSelectable.prototype.expandSelectedRegions = function (regions, region, focusedCell) {
	        if (regions.length === 0) {
	            return [region];
	        }
	        else if (focusedCell != null) {
	            var expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);
	            return regions_1.Regions.update(regions, expandedRegion);
	        }
	        else {
	            var expandedRegion = regions_1.Regions.expandRegion(regions[regions.length - 1], region);
	            return regions_1.Regions.update(regions, expandedRegion);
	        }
	    };
	    return DragSelectable;
	}(React.Component));
	DragSelectable.defaultProps = {
	    allowMultipleSelection: false,
	    disabled: false,
	    selectedRegions: [],
	};
	DragSelectable = tslib_1.__decorate([
	    PureRender
	], DragSelectable);
	exports.DragSelectable = DragSelectable;
	
	//# sourceMappingURL=selectable.js.map


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var regions_1 = __webpack_require__(24);
	var Errors = __webpack_require__(34);
	/**
	 * Returns the proper focused cell for the given set of initial conditions.
	 */
	function getInitialFocusedCell(enableFocus, focusedCellFromProps, focusedCellFromState, selectedRegions) {
	    if (!enableFocus) {
	        return undefined;
	    }
	    else if (focusedCellFromProps != null) {
	        // controlled mode
	        return focusedCellFromProps;
	    }
	    else if (focusedCellFromState != null) {
	        // use the current focused cell from state
	        return focusedCellFromState;
	    }
	    else if (selectedRegions.length > 0) {
	        // focus the top-left cell of the last selection
	        var lastIndex = selectedRegions.length - 1;
	        return tslib_1.__assign({}, regions_1.Regions.getFocusCellCoordinatesFromRegion(selectedRegions[lastIndex]), { focusSelectionIndex: lastIndex });
	    }
	    else {
	        // focus the top-left cell of the table
	        return { col: 0, row: 0, focusSelectionIndex: 0 };
	    }
	}
	exports.getInitialFocusedCell = getInitialFocusedCell;
	/**
	 * Returns a new cell-coordinates object that includes a focusSelectionIndex property.
	 * The returned object will have the proper IFocusedCellCoordinates type.
	 */
	function toFullCoordinates(cellCoords, focusSelectionIndex) {
	    if (focusSelectionIndex === void 0) { focusSelectionIndex = 0; }
	    return tslib_1.__assign({}, cellCoords, { focusSelectionIndex: focusSelectionIndex });
	}
	exports.toFullCoordinates = toFullCoordinates;
	/**
	 * Expands an existing region to new region based on the current focused cell.
	 * The focused cell is an invariant and should not move as a result of this
	 * operation. This function is used, for instance, to expand a selected region
	 * on shift+click.
	 */
	function expandFocusedRegion(focusedCell, newRegion) {
	    switch (regions_1.Regions.getRegionCardinality(newRegion)) {
	        case regions_1.RegionCardinality.FULL_COLUMNS: {
	            var _a = getExpandedRegionIndices(focusedCell, newRegion, "col", "cols"), indexStart = _a[0], indexEnd = _a[1];
	            return regions_1.Regions.column(indexStart, indexEnd);
	        }
	        case regions_1.RegionCardinality.FULL_ROWS: {
	            var _b = getExpandedRegionIndices(focusedCell, newRegion, "row", "rows"), indexStart = _b[0], indexEnd = _b[1];
	            return regions_1.Regions.row(indexStart, indexEnd);
	        }
	        case regions_1.RegionCardinality.CELLS:
	            var _c = getExpandedRegionIndices(focusedCell, newRegion, "row", "rows"), rowIndexStart = _c[0], rowIndexEnd = _c[1];
	            var _d = getExpandedRegionIndices(focusedCell, newRegion, "col", "cols"), colIndexStart = _d[0], colIndexEnd = _d[1];
	            return regions_1.Regions.cell(rowIndexStart, colIndexStart, rowIndexEnd, colIndexEnd);
	        default:
	            return regions_1.Regions.table();
	    }
	}
	exports.expandFocusedRegion = expandFocusedRegion;
	function getExpandedRegionIndices(focusedCell, newRegion, focusedCellDimension, regionDimension) {
	    var sourceIndex = focusedCell[focusedCellDimension];
	    var _a = newRegion[regionDimension], destinationIndex = _a[0], destinationIndexEnd = _a[1];
	    if (destinationIndex !== destinationIndexEnd) {
	        if (regionDimension === "rows") {
	            throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_ROW_REGION);
	        }
	        else if (regionDimension === "cols") {
	            throw new Error(Errors.TABLE_EXPAND_FOCUSED_REGION_MULTI_COLUMN_REGION);
	        }
	    }
	    return sourceIndex <= destinationIndex
	        ? [sourceIndex, destinationIndex]
	        : [destinationIndex, sourceIndex];
	}
	
	//# sourceMappingURL=focusedCellUtils.js.map


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/*
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var ns = "[Blueprint Table]";
	var deprec = ns + " DEPRECATION:";
	exports.COLUMN_HEADER_CELL_MENU_DEPRECATED = deprec + " <ColumnHeaderCell> menu is deprecated. Use renderMenu instead.";
	exports.ROW_HEADER_CELL_MENU_DEPRECATED = deprec + " <RowHeaderCell> menu is deprecated. Use renderMenu instead.";
	exports.QUADRANT_ON_SCROLL_UNNECESSARILY_DEFINED = ns + " <TableQuadrant> onScroll need not be defined for any quadrant aside from the MAIN quadrant.";
	exports.TABLE_NON_COLUMN_CHILDREN_WARNING = ns + " <Table> Children of Table must be Columns\"";
	exports.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING = ns + " <Table> numFrozenColumns must be in [0, number of columns]";
	exports.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING = ns + " <Table> numFrozenRows must be in [0, numRows]";
	exports.TABLE_EXPAND_FOCUSED_REGION_MULTI_ROW_REGION = ns + " <Table> Cannot expand a FULL_COLUMNS selection using a multi-row region";
	exports.TABLE_EXPAND_FOCUSED_REGION_MULTI_COLUMN_REGION = ns + " <Table> Cannot expand a FULL_COLUMNS selection using a multi-column region";
	
	//# sourceMappingURL=errors.js.map


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var core_1 = __webpack_require__(8);
	var Classes = __webpack_require__(6);
	var Errors = __webpack_require__(34);
	var loadableContent_1 = __webpack_require__(9);
	var headerCell_1 = __webpack_require__(36);
	function HorizontalCellDivider() {
	    return React.createElement("div", { className: Classes.TABLE_HORIZONTAL_CELL_DIVIDER });
	}
	exports.HorizontalCellDivider = HorizontalCellDivider;
	var ColumnHeaderCell = (function (_super) {
	    tslib_1.__extends(ColumnHeaderCell, _super);
	    function ColumnHeaderCell() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isActive: false,
	        };
	        _this.handlePopoverDidOpen = function () {
	            _this.setState({ isActive: true });
	        };
	        _this.handlePopoverWillClose = function () {
	            _this.setState({ isActive: false });
	        };
	        return _this;
	    }
	    /**
	     * This method determines if a `MouseEvent` was triggered on a target that
	     * should be used as the header click/drag target. This enables users of
	     * this component to render fully interactive components in their header
	     * cells without worry of selection or resize operations from capturing
	     * their mouse events.
	     */
	    ColumnHeaderCell.isHeaderMouseTarget = function (target) {
	        return target.classList.contains(Classes.TABLE_HEADER)
	            || target.classList.contains(Classes.TABLE_COLUMN_NAME)
	            || target.classList.contains(Classes.TABLE_INTERACTION_BAR)
	            || target.classList.contains(Classes.TABLE_HEADER_CONTENT);
	    };
	    ColumnHeaderCell.prototype.render = function () {
	        var _a = this.props, 
	        // from IColumnHeaderCellProps
	        isColumnReorderable = _a.isColumnReorderable, isColumnSelected = _a.isColumnSelected, menuIconName = _a.menuIconName, 
	        // from IColumnNameProps
	        name = _a.name, renderName = _a.renderName, useInteractionBar = _a.useInteractionBar, 
	        // from IHeaderProps
	        spreadableProps = tslib_1.__rest(_a, ["isColumnReorderable", "isColumnSelected", "menuIconName", "name", "renderName", "useInteractionBar"]);
	        var classes = classNames(spreadableProps.className, Classes.TABLE_COLUMN_HEADER_CELL, (_b = {},
	            _b[Classes.TABLE_HAS_INTERACTION_BAR] = useInteractionBar,
	            _b[Classes.TABLE_HAS_REORDER_HANDLE] = this.props.reorderHandle != null,
	            _b));
	        return (React.createElement(headerCell_1.HeaderCell, tslib_1.__assign({ isReorderable: this.props.isColumnReorderable, isSelected: this.props.isColumnSelected }, spreadableProps, { className: classes }),
	            this.renderName(),
	            this.maybeRenderContent(),
	            this.props.loading ? undefined : this.props.resizeHandle));
	        var _b;
	    };
	    ColumnHeaderCell.prototype.validateProps = function (nextProps) {
	        if (nextProps.menu != null) {
	            // throw this warning from the publicly exported, higher-order *HeaderCell components
	            // rather than HeaderCell, so consumers know exactly which components are receiving the
	            // offending prop
	            console.warn(Errors.COLUMN_HEADER_CELL_MENU_DEPRECATED);
	        }
	    };
	    ColumnHeaderCell.prototype.renderName = function () {
	        var _a = this.props, index = _a.index, loading = _a.loading, name = _a.name, renderName = _a.renderName, reorderHandle = _a.reorderHandle, useInteractionBar = _a.useInteractionBar;
	        var dropdownMenu = this.maybeRenderDropdownMenu();
	        var defaultName = React.createElement("div", { className: Classes.TABLE_TRUNCATED_TEXT }, name);
	        var nameComponent = (React.createElement(loadableContent_1.LoadableContent, { loading: loading, variableLength: true }, renderName == null ? defaultName : renderName(name, index)));
	        if (useInteractionBar) {
	            return (React.createElement("div", { className: Classes.TABLE_COLUMN_NAME, title: name },
	                React.createElement("div", { className: Classes.TABLE_INTERACTION_BAR },
	                    reorderHandle,
	                    dropdownMenu),
	                React.createElement(HorizontalCellDivider, null),
	                React.createElement("div", { className: Classes.TABLE_COLUMN_NAME_TEXT }, nameComponent)));
	        }
	        else {
	            return (React.createElement("div", { className: Classes.TABLE_COLUMN_NAME, title: name },
	                reorderHandle,
	                dropdownMenu,
	                React.createElement("div", { className: Classes.TABLE_COLUMN_NAME_TEXT }, nameComponent)));
	        }
	    };
	    ColumnHeaderCell.prototype.maybeRenderContent = function () {
	        if (this.props.children === null) {
	            return undefined;
	        }
	        return (React.createElement("div", { className: Classes.TABLE_HEADER_CONTENT }, this.props.children));
	    };
	    ColumnHeaderCell.prototype.maybeRenderDropdownMenu = function () {
	        var _a = this.props, index = _a.index, menu = _a.menu, menuIconName = _a.menuIconName, renderMenu = _a.renderMenu;
	        if (renderMenu == null && menu == null) {
	            return undefined;
	        }
	        var constraints = [{
	                attachment: "together",
	                pin: true,
	                to: "window",
	            }];
	        var classes = classNames(Classes.TABLE_TH_MENU_CONTAINER, (_b = {},
	            _b[Classes.TABLE_TH_MENU_OPEN] = this.state.isActive,
	            _b));
	        // prefer renderMenu if it's defined
	        var content = core_1.Utils.isFunction(renderMenu)
	            ? renderMenu(index)
	            : menu;
	        return (React.createElement("div", { className: classes },
	            React.createElement("div", { className: Classes.TABLE_TH_MENU_CONTAINER_BACKGROUND }),
	            React.createElement(core_1.Popover, { tetherOptions: { constraints: constraints }, content: content, position: core_1.Position.BOTTOM, className: Classes.TABLE_TH_MENU, popoverDidOpen: this.handlePopoverDidOpen, popoverWillClose: this.handlePopoverWillClose, useSmartArrowPositioning: true },
	                React.createElement(core_1.Icon, { iconName: menuIconName }))));
	        var _b;
	    };
	    return ColumnHeaderCell;
	}(core_1.AbstractComponent));
	ColumnHeaderCell.defaultProps = {
	    isActive: false,
	    menuIconName: "chevron-down",
	    useInteractionBar: false,
	};
	exports.ColumnHeaderCell = ColumnHeaderCell;
	
	//# sourceMappingURL=columnHeaderCell.js.map


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var core_1 = __webpack_require__(8);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var HeaderCell = (function (_super) {
	    tslib_1.__extends(HeaderCell, _super);
	    function HeaderCell() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.state = {
	            isActive: false,
	        };
	        return _this;
	    }
	    HeaderCell.prototype.shouldComponentUpdate = function (nextProps) {
	        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: ["style"] })
	            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, ["style"]);
	    };
	    HeaderCell.prototype.renderContextMenu = function (_event) {
	        var renderMenu = this.props.renderMenu;
	        if (core_1.Utils.isFunction(renderMenu)) {
	            // the preferred way (a consistent function instance that won't cause as many re-renders)
	            return renderMenu(this.props.index);
	        }
	        else {
	            // the deprecated way (leads to lots of unnecessary re-renders because of menu-item
	            // callbacks needing access to the index of the right-clicked cell, which demands that
	            // new callback functions and JSX elements be recreated on each render of the parent)
	            return this.props.menu;
	        }
	    };
	    HeaderCell.prototype.render = function () {
	        var classes = classNames(Classes.TABLE_HEADER, (_a = {},
	            _a[Classes.TABLE_HEADER_ACTIVE] = this.props.isActive || this.state.isActive,
	            _a[Classes.TABLE_HEADER_SELECTED] = this.props.isSelected,
	            _a[core_1.Classes.LOADING] = this.props.loading,
	            _a), this.props.className);
	        return (React.createElement("div", { className: classes, style: this.props.style }, this.props.children));
	        var _a;
	    };
	    return HeaderCell;
	}(React.Component));
	HeaderCell = tslib_1.__decorate([
	    core_1.ContextMenuTarget
	], HeaderCell);
	exports.HeaderCell = HeaderCell;
	
	//# sourceMappingURL=headerCell.js.map


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var core_1 = __webpack_require__(8);
	var Classes = __webpack_require__(6);
	var Errors = __webpack_require__(34);
	var loadableContent_1 = __webpack_require__(9);
	var headerCell_1 = __webpack_require__(36);
	var RowHeaderCell = (function (_super) {
	    tslib_1.__extends(RowHeaderCell, _super);
	    function RowHeaderCell() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    RowHeaderCell.prototype.render = function () {
	        var loadableContentDivClasses = classNames(Classes.TABLE_ROW_NAME_TEXT, Classes.TABLE_TRUNCATED_TEXT);
	        var _a = this.props, 
	        // from IRowHeaderCellProps
	        isRowReorderable = _a.isRowReorderable, isRowSelected = _a.isRowSelected, 
	        // from IHeaderProps
	        spreadableProps = tslib_1.__rest(_a, ["isRowReorderable", "isRowSelected"]);
	        return (React.createElement(headerCell_1.HeaderCell, tslib_1.__assign({ isReorderable: this.props.isRowReorderable, isSelected: this.props.isRowSelected }, spreadableProps),
	            React.createElement("div", { className: Classes.TABLE_ROW_NAME },
	                React.createElement(loadableContent_1.LoadableContent, { loading: spreadableProps.loading },
	                    React.createElement("div", { className: loadableContentDivClasses }, spreadableProps.name))),
	            this.props.children,
	            spreadableProps.loading ? undefined : spreadableProps.resizeHandle));
	    };
	    RowHeaderCell.prototype.validateProps = function (nextProps) {
	        if (nextProps.menu != null) {
	            // throw this warning from the publicly exported, higher-order *HeaderCell components
	            // rather than HeaderCell, so consumers know exactly which components are receiving the
	            // offending prop
	            console.warn(Errors.ROW_HEADER_CELL_MENU_DEPRECATED);
	        }
	    };
	    return RowHeaderCell;
	}(core_1.AbstractComponent));
	exports.RowHeaderCell = RowHeaderCell;
	
	//# sourceMappingURL=rowHeaderCell.js.map


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var EditableName = (function (_super) {
	    tslib_1.__extends(EditableName, _super);
	    function EditableName() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    EditableName.prototype.render = function () {
	        var _a = this.props, className = _a.className, intent = _a.intent, name = _a.name, onCancel = _a.onCancel, onChange = _a.onChange, onConfirm = _a.onConfirm;
	        return (React.createElement(core_1.EditableText, { className: classNames(className, Classes.TABLE_EDITABLE_NAME), defaultValue: name, intent: intent, minWidth: null, onCancel: onCancel, onChange: onChange, onConfirm: onConfirm, placeholder: "", selectAllOnFocus: true }));
	    };
	    return EditableName;
	}(React.Component));
	EditableName = tslib_1.__decorate([
	    PureRender
	], EditableName);
	exports.EditableName = EditableName;
	
	//# sourceMappingURL=editableName.js.map


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var core_2 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var column_1 = __webpack_require__(20);
	var Classes = __webpack_require__(6);
	var clipboard_1 = __webpack_require__(22);
	var Errors = __webpack_require__(34);
	var grid_1 = __webpack_require__(23);
	var FocusedCellUtils = __webpack_require__(33);
	var ScrollUtils = __webpack_require__(40);
	var rect_1 = __webpack_require__(25);
	var renderMode_1 = __webpack_require__(26);
	var utils_1 = __webpack_require__(7);
	var columnHeader_1 = __webpack_require__(41);
	var columnHeaderCell_1 = __webpack_require__(35);
	var rowHeader_1 = __webpack_require__(47);
	var resizeSensor_1 = __webpack_require__(48);
	var guides_1 = __webpack_require__(49);
	var regions_1 = __webpack_require__(50);
	var locator_1 = __webpack_require__(51);
	var tableQuadrant_1 = __webpack_require__(52);
	var tableQuadrantStack_1 = __webpack_require__(53);
	var regions_2 = __webpack_require__(24);
	var tableBody_1 = __webpack_require__(54);
	var Table = Table_1 = (function (_super) {
	    tslib_1.__extends(Table, _super);
	    function Table(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.refHandlers = {
	            columnHeader: function (ref) { return _this.columnHeaderElement = ref; },
	            mainQuadrant: function (ref) { return _this.mainQuadrantElement = ref; },
	            quadrantStack: function (ref) { return _this.quadrantStackInstance = ref; },
	            rowHeader: function (ref) { return _this.rowHeaderElement = ref; },
	            scrollContainer: function (ref) { return _this.scrollContainerElement = ref; },
	        };
	        _this.handleCopy = function (e) {
	            var grid = _this.grid;
	            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;
	            var selectedRegions = _this.state.selectedRegions;
	            if (getCellClipboardData == null) {
	                return;
	            }
	            // prevent "real" copy from being called
	            e.preventDefault();
	            e.stopPropagation();
	            var cells = regions_2.Regions.enumerateUniqueCells(selectedRegions, grid.numRows, grid.numCols);
	            var sparse = regions_2.Regions.sparseMapCells(cells, getCellClipboardData);
	            if (sparse != null) {
	                var success = clipboard_1.Clipboard.copyCells(sparse);
	                core_1.Utils.safeInvoke(onCopy, success);
	            }
	        };
	        _this.renderMenu = function (refHandler) {
	            var classes = classNames(Classes.TABLE_MENU, (_a = {},
	                _a[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE),
	                _a));
	            return (React.createElement("div", { className: classes, ref: refHandler, onMouseDown: _this.handleMenuMouseDown }, _this.maybeRenderRegions(_this.styleMenuRegion)));
	            var _a;
	        };
	        _this.handleMenuMouseDown = function (e) {
	            // the shift+click interaction expands the region from the focused cell.
	            // thus, if shift is pressed we shouldn't move the focused cell.
	            _this.selectAll(!e.shiftKey);
	        };
	        _this.selectAll = function (shouldUpdateFocusedCell) {
	            var selectionHandler = _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_TABLE);
	            // clicking on upper left hand corner sets selection to "all"
	            // regardless of current selection state (clicking twice does not deselect table)
	            selectionHandler([regions_2.Regions.table()]);
	            if (shouldUpdateFocusedCell) {
	                var newFocusedCellCoordinates = regions_2.Regions.getFocusCellCoordinatesFromRegion(regions_2.Regions.table());
	                _this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));
	            }
	        };
	        _this.handleSelectAllHotkey = function (e) {
	            // prevent "real" select all from happening as well
	            e.preventDefault();
	            e.stopPropagation();
	            // selecting-all via the keyboard should not move the focused cell.
	            _this.selectAll(false);
	        };
	        _this.columnHeaderCellRenderer = function (columnIndex) {
	            var props = _this.getColumnProps(columnIndex);
	            var id = props.id, loadingOptions = props.loadingOptions, renderCell = props.renderCell, renderColumnHeader = props.renderColumnHeader, spreadableProps = tslib_1.__rest(props, ["id", "loadingOptions", "renderCell", "renderColumnHeader"]);
	            var columnLoading = _this.hasLoadingOption(loadingOptions, regions_2.ColumnLoadingOption.HEADER);
	            if (renderColumnHeader != null) {
	                var columnHeader = renderColumnHeader(columnIndex);
	                var columnHeaderLoading = columnHeader.props.loading;
	                return React.cloneElement(columnHeader, {
	                    loading: columnHeaderLoading != null ? columnHeaderLoading : columnLoading,
	                });
	            }
	            var baseProps = tslib_1.__assign({ index: columnIndex, loading: columnLoading }, spreadableProps);
	            if (props.name != null) {
	                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, baseProps));
	            }
	            else {
	                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, baseProps, { name: utils_1.Utils.toBase26Alpha(columnIndex) }));
	            }
	        };
	        _this.renderColumnHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly) {
	            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }
	            var _a = _this, grid = _a.grid, locator = _a.locator;
	            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
	            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, isColumnReorderable = _c.isColumnReorderable, isColumnResizable = _c.isColumnResizable, loadingOptions = _c.loadingOptions, maxColumnWidth = _c.maxColumnWidth, minColumnWidth = _c.minColumnWidth, selectedRegionTransform = _c.selectedRegionTransform;
	            var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_d = {},
	                _d[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_COLUMNS),
	                _d));
	            var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
	            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;
	            var columnIndexEnd = showFrozenColumnsOnly ? _this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;
	            return (React.createElement("div", { className: classes, ref: refHandler },
	                React.createElement(columnHeader_1.ColumnHeader, { allowMultipleSelection: allowMultipleSelection, cellRenderer: _this.columnHeaderCellRenderer, focusedCell: focusedCell, grid: grid, isReorderable: isColumnReorderable, isResizable: isColumnResizable, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS), locator: locator, maxColumnWidth: maxColumnWidth, minColumnWidth: minColumnWidth, onColumnWidthChanged: _this.handleColumnWidthChanged, onFocus: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onReordered: _this.handleColumnsReordered, onReordering: reorderingHandler, onResizeGuide: resizeHandler, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd }, _this.props.children),
	                _this.maybeRenderRegions(_this.styleColumnHeaderRegion)));
	            var _d;
	        };
	        _this.renderRowHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly) {
	            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }
	            var _a = _this, grid = _a.grid, locator = _a.locator;
	            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
	            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, isRowReorderable = _c.isRowReorderable, isRowResizable = _c.isRowResizable, loadingOptions = _c.loadingOptions, maxRowHeight = _c.maxRowHeight, minRowHeight = _c.minRowHeight, renderRowHeader = _c.renderRowHeader, selectedRegionTransform = _c.selectedRegionTransform;
	            var classes = classNames(Classes.TABLE_ROW_HEADERS, (_d = {},
	                _d[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_ROWS),
	                _d));
	            var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
	            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;
	            var rowIndexEnd = showFrozenRowsOnly ? _this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;
	            return (React.createElement("div", { className: classes, ref: refHandler },
	                React.createElement(rowHeader_1.RowHeader, { allowMultipleSelection: allowMultipleSelection, focusedCell: focusedCell, grid: grid, locator: locator, isReorderable: isRowReorderable, isResizable: isRowResizable, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocus: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onResizeGuide: resizeHandler, onReordered: _this.handleRowsReordered, onReordering: reorderingHandler, onRowHeightChanged: _this.handleRowHeightChanged, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_ROWS), renderRowHeader: renderRowHeader, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd }),
	                _this.maybeRenderRegions(_this.styleRowHeaderRegion)));
	            var _d;
	        };
	        _this.bodyCellRenderer = function (rowIndex, columnIndex) {
	            var columnProps = _this.getColumnProps(columnIndex);
	            var cell = columnProps.renderCell(rowIndex, columnIndex);
	            var cellLoading = cell.props.loading;
	            var loading = cellLoading != null
	                ? cellLoading
	                : _this.hasLoadingOption(columnProps.loadingOptions, regions_2.ColumnLoadingOption.CELLS);
	            return React.cloneElement(cell, tslib_1.__assign({}, columnProps, { loading: loading }));
	        };
	        _this.renderBody = function (quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly) {
	            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }
	            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }
	            var _a = _this, grid = _a.grid, locator = _a.locator;
	            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
	            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, loadingOptions = _c.loadingOptions, renderBodyContextMenu = _c.renderBodyContextMenu, renderMode = _c.renderMode, selectedRegionTransform = _c.selectedRegionTransform;
	            var numFrozenColumns = _this.getNumFrozenColumnsClamped();
	            var numFrozenRows = _this.getNumFrozenRowsClamped();
	            var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
	            var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
	            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;
	            var columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns : columnIndices.columnIndexEnd;
	            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;
	            var rowIndexEnd = showFrozenRowsOnly ? numFrozenRows : rowIndices.rowIndexEnd;
	            // the main quadrant contains all cells in the table, so listen only to that quadrant
	            var onCompleteRender = quadrantType === tableQuadrant_1.QuadrantType.MAIN
	                ? _this.handleCompleteRender
	                : undefined;
	            return (React.createElement("div", null,
	                React.createElement(tableBody_1.TableBody, { allowMultipleSelection: allowMultipleSelection, cellRenderer: _this.bodyCellRenderer, focusedCell: focusedCell, grid: grid, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.CELLS), locator: locator, onCompleteRender: onCompleteRender, onFocus: _this.handleFocus, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.CELLS), renderBodyContextMenu: renderBodyContextMenu, renderMode: renderMode, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd, numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined, numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined }),
	                _this.maybeRenderRegions(_this.styleBodyRegion, quadrantType)));
	        };
	        _this.handleCompleteRender = function () {
	            // the first onCompleteRender is triggered before the viewportRect is
	            // defined and the second after the viewportRect has been set. the cells
	            // will only actually render once the viewportRect is defined though, so
	            // we defer invoking onCompleteRender until that check passes.
	            if (_this.state.viewportRect != null) {
	                core_1.Utils.safeInvoke(_this.props.onCompleteRender);
	            }
	        };
	        _this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, "left"); };
	        _this.handleFocusMoveLeftInternal = function (e) { return _this.handleFocusMoveInternal(e, "left"); };
	        _this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, "right"); };
	        _this.handleFocusMoveRightInternal = function (e) { return _this.handleFocusMoveInternal(e, "right"); };
	        _this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, "up"); };
	        _this.handleFocusMoveUpInternal = function (e) { return _this.handleFocusMoveInternal(e, "up"); };
	        _this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, "down"); };
	        _this.handleFocusMoveDownInternal = function (e) { return _this.handleFocusMoveInternal(e, "down"); };
	        _this.styleBodyRegion = function (region, quadrantType) {
	            var numFrozenColumns = _this.props.numFrozenColumns;
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = _this.grid.getRegionStyle(region);
	            // ensure we're not showing borders at the boundary of the frozen-columns area
	            var canHideRightBorder = (quadrantType === tableQuadrant_1.QuadrantType.TOP_LEFT || quadrantType === tableQuadrant_1.QuadrantType.LEFT)
	                && numFrozenColumns != null && numFrozenColumns > 0;
	            var fixedHeight = _this.grid.getHeight();
	            var fixedWidth = _this.grid.getWidth();
	            // include a correction in some cases to hide borders along quadrant boundaries
	            var alignmentCorrection = 1;
	            var alignmentCorrectionString = "-" + alignmentCorrection + "px";
	            switch (cardinality) {
	                case regions_2.RegionCardinality.CELLS:
	                    return style;
	                case regions_2.RegionCardinality.FULL_COLUMNS:
	                    style.top = alignmentCorrectionString;
	                    style.height = fixedHeight + alignmentCorrection;
	                    return style;
	                case regions_2.RegionCardinality.FULL_ROWS:
	                    style.left = alignmentCorrectionString;
	                    style.width = fixedWidth + alignmentCorrection;
	                    if (canHideRightBorder) {
	                        style.right = alignmentCorrectionString;
	                    }
	                    return style;
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.left = alignmentCorrectionString;
	                    style.top = alignmentCorrectionString;
	                    style.width = fixedWidth + alignmentCorrection;
	                    style.height = fixedHeight + alignmentCorrection;
	                    if (canHideRightBorder) {
	                        style.right = alignmentCorrectionString;
	                    }
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        _this.styleMenuRegion = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.right = "0px";
	                    style.bottom = "0px";
	                    style.top = "0px";
	                    style.left = "0px";
	                    style.borderBottom = "none";
	                    style.borderRight = "none";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        _this.styleColumnHeaderRegion = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.left = "-1px";
	                    style.borderLeft = "none";
	                    style.bottom = "-1px";
	                    return style;
	                case regions_2.RegionCardinality.FULL_COLUMNS:
	                    style.bottom = "-1px";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        _this.styleRowHeaderRegion = function (region) {
	            var grid = _this.grid;
	            var viewportRect = _this.state.viewportRect;
	            if (viewportRect == null) {
	                return {};
	            }
	            var cardinality = regions_2.Regions.getRegionCardinality(region);
	            var style = grid.getRegionStyle(region);
	            switch (cardinality) {
	                case regions_2.RegionCardinality.FULL_TABLE:
	                    style.top = "-1px";
	                    style.borderTop = "none";
	                    style.right = "-1px";
	                    return style;
	                case regions_2.RegionCardinality.FULL_ROWS:
	                    style.right = "-1px";
	                    return style;
	                default:
	                    return { display: "none" };
	            }
	        };
	        _this.handleColumnWidthChanged = function (columnIndex, width) {
	            var selectedRegions = _this.state.selectedRegions;
	            var columnWidths = _this.state.columnWidths.slice();
	            if (regions_2.Regions.hasFullTable(selectedRegions)) {
	                for (var col = 0; col < columnWidths.length; col++) {
	                    columnWidths[col] = width;
	                }
	            }
	            if (regions_2.Regions.hasFullColumn(selectedRegions, columnIndex)) {
	                regions_2.Regions.eachUniqueFullColumn(selectedRegions, function (col) {
	                    columnWidths[col] = width;
	                });
	            }
	            else {
	                columnWidths[columnIndex] = width;
	            }
	            _this.invalidateGrid();
	            _this.setState({ columnWidths: columnWidths });
	            var onColumnWidthChanged = _this.props.onColumnWidthChanged;
	            if (onColumnWidthChanged != null) {
	                onColumnWidthChanged(columnIndex, width);
	            }
	        };
	        _this.handleRowHeightChanged = function (rowIndex, height) {
	            var selectedRegions = _this.state.selectedRegions;
	            var rowHeights = _this.state.rowHeights.slice();
	            if (regions_2.Regions.hasFullTable(selectedRegions)) {
	                for (var row = 0; row < rowHeights.length; row++) {
	                    rowHeights[row] = height;
	                }
	            }
	            if (regions_2.Regions.hasFullRow(selectedRegions, rowIndex)) {
	                regions_2.Regions.eachUniqueFullRow(selectedRegions, function (row) {
	                    rowHeights[row] = height;
	                });
	            }
	            else {
	                rowHeights[rowIndex] = height;
	            }
	            _this.invalidateGrid();
	            _this.setState({ rowHeights: rowHeights });
	            var onRowHeightChanged = _this.props.onRowHeightChanged;
	            if (onRowHeightChanged != null) {
	                onRowHeightChanged(rowIndex, height);
	            }
	        };
	        _this.handleRootScroll = function (_event) {
	            // Bug #211 - Native browser text selection events can cause the root
	            // element to scroll even though it has a overflow:hidden style. The
	            // only viable solution to this is to unscroll the element after the
	            // browser scrolls it.
	            if (_this.rootTableElement != null) {
	                _this.rootTableElement.scrollLeft = 0;
	                _this.rootTableElement.scrollTop = 0;
	            }
	        };
	        _this.handleBodyScroll = function (event) {
	            // Prevent the event from propagating to avoid a resize event on the
	            // resize sensor.
	            event.stopPropagation();
	            if (_this.locator != null && !_this.state.isLayoutLocked) {
	                var viewportRect = _this.locator.getViewportRect();
	                _this.updateViewportRect(viewportRect);
	            }
	        };
	        _this.clearSelection = function (_selectedRegions) {
	            _this.handleSelection([]);
	        };
	        // no good way to call arrow-key keyboard events from tests
	        /* istanbul ignore next */
	        _this.handleFocusMove = function (e, direction) {
	            e.preventDefault();
	            e.stopPropagation();
	            var focusedCell = _this.state.focusedCell;
	            if (focusedCell == null) {
	                // halt early if we have a selectedRegionTransform or something else in play that nixes
	                // the focused cell.
	                return;
	            }
	            var newFocusedCell = { col: focusedCell.col, row: focusedCell.row, focusSelectionIndex: 0 };
	            var grid = _this.grid;
	            switch (direction) {
	                case "up":
	                    newFocusedCell.row -= 1;
	                    break;
	                case "down":
	                    newFocusedCell.row += 1;
	                    break;
	                case "left":
	                    newFocusedCell.col -= 1;
	                    break;
	                case "right":
	                    newFocusedCell.col += 1;
	                    break;
	                default:
	                    break;
	            }
	            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
	                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
	                return;
	            }
	            // change selection to match new focus cell location
	            var newSelectionRegions = [regions_2.Regions.cell(newFocusedCell.row, newFocusedCell.col)];
	            _this.handleSelection(newSelectionRegions);
	            _this.handleFocus(newFocusedCell);
	            // keep the focused cell in view
	            _this.scrollBodyToFocusedCell(newFocusedCell);
	        };
	        // no good way to call arrow-key keyboard events from tests
	        /* istanbul ignore next */
	        _this.handleFocusMoveInternal = function (e, direction) {
	            e.preventDefault();
	            e.stopPropagation();
	            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;
	            var grid = _this.grid;
	            if (focusedCell == null) {
	                // halt early if we have a selectedRegionTransform or something else in play that nixes
	                // the focused cell.
	                return;
	            }
	            var newFocusedCell = {
	                col: focusedCell.col,
	                focusSelectionIndex: focusedCell.focusSelectionIndex,
	                row: focusedCell.row,
	            };
	            // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one
	            if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {
	                var focusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[0], grid.numRows, grid.numCols);
	                newFocusedCell = {
	                    col: focusCellRegion.cols[0],
	                    focusSelectionIndex: 0,
	                    row: focusCellRegion.rows[0],
	                };
	            }
	            else {
	                if (selectedRegions.length === 0) {
	                    _this.handleFocusMove(e, direction);
	                    return;
	                }
	                var focusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], grid.numRows, grid.numCols);
	                if (focusCellRegion.cols[0] === focusCellRegion.cols[1]
	                    && focusCellRegion.rows[0] === focusCellRegion.rows[1]
	                    && selectedRegions.length === 1) {
	                    _this.handleFocusMove(e, direction);
	                    return;
	                }
	                switch (direction) {
	                    case "up":
	                        newFocusedCell = _this.moveFocusCell("row", "col", true, newFocusedCell, focusCellRegion);
	                        break;
	                    case "left":
	                        newFocusedCell = _this.moveFocusCell("col", "row", true, newFocusedCell, focusCellRegion);
	                        break;
	                    case "down":
	                        newFocusedCell = _this.moveFocusCell("row", "col", false, newFocusedCell, focusCellRegion);
	                        break;
	                    case "right":
	                        newFocusedCell = _this.moveFocusCell("col", "row", false, newFocusedCell, focusCellRegion);
	                        break;
	                    default:
	                        break;
	                }
	            }
	            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
	                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
	                return;
	            }
	            _this.handleFocus(newFocusedCell);
	            // keep the focused cell in view
	            _this.scrollBodyToFocusedCell(newFocusedCell);
	        };
	        _this.scrollBodyToFocusedCell = function (focusedCell) {
	            var row = focusedCell.row, col = focusedCell.col;
	            var viewportRect = _this.state.viewportRect;
	            // sort keys in normal CSS position order (per the trusty TRBL/"trouble" acronym)
	            // tslint:disable:object-literal-sort-keys
	            var viewportBounds = {
	                top: viewportRect.top,
	                right: viewportRect.left + viewportRect.width,
	                bottom: viewportRect.top + viewportRect.height,
	                left: viewportRect.left,
	            };
	            var focusedCellBounds = {
	                top: _this.grid.getCumulativeHeightBefore(row),
	                right: _this.grid.getCumulativeWidthAt(col),
	                bottom: _this.grid.getCumulativeHeightAt(row),
	                left: _this.grid.getCumulativeWidthBefore(col),
	            };
	            // tslint:enable:object-literal-sort-keys
	            var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;
	            var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;
	            var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;
	            var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;
	            var nextScrollTop = viewportRect.top;
	            var nextScrollLeft = viewportRect.left;
	            // keep the top end of an overly tall focused cell in view when moving left and right
	            // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)
	            if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {
	                // scroll up (minus one pixel to avoid clipping the focused-cell border)
	                nextScrollTop = Math.max(0, focusedCellBounds.top - 1);
	            }
	            else if (focusedCellBounds.bottom > viewportBounds.bottom) {
	                // scroll down
	                var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;
	                nextScrollTop = viewportBounds.top + scrollDelta;
	            }
	            // keep the left end of an overly wide focused cell in view when moving up and down
	            if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {
	                // scroll left (again minus one additional pixel)
	                nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);
	            }
	            else if (focusedCellBounds.right > viewportBounds.right) {
	                // scroll right
	                var scrollDelta = focusedCellBounds.right - viewportBounds.right;
	                nextScrollLeft = viewportBounds.left + scrollDelta;
	            }
	            _this.syncViewportPosition(nextScrollLeft, nextScrollTop);
	        };
	        _this.handleFocus = function (focusedCell) {
	            if (!_this.props.enableFocus) {
	                // don't set focus state if focus is not allowed
	                return;
	            }
	            // only set focused cell state if not specified in props
	            if (_this.props.focusedCell == null) {
	                _this.setState({ focusedCell: focusedCell });
	            }
	            core_1.Utils.safeInvoke(_this.props.onFocus, focusedCell);
	        };
	        _this.handleSelection = function (selectedRegions) {
	            // only set selectedRegions state if not specified in props
	            if (_this.props.selectedRegions == null) {
	                _this.setState({ selectedRegions: selectedRegions });
	            }
	            var onSelection = _this.props.onSelection;
	            if (onSelection != null) {
	                onSelection(selectedRegions);
	            }
	        };
	        _this.handleColumnsReordering = function (verticalGuides) {
	            _this.setState({ isReordering: true, verticalGuides: verticalGuides });
	        };
	        _this.handleColumnsReordered = function (oldIndex, newIndex, length) {
	            _this.setState({ isReordering: false, verticalGuides: undefined });
	            core_1.Utils.safeInvoke(_this.props.onColumnsReordered, oldIndex, newIndex, length);
	        };
	        _this.handleRowsReordering = function (horizontalGuides) {
	            _this.setState({ isReordering: true, horizontalGuides: horizontalGuides });
	        };
	        _this.handleRowsReordered = function (oldIndex, newIndex, length) {
	            _this.setState({ isReordering: false, horizontalGuides: undefined });
	            core_1.Utils.safeInvoke(_this.props.onRowsReordered, oldIndex, newIndex, length);
	        };
	        _this.handleLayoutLock = function (isLayoutLocked) {
	            if (isLayoutLocked === void 0) { isLayoutLocked = false; }
	            _this.setState({ isLayoutLocked: isLayoutLocked });
	        };
	        _this.hasLoadingOption = function (loadingOptions, loadingOption) {
	            if (loadingOptions == null) {
	                return undefined;
	            }
	            return loadingOptions.indexOf(loadingOption) >= 0;
	        };
	        _this.updateViewportRect = function (nextViewportRect) {
	            _this.setState({ viewportRect: nextViewportRect });
	            var viewportRect = _this.state.viewportRect;
	            var didViewportChange = (viewportRect != null && !viewportRect.equals(nextViewportRect))
	                || (viewportRect == null && nextViewportRect != null);
	            if (didViewportChange) {
	                _this.invokeOnVisibleCellsChangeCallback(nextViewportRect);
	            }
	        };
	        _this.getMaxFrozenColumnIndex = function () {
	            var numFrozenColumns = _this.getNumFrozenColumnsClamped();
	            return (numFrozenColumns != null) ? numFrozenColumns - 1 : undefined;
	        };
	        _this.getMaxFrozenRowIndex = function () {
	            var numFrozenRows = _this.getNumFrozenRowsClamped();
	            return (numFrozenRows != null) ? numFrozenRows - 1 : undefined;
	        };
	        _this.handleColumnResizeGuide = function (verticalGuides) {
	            _this.setState({ verticalGuides: verticalGuides });
	        };
	        _this.handleRowResizeGuide = function (horizontalGuides) {
	            _this.setState({ horizontalGuides: horizontalGuides });
	        };
	        _this.setBodyRef = function (ref) { return _this.bodyElement = ref; };
	        _this.setRootTableRef = function (ref) { return _this.rootTableElement = ref; };
	        var _a = _this.props, children = _a.children, columnWidths = _a.columnWidths, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth, numRows = _a.numRows, rowHeights = _a.rowHeights;
	        _this.childrenArray = React.Children.toArray(children);
	        _this.columnIdToIndex = Table_1.createColumnIdIndex(_this.childrenArray);
	        // Create height/width arrays using the lengths from props and
	        // children, the default values from props, and finally any sparse
	        // arrays passed into props.
	        var newColumnWidths = _this.childrenArray.map(function () { return defaultColumnWidth; });
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
	        var newRowHeights = utils_1.Utils.times(numRows, function () { return defaultRowHeight; });
	        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
	        var selectedRegions = (props.selectedRegions == null) ? [] : props.selectedRegions;
	        var focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocus, props.focusedCell, undefined, selectedRegions);
	        _this.state = {
	            columnWidths: newColumnWidths,
	            focusedCell: focusedCell,
	            isLayoutLocked: false,
	            isReordering: false,
	            rowHeights: newRowHeights,
	            selectedRegions: selectedRegions,
	        };
	        return _this;
	    }
	    Table.createColumnIdIndex = function (children) {
	        var columnIdToIndex = {};
	        for (var i = 0; i < children.length; i++) {
	            var key = children[i].props.id;
	            if (key != null) {
	                columnIdToIndex[String(key)] = i;
	            }
	        }
	        return columnIdToIndex;
	    };
	    // Instance methods
	    // ================
	    /**
	     * Resize all rows in the table to the height of the tallest visible cell in the specified columns.
	     * If no indices are provided, default to using the tallest visible cell from all columns in view.
	     */
	    Table.prototype.resizeRowsByTallestCell = function (columnIndices) {
	        var _this = this;
	        var tallest = 0;
	        if (columnIndices == null) {
	            // Consider all columns currently in viewport
	            var viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);
	            for (var col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {
	                tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));
	            }
	        }
	        else {
	            var columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];
	            var tallestByColumns = columnIndicesArray.map(function (col) { return _this.locator.getTallestVisibleCellInColumn(col); });
	            tallest = Math.max.apply(Math, tallestByColumns);
	        }
	        var rowHeights = Array(this.state.rowHeights.length).fill(tallest);
	        this.invalidateGrid();
	        this.setState({ rowHeights: rowHeights });
	    };
	    /**
	     * Scrolls the table to the target region in a fashion appropriate to the target region's
	     * cardinality:
	     *
	     * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.
	     * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.
	     * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.
	     * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.
	     *
	     * If there are active frozen rows and/or columns, the target region will be positioned in the
	     * top-left corner of the non-frozen area (unless the target region itself is in the frozen
	     * area).
	     *
	     * If the target region is close to the bottom-right corner of the table, this function will
	     * simply scroll the target region as close to the top-left as possible until the bottom-right
	     * corner is reached.
	     */
	    Table.prototype.scrollToRegion = function (region) {
	        var _a = this.state.viewportRect, currScrollLeft = _a.left, currScrollTop = _a.top;
	        var numFrozenRows = this.getNumFrozenRowsClamped();
	        var numFrozenColumns = this.getNumFrozenColumnsClamped();
	        var _b = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns), scrollLeft = _b.scrollLeft, scrollTop = _b.scrollTop;
	        var correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;
	        var correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop;
	        // defer to the quadrant stack to keep all quadrant positions in sync
	        this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);
	    };
	    // React lifecycle
	    // ===============
	    Table.prototype.shouldComponentUpdate = function (nextProps, nextState) {
	        var propKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST };
	        var stateKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST };
	        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, propKeysBlacklist)
	            || !utils_1.Utils.shallowCompareKeys(this.state, nextState, stateKeysBlacklist)
	            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST)
	            || !utils_1.Utils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST);
	    };
	    Table.prototype.componentWillReceiveProps = function (nextProps) {
	        var _this = this;
	        var children = nextProps.children, columnWidths = nextProps.columnWidths, defaultColumnWidth = nextProps.defaultColumnWidth, defaultRowHeight = nextProps.defaultRowHeight, enableFocus = nextProps.enableFocus, focusedCell = nextProps.focusedCell, numRows = nextProps.numRows, rowHeights = nextProps.rowHeights, selectedRegions = nextProps.selectedRegions, selectionModes = nextProps.selectionModes;
	        var newChildArray = React.Children.toArray(children);
	        var numCols = newChildArray.length;
	        // Try to maintain widths of columns by looking up the width of the
	        // column that had the same `ID` prop. If none is found, use the
	        // previous width at the same index.
	        var previousColumnWidths = newChildArray.map(function (child, index) {
	            var mappedIndex = _this.columnIdToIndex[child.props.id];
	            return _this.state.columnWidths[mappedIndex != null ? mappedIndex : index];
	        });
	        // Make sure the width/height arrays have the correct length, but keep
	        // as many existing widths/heights when possible. Also, apply the
	        // sparse width/heights from props.
	        var newColumnWidths = this.state.columnWidths;
	        newColumnWidths = utils_1.Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, previousColumnWidths);
	        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
	        var newRowHeights = this.state.rowHeights;
	        newRowHeights = utils_1.Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);
	        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
	        var newSelectedRegions = selectedRegions;
	        if (selectedRegions == null) {
	            // if we're in uncontrolled mode, filter out all selected regions that don't
	            // fit in the current new table dimensions
	            newSelectedRegions = this.state.selectedRegions.filter(function (region) {
	                var regionCardinality = regions_2.Regions.getRegionCardinality(region);
	                var isSelectionModeEnabled = selectionModes.indexOf(regionCardinality) >= 0;
	                return isSelectionModeEnabled && regions_2.Regions.isRegionValidForTable(region, numRows, numCols);
	            });
	        }
	        var newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocus, focusedCell, this.state.focusedCell, newSelectedRegions);
	        this.childrenArray = newChildArray;
	        this.columnIdToIndex = Table_1.createColumnIdIndex(this.childrenArray);
	        this.invalidateGrid();
	        this.setState({
	            columnWidths: newColumnWidths,
	            focusedCell: newFocusedCell,
	            rowHeights: newRowHeights,
	            selectedRegions: newSelectedRegions,
	        });
	    };
	    Table.prototype.render = function () {
	        var _a = this.props, className = _a.className, isRowHeaderShown = _a.isRowHeaderShown;
	        var _b = this.state, horizontalGuides = _b.horizontalGuides, verticalGuides = _b.verticalGuides;
	        this.validateGrid();
	        var classes = classNames(Classes.TABLE_CONTAINER, (_c = {},
	            _c[Classes.TABLE_REORDERING] = this.state.isReordering,
	            _c[Classes.TABLE_NO_VERTICAL_SCROLL] = this.shouldDisableVerticalScroll(),
	            _c[Classes.TABLE_NO_HORIZONTAL_SCROLL] = this.shouldDisableHorizontalScroll(),
	            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.CELLS),
	            _c), className);
	        return (React.createElement("div", { className: classes, ref: this.setRootTableRef, onScroll: this.handleRootScroll },
	            React.createElement(tableQuadrantStack_1.TableQuadrantStack, { bodyRef: this.setBodyRef, columnHeaderRef: this.refHandlers.columnHeader, grid: this.grid, handleColumnResizeGuide: this.handleColumnResizeGuide, handleColumnsReordering: this.handleColumnsReordering, handleRowResizeGuide: this.handleRowResizeGuide, handleRowsReordering: this.handleRowsReordering, isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(), isRowHeaderShown: isRowHeaderShown, isVerticalScrollDisabled: this.shouldDisableVerticalScroll(), numFrozenColumns: this.getNumFrozenColumnsClamped(), numFrozenRows: this.getNumFrozenRowsClamped(), onScroll: this.handleBodyScroll, quadrantRef: this.refHandlers.mainQuadrant, ref: this.refHandlers.quadrantStack, renderBody: this.renderBody, renderColumnHeader: this.renderColumnHeader, renderMenu: this.renderMenu, renderRowHeader: this.renderRowHeader, rowHeaderRef: this.refHandlers.rowHeader, scrollContainerRef: this.refHandlers.scrollContainer }),
	            React.createElement("div", { className: classNames(Classes.TABLE_OVERLAY_LAYER, "bp-table-reordering-cursor-overlay") }),
	            React.createElement(guides_1.GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides })));
	        var _c;
	    };
	    Table.prototype.renderHotkeys = function () {
	        var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys()];
	        return (React.createElement(core_2.Hotkeys, null, hotkeys.filter(function (element) { return element !== undefined; })));
	    };
	    /**
	     * When the component mounts, the HTML Element refs will be available, so
	     * we constructor the Locator, which queries the elements' bounding
	     * ClientRects.
	     */
	    Table.prototype.componentDidMount = function () {
	        var _this = this;
	        this.validateGrid();
	        this.locator = new locator_1.Locator(this.mainQuadrantElement, this.scrollContainerElement);
	        this.updateLocator();
	        this.updateViewportRect(this.locator.getViewportRect());
	        this.resizeSensorDetach = resizeSensor_1.ResizeSensor.attach(this.rootTableElement, function () {
	            if (!_this.state.isLayoutLocked) {
	                _this.updateViewportRect(_this.locator.getViewportRect());
	            }
	        });
	    };
	    Table.prototype.componentWillUnmount = function () {
	        if (this.resizeSensorDetach != null) {
	            this.resizeSensorDetach();
	            delete this.resizeSensorDetach;
	        }
	    };
	    Table.prototype.componentDidUpdate = function () {
	        if (this.locator != null) {
	            this.validateGrid();
	            this.updateLocator();
	        }
	        this.maybeScrollTableIntoView();
	    };
	    Table.prototype.validateProps = function (props) {
	        var children = props.children, numFrozenColumns = props.numFrozenColumns, numFrozenRows = props.numFrozenRows, numRows = props.numRows;
	        var numColumns = React.Children.count(children);
	        React.Children.forEach(children, function (child) {
	            // save as a variable so that union type narrowing works
	            var childType = child.type;
	            if (typeof childType === "string") {
	                console.warn(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);
	            }
	            else {
	                var isColumn = childType.prototype === column_1.Column.prototype || column_1.Column.prototype.isPrototypeOf(childType);
	                if (!isColumn) {
	                    console.warn(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);
	                }
	            }
	        });
	        if (numFrozenColumns != null && (numFrozenColumns < 0 || numFrozenColumns > numColumns)) {
	            console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);
	        }
	        if (numFrozenRows != null && (numFrozenRows < 0 || (numRows != null && numFrozenRows > numRows))) {
	            console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);
	        }
	    };
	    // Quadrant refs
	    // =============
	    Table.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {
	        var grid = this.grid;
	        var selectedRegions = this.state.selectedRegions;
	        var primaryAxisPlural = primaryAxis === "row" ? "rows" : "cols";
	        var secondaryAxisPlural = secondaryAxis === "row" ? "rows" : "cols";
	        var movementDirection = isUpOrLeft ? -1 : +1;
	        var regionIntervalIndex = isUpOrLeft ? 1 : 0;
	        // try moving the cell in the direction along the primary axis
	        newFocusedCell[primaryAxis] += movementDirection;
	        var isPrimaryIndexOutOfBounds = isUpOrLeft
	            ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0]
	            : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];
	        if (isPrimaryIndexOutOfBounds) {
	            // if we moved outside the bounds of selection region,
	            // move to the start (or end) of the primary axis, and move one along the secondary
	            newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];
	            newFocusedCell[secondaryAxis] += movementDirection;
	            var isSecondaryIndexOutOfBounds = isUpOrLeft
	                ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0]
	                : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];
	            if (isSecondaryIndexOutOfBounds) {
	                // if moving along the secondary also moves us outside
	                // go to the start (or end) of the next (or previous region)
	                // (note that if there's only one region you'll be moving to the opposite corner, which is fine)
	                var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection;
	                // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around
	                if (isUpOrLeft
	                    ? newFocusCellSelectionIndex < 0
	                    : newFocusCellSelectionIndex >= selectedRegions.length) {
	                    newFocusCellSelectionIndex = isUpOrLeft
	                        ? selectedRegions.length - 1
	                        : 0;
	                }
	                var newFocusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], grid.numRows, grid.numCols);
	                newFocusedCell = {
	                    col: newFocusCellRegion.cols[regionIntervalIndex],
	                    focusSelectionIndex: newFocusCellSelectionIndex,
	                    row: newFocusCellRegion.rows[regionIntervalIndex],
	                };
	            }
	        }
	        return newFocusedCell;
	    };
	    Table.prototype.shouldDisableVerticalScroll = function () {
	        var fillBodyWithGhostCells = this.props.fillBodyWithGhostCells;
	        var viewportRect = this.state.viewportRect;
	        var rowIndices = this.grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        var isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;
	        var areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS);
	        var areGhostRowsVisible = fillBodyWithGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);
	        return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);
	    };
	    Table.prototype.shouldDisableHorizontalScroll = function () {
	        var fillBodyWithGhostCells = this.props.fillBodyWithGhostCells;
	        var viewportRect = this.state.viewportRect;
	        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
	        var isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;
	        var areGhostColumnsVisible = fillBodyWithGhostCells && this.grid.isGhostIndex(0, columnIndices.columnIndexEnd);
	        var areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS);
	        return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);
	    };
	    Table.prototype.maybeScrollTableIntoView = function () {
	        var viewportRect = this.state.viewportRect;
	        var tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);
	        var tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);
	        var nextScrollTop = (tableBottom < viewportRect.top + viewportRect.height)
	            ? Math.max(0, tableBottom - viewportRect.height)
	            : viewportRect.top;
	        var nextScrollLeft = (tableRight < viewportRect.left + viewportRect.width)
	            ? Math.max(0, tableRight - viewportRect.width)
	            : viewportRect.left;
	        this.syncViewportPosition(nextScrollLeft, nextScrollTop);
	    };
	    Table.prototype.getColumnProps = function (columnIndex) {
	        var column = this.childrenArray[columnIndex];
	        return column.props;
	    };
	    Table.prototype.isGuidesShowing = function () {
	        return this.state.verticalGuides != null || this.state.horizontalGuides != null;
	    };
	    Table.prototype.isSelectionModeEnabled = function (selectionMode) {
	        return this.props.selectionModes.indexOf(selectionMode) >= 0;
	    };
	    Table.prototype.getEnabledSelectionHandler = function (selectionMode) {
	        if (!this.isSelectionModeEnabled(selectionMode)) {
	            // If the selection mode isn't enabled, return a callback that
	            // will clear the selection. For example, if row selection is
	            // disabled, clicking on the row header will clear the table's
	            // selection. If all selection modes are enabled, clicking on the
	            // same region twice will clear the selection.
	            return this.clearSelection;
	        }
	        else {
	            return this.handleSelection;
	        }
	    };
	    Table.prototype.invalidateGrid = function () {
	        this.grid = null;
	    };
	    Table.prototype.validateGrid = function () {
	        if (this.grid == null) {
	            var _a = this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth;
	            var _b = this.state, rowHeights = _b.rowHeights, columnWidths = _b.columnWidths;
	            this.grid = new grid_1.Grid(rowHeights, columnWidths, grid_1.Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);
	            this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);
	        }
	    };
	    /**
	     * Renders a `RegionLayer`, applying styles to the regions using the
	     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so
	     * the `IRegionStyler` should be a new instance on every render if we
	     * intend to redraw the region layer.
	     */
	    Table.prototype.maybeRenderRegions = function (getRegionStyle, quadrantType) {
	        if (this.isGuidesShowing() && !this.state.isReordering) {
	            // we want to show guides *and* the selection styles when reordering rows or columns
	            return undefined;
	        }
	        var regionGroups = regions_2.Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);
	        return regionGroups.map(function (regionGroup, index) {
	            var regionStyles = regionGroup.regions.map(function (region) { return getRegionStyle(region, quadrantType); });
	            return (React.createElement(regions_1.RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, regionStyles: regionStyles }));
	        });
	    };
	    Table.prototype.maybeRenderCopyHotkey = function () {
	        var getCellClipboardData = this.props.getCellClipboardData;
	        if (getCellClipboardData != null) {
	            return (React.createElement(core_2.Hotkey, { key: "copy-hotkey", label: "Copy selected table cells", group: "Table", combo: "mod+c", onKeyDown: this.handleCopy }));
	        }
	        else {
	            return undefined;
	        }
	    };
	    Table.prototype.maybeRenderFocusHotkeys = function () {
	        var enableFocus = this.props.enableFocus;
	        if (enableFocus != null) {
	            return [
	                React.createElement(core_2.Hotkey, { key: "move left", label: "Move focus cell left", group: "Table", combo: "left", onKeyDown: this.handleFocusMoveLeft }),
	                React.createElement(core_2.Hotkey, { key: "move right", label: "Move focus cell right", group: "Table", combo: "right", onKeyDown: this.handleFocusMoveRight }),
	                React.createElement(core_2.Hotkey, { key: "move up", label: "Move focus cell up", group: "Table", combo: "up", onKeyDown: this.handleFocusMoveUp }),
	                React.createElement(core_2.Hotkey, { key: "move down", label: "Move focus cell down", group: "Table", combo: "down", onKeyDown: this.handleFocusMoveDown }),
	                React.createElement(core_2.Hotkey, { key: "move tab", label: "Move focus cell tab", group: "Table", combo: "tab", onKeyDown: this.handleFocusMoveRightInternal }),
	                React.createElement(core_2.Hotkey, { key: "move shift-tab", label: "Move focus cell shift tab", group: "Table", combo: "shift+tab", onKeyDown: this.handleFocusMoveLeftInternal }),
	                React.createElement(core_2.Hotkey, { key: "move enter", label: "Move focus cell enter", group: "Table", combo: "enter", onKeyDown: this.handleFocusMoveDownInternal }),
	                React.createElement(core_2.Hotkey, { key: "move shift-enter", label: "Move focus cell shift enter", group: "Table", combo: "shift+enter", onKeyDown: this.handleFocusMoveUpInternal }),
	            ];
	        }
	        else {
	            return [];
	        }
	    };
	    Table.prototype.maybeRenderSelectAllHotkey = function () {
	        if (this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE)) {
	            return (React.createElement(core_2.Hotkey, { key: "select-all-hotkey", label: "Select all", group: "Table", combo: "mod+a", onKeyDown: this.handleSelectAllHotkey }));
	        }
	        else {
	            return undefined;
	        }
	    };
	    Table.prototype.syncViewportPosition = function (nextScrollLeft, nextScrollTop) {
	        var viewportRect = this.state.viewportRect;
	        var didScrollTopChange = nextScrollTop !== viewportRect.top;
	        var didScrollLeftChange = nextScrollLeft !== viewportRect.left;
	        if (didScrollTopChange || didScrollLeftChange) {
	            // we need to modify the scroll container explicitly for the viewport to shift. in so
	            // doing, we add the size of the header elements, which are not technically part of the
	            // "grid" concept (the grid only consists of body cells at present).
	            if (didScrollTopChange) {
	                var topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;
	                this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;
	            }
	            if (didScrollLeftChange) {
	                var leftCorrection = this.shouldDisableHorizontalScroll() ? 0 : this.rowHeaderElement.clientWidth;
	                this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;
	            }
	            var nextViewportRect = new rect_1.Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);
	            this.updateViewportRect(nextViewportRect);
	        }
	    };
	    Table.prototype.updateLocator = function () {
	        var rowHeaderWidth = this.rowHeaderElement == null ? 0 : this.rowHeaderElement.getBoundingClientRect().width;
	        var columnHeaderHeight = this.columnHeaderElement == null ? 0 : this.columnHeaderElement.getBoundingClientRect().height;
	        this.locator.setGrid(this.grid)
	            .setNumFrozenRows(this.getNumFrozenRowsClamped())
	            .setNumFrozenColumns(this.getNumFrozenColumnsClamped())
	            .setRowHeaderWidth(rowHeaderWidth)
	            .setColumnHeaderHeight(columnHeaderHeight);
	    };
	    Table.prototype.invokeOnVisibleCellsChangeCallback = function (viewportRect) {
	        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect);
	        var rowIndices = this.grid.getRowIndicesInRect(viewportRect);
	        core_1.Utils.safeInvoke(this.props.onVisibleCellsChange, rowIndices, columnIndices);
	    };
	    Table.prototype.getNumFrozenColumnsClamped = function (props) {
	        if (props === void 0) { props = this.props; }
	        var numFrozenColumns = props.numFrozenColumns;
	        var numColumns = React.Children.count(props.children);
	        return utils_1.Utils.clamp(numFrozenColumns, 0, numColumns);
	    };
	    Table.prototype.getNumFrozenRowsClamped = function (props) {
	        if (props === void 0) { props = this.props; }
	        var numFrozenRows = props.numFrozenRows, numRows = props.numRows;
	        return utils_1.Utils.clamp(numFrozenRows, 0, numRows);
	    };
	    return Table;
	}(core_1.AbstractComponent));
	Table.defaultProps = {
	    allowMultipleSelection: true,
	    defaultColumnWidth: 150,
	    defaultRowHeight: 20,
	    enableFocus: false,
	    fillBodyWithGhostCells: false,
	    isRowHeaderShown: true,
	    loadingOptions: [],
	    minColumnWidth: 50,
	    minRowHeight: 20,
	    numRows: 0,
	    renderMode: renderMode_1.RenderMode.BATCH,
	    renderRowHeader: rowHeader_1.renderDefaultRowHeader,
	    selectionModes: regions_2.SelectionModes.ALL,
	};
	Table.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [
	    "selectedRegions",
	];
	Table.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST = [
	    "selectedRegions",
	    "viewportRect",
	];
	Table = Table_1 = tslib_1.__decorate([
	    core_2.HotkeysTarget
	], Table);
	exports.Table = Table;
	var Table_1;
	
	//# sourceMappingURL=table.js.map


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var regions_1 = __webpack_require__(24);
	function getScrollPositionForRegion(region, currScrollLeft, currScrollTop, getLeftOffset, getTopOffset, numFrozenRows, numFrozenColumns) {
	    if (numFrozenRows === void 0) { numFrozenRows = 0; }
	    if (numFrozenColumns === void 0) { numFrozenColumns = 0; }
	    var cardinality = regions_1.Regions.getRegionCardinality(region);
	    var scrollTop = currScrollTop;
	    var scrollLeft = currScrollLeft;
	    // if these were max-frozen-index values, we would have added 1 before passing to the get*Offset
	    // functions, but the counts are already 1-indexed, so we can just pass those.
	    var frozenColumnsCumulativeWidth = getLeftOffset(numFrozenColumns);
	    var frozenRowsCumulativeHeight = getTopOffset(numFrozenRows);
	    switch (cardinality) {
	        case regions_1.RegionCardinality.CELLS: {
	            // scroll to the top-left corner of the block of cells
	            var topOffset = getTopOffset(region.rows[0]);
	            var leftOffset = getLeftOffset(region.cols[0]);
	            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);
	            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);
	            break;
	        }
	        case regions_1.RegionCardinality.FULL_ROWS: {
	            // scroll to the top of the row block
	            var topOffset = getTopOffset(region.rows[0]);
	            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);
	            break;
	        }
	        case regions_1.RegionCardinality.FULL_COLUMNS: {
	            // scroll to the left side of the column block
	            var leftOffset = getLeftOffset(region.cols[0]);
	            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);
	            break;
	        }
	        default: {
	            // if it's a FULL_TABLE region, scroll back to the top-left cell of the table
	            scrollTop = 0;
	            scrollLeft = 0;
	            break;
	        }
	    }
	    return { scrollLeft: scrollLeft, scrollTop: scrollTop };
	}
	exports.getScrollPositionForRegion = getScrollPositionForRegion;
	/**
	 * Adjust the scroll position to align content just beyond the frozen region, if necessary.
	 */
	function getClampedScrollPosition(scrollOffset, frozenRegionCumulativeSize) {
	    // if the new scroll offset falls within the frozen region, clamp it to 0
	    return Math.max(scrollOffset - frozenRegionCumulativeSize, 0);
	}
	
	//# sourceMappingURL=scrollUtils.js.map


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var index_1 = __webpack_require__(21);
	var resizeHandle_1 = __webpack_require__(31);
	var regions_1 = __webpack_require__(24);
	var columnHeaderCell_1 = __webpack_require__(35);
	var header_1 = __webpack_require__(42);
	var ColumnHeader = (function (_super) {
	    tslib_1.__extends(ColumnHeader, _super);
	    function ColumnHeader() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.wrapCells = function (cells) {
	            var _a = _this.props, columnIndexStart = _a.columnIndexStart, grid = _a.grid;
	            var tableWidth = grid.getRect().width;
	            var scrollLeftCorrection = _this.props.grid.getCumulativeWidthBefore(columnIndexStart);
	            var style = {
	                // only header cells in view will render, but we need to reposition them to stay in view
	                // as we scroll horizontally.
	                transform: "translateX(" + (scrollLeftCorrection || 0) + "px)",
	                // reduce the width to clamp the sliding window as we approach the final headers; otherwise,
	                // we'll have tons of useless whitespace at the end.
	                width: tableWidth - scrollLeftCorrection,
	            };
	            var classes = classNames(Classes.TABLE_THEAD, Classes.TABLE_COLUMN_HEADER_TR);
	            // add a wrapper set to the full-table width to ensure container styles stretch from the first
	            // cell all the way to the last
	            return (React.createElement("div", { style: { width: tableWidth } },
	                React.createElement("div", { style: style, className: classes }, cells)));
	        };
	        _this.convertPointToColumn = function (clientXOrY, useMidpoint) {
	            var locator = _this.props.locator;
	            return locator != null ? locator.convertPointToColumn(clientXOrY, useMidpoint) : null;
	        };
	        _this.getCellExtremaClasses = function (index, indexEnd) {
	            return _this.props.grid.getExtremaClasses(0, index, 1, indexEnd);
	        };
	        _this.getColumnWidth = function (index) {
	            return _this.props.grid.getColumnRect(index).width;
	        };
	        _this.getDragCoordinate = function (clientCoords) {
	            return clientCoords[0]; // x-coordinate
	        };
	        _this.getMouseCoordinate = function (event) {
	            return event.clientX;
	        };
	        _this.handleResizeEnd = function (index, size) {
	            _this.props.onResizeGuide(null);
	            _this.props.onColumnWidthChanged(index, size);
	        };
	        _this.handleResizeDoubleClick = function (index) {
	            var _a = _this.props, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth;
	            var width = _this.props.locator.getWidestVisibleCellInColumn(index);
	            var clampedWidth = index_1.Utils.clamp(width, minColumnWidth, maxColumnWidth);
	            _this.props.onResizeGuide(null);
	            _this.props.onColumnWidthChanged(index, clampedWidth);
	        };
	        _this.handleSizeChanged = function (index, size) {
	            var rect = _this.props.grid.getColumnRect(index);
	            _this.props.onResizeGuide([rect.left + size]);
	        };
	        _this.isCellSelected = function (index) {
	            return regions_1.Regions.hasFullColumn(_this.props.selectedRegions, index);
	        };
	        _this.isGhostIndex = function (index) {
	            return _this.props.grid.isGhostIndex(-1, index);
	        };
	        _this.renderGhostCell = function (index, extremaClasses) {
	            var _a = _this.props, grid = _a.grid, loading = _a.loading;
	            var rect = grid.getGhostCellRect(0, index);
	            var style = {
	                flexBasis: rect.width + "px",
	                width: rect.width + "px",
	            };
	            return (React.createElement(columnHeaderCell_1.ColumnHeaderCell, { className: classNames(extremaClasses), index: index, key: Classes.columnIndexClass(index), loading: loading, style: style }));
	        };
	        _this.toRegion = function (index1, index2) {
	            return regions_1.Regions.column(index1, index2);
	        };
	        return _this;
	    }
	    ColumnHeader.prototype.render = function () {
	        var _a = this.props, 
	        // from IColumnHeaderProps
	        renderHeaderCell = _a.cellRenderer, onColumnWidthChanged = _a.onColumnWidthChanged, 
	        // from IColumnWidths
	        minSize = _a.minColumnWidth, maxSize = _a.maxColumnWidth, defaultColumnWidth = _a.defaultColumnWidth, 
	        // from IColumnIndices
	        indexStart = _a.columnIndexStart, indexEnd = _a.columnIndexEnd, 
	        // from IHeaderProps
	        spreadableProps = tslib_1.__rest(_a, ["cellRenderer", "onColumnWidthChanged", "minColumnWidth", "maxColumnWidth", "defaultColumnWidth", "columnIndexStart", "columnIndexEnd"]);
	        return (React.createElement(header_1.Header, tslib_1.__assign({ convertPointToIndex: this.convertPointToColumn, fullRegionCardinality: regions_1.RegionCardinality.FULL_COLUMNS, getCellExtremaClasses: this.getCellExtremaClasses, getCellIndexClass: Classes.columnCellIndexClass, getCellSize: this.getColumnWidth, getDragCoordinate: this.getDragCoordinate, getIndexClass: Classes.columnIndexClass, getMouseCoordinate: this.getMouseCoordinate, handleResizeDoubleClick: this.handleResizeDoubleClick, handleResizeEnd: this.handleResizeEnd, handleSizeChanged: this.handleSizeChanged, headerCellIsReorderablePropName: "isColumnReorderable", headerCellIsSelectedPropName: "isColumnSelected", indexEnd: indexEnd, indexStart: indexStart, isCellSelected: this.isCellSelected, isGhostIndex: this.isGhostIndex, maxSize: maxSize, minSize: minSize, renderGhostCell: this.renderGhostCell, renderHeaderCell: renderHeaderCell, resizeOrientation: resizeHandle_1.Orientation.VERTICAL, toRegion: this.toRegion, wrapCells: this.wrapCells }, spreadableProps)));
	    };
	    return ColumnHeader;
	}(React.Component));
	ColumnHeader.defaultProps = {
	    isReorderable: false,
	    isResizable: true,
	    loading: false,
	};
	exports.ColumnHeader = ColumnHeader;
	
	//# sourceMappingURL=columnHeader.js.map


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var batcher_1 = __webpack_require__(43);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var reorderable_1 = __webpack_require__(45);
	var resizable_1 = __webpack_require__(46);
	var selectable_1 = __webpack_require__(32);
	var regions_1 = __webpack_require__(24);
	var SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [
	    "focusedCell",
	    "selectedRegions",
	];
	var RESET_CELL_KEYS_BLACKLIST = [
	    "indexEnd",
	    "indexStart",
	];
	var Header = (function (_super) {
	    tslib_1.__extends(Header, _super);
	    function Header(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.state = {
	            hasSelectionEnded: false,
	        };
	        _this.batcher = new batcher_1.Batcher();
	        _this.locateClick = function (event) {
	            var coord = _this.props.getMouseCoordinate(event);
	            _this.activationIndex = _this.props.convertPointToIndex(coord);
	            return _this.props.toRegion(_this.activationIndex);
	        };
	        _this.locateDragForSelection = function (_event, coords, returnEndOnly) {
	            if (returnEndOnly === void 0) { returnEndOnly = false; }
	            var coord = _this.props.getDragCoordinate(coords.current);
	            var indexStart = _this.activationIndex;
	            var indexEnd = _this.props.convertPointToIndex(coord);
	            return returnEndOnly
	                ? _this.props.toRegion(indexEnd)
	                : _this.props.toRegion(indexStart, indexEnd);
	        };
	        _this.locateDragForReordering = function (_event, coords) {
	            var coord = _this.props.getDragCoordinate(coords.current);
	            var guideIndex = _this.props.convertPointToIndex(coord, true);
	            return (guideIndex < 0) ? undefined : guideIndex;
	        };
	        _this.renderCells = function () {
	            var _a = _this.props, indexStart = _a.indexStart, indexEnd = _a.indexEnd;
	            _this.batcher.startNewBatch();
	            for (var index = indexStart; index <= indexEnd; index++) {
	                _this.batcher.addArgsToBatch(index);
	            }
	            _this.batcher.removeOldAddNew(_this.renderNewCell);
	            if (!_this.batcher.isDone()) {
	                _this.batcher.idleCallback(function () { return _this.forceUpdate(); });
	            }
	            return _this.batcher.getList();
	        };
	        _this.renderNewCell = function (index) {
	            var extremaClasses = _this.props.getCellExtremaClasses(index, _this.props.indexEnd);
	            var renderer = _this.props.isGhostIndex(index)
	                ? _this.props.renderGhostCell
	                : _this.renderCell;
	            return renderer(index, extremaClasses);
	        };
	        _this.renderCell = function (index, extremaClasses) {
	            var _a = _this.props, getIndexClass = _a.getIndexClass, selectedRegions = _a.selectedRegions;
	            var cell = _this.props.renderHeaderCell(index);
	            var isLoading = cell.props.loading != null ? cell.props.loading : _this.props.loading;
	            var isSelected = _this.props.isCellSelected(index);
	            var isEntireCellTargetReorderable = _this.isEntireCellTargetReorderable(isSelected);
	            var className = classNames(extremaClasses, (_b = {},
	                _b[Classes.TABLE_HEADER_REORDERABLE] = isEntireCellTargetReorderable,
	                _b), _this.props.getCellIndexClass(index), cell.props.className);
	            var cellProps = (_c = {
	                    className: className,
	                    index: index
	                },
	                _c[_this.props.headerCellIsSelectedPropName] = isSelected,
	                _c[_this.props.headerCellIsReorderablePropName] = isEntireCellTargetReorderable,
	                _c.loading = isLoading,
	                _c.reorderHandle = _this.maybeRenderReorderHandle(index),
	                _c);
	            var modifiedHandleSizeChanged = function (size) { return _this.props.handleSizeChanged(index, size); };
	            var modifiedHandleResizeEnd = function (size) { return _this.props.handleResizeEnd(index, size); };
	            var modifiedHandleResizeHandleDoubleClick = function () { return _this.props.handleResizeDoubleClick(index); };
	            var baseChildren = (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: _this.props.allowMultipleSelection, disabled: isEntireCellTargetReorderable, focusedCell: _this.props.focusedCell, ignoredSelectors: ["." + Classes.TABLE_REORDER_HANDLE_TARGET], key: getIndexClass(index), locateClick: _this.locateClick, locateDrag: _this.locateDragForSelection, onFocus: _this.props.onFocus, onSelection: _this.handleDragSelectableSelection, onSelectionEnd: _this.handleDragSelectableSelectionEnd, selectedRegions: selectedRegions, selectedRegionTransform: _this.props.selectedRegionTransform },
	                React.createElement(resizable_1.Resizable, { isResizable: _this.props.isResizable, maxSize: _this.props.maxSize, minSize: _this.props.minSize, onDoubleClick: modifiedHandleResizeHandleDoubleClick, onLayoutLock: _this.props.onLayoutLock, onResizeEnd: modifiedHandleResizeEnd, onSizeChanged: modifiedHandleSizeChanged, orientation: _this.props.resizeOrientation, size: _this.props.getCellSize(index) }, React.cloneElement(cell, cellProps))));
	            return _this.isReorderHandleEnabled()
	                ? baseChildren // reordering will be handled by interacting with the reorder handle
	                : _this.wrapInDragReorderable(index, baseChildren, !isEntireCellTargetReorderable);
	            var _b, _c;
	        };
	        _this.handleDragSelectableSelection = function (selectedRegions) {
	            _this.props.onSelection(selectedRegions);
	            _this.setState({ hasSelectionEnded: false });
	        };
	        _this.handleDragSelectableSelectionEnd = function () {
	            _this.activationIndex = null; // not strictly required, but good practice
	            _this.setState({ hasSelectionEnded: true });
	        };
	        _this.isEntireCellTargetReorderable = function (isSelected) {
	            var selectedRegions = _this.props.selectedRegions;
	            // although reordering may be generally enabled for this row/column (via props.isReorderable), the
	            // row/column shouldn't actually become reorderable from a user perspective until a few other
	            // conditions are true:
	            return _this.props.isReorderable
	                && isSelected
	                && _this.state.hasSelectionEnded
	                && regions_1.Regions.getRegionCardinality(selectedRegions[0]) === _this.props.fullRegionCardinality
	                && selectedRegions.length === 1
	                && !_this.isReorderHandleEnabled();
	        };
	        return _this;
	    }
	    Header.prototype.componentDidMount = function () {
	        if (this.props.selectedRegions != null && this.props.selectedRegions.length > 0) {
	            // we already have a selection defined, so we'll want to enable reordering interactions
	            // right away if other criteria are satisfied too.
	            this.setState({ hasSelectionEnded: true });
	        }
	    };
	    Header.prototype.componentWillUnmount = function () {
	        this.batcher.cancelOutstandingCallback();
	    };
	    Header.prototype.componentWillReceiveProps = function (nextProps) {
	        if (nextProps.selectedRegions != null && nextProps.selectedRegions.length > 0) {
	            this.setState({ hasSelectionEnded: true });
	        }
	        else {
	            this.setState({ hasSelectionEnded: false });
	        }
	    };
	    Header.prototype.shouldComponentUpdate = function (nextProps, nextState) {
	        return !utils_1.Utils.shallowCompareKeys(this.state, nextState)
	            || !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: SHALLOW_COMPARE_PROP_KEYS_BLACKLIST })
	            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, SHALLOW_COMPARE_PROP_KEYS_BLACKLIST);
	    };
	    Header.prototype.componentWillUpdate = function (nextProps, nextState) {
	        var resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };
	        var shouldResetBatcher = !utils_1.Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);
	        shouldResetBatcher = shouldResetBatcher || !utils_1.Utils.shallowCompareKeys(this.state, nextState);
	        if (shouldResetBatcher) {
	            this.batcher.reset();
	        }
	    };
	    Header.prototype.render = function () {
	        return this.props.wrapCells(this.renderCells());
	    };
	    Header.prototype.isReorderHandleEnabled = function () {
	        // the reorder handle can only appear in the column interaction bar
	        return this.isColumnHeader() && this.props.isReorderable;
	    };
	    Header.prototype.maybeRenderReorderHandle = function (index) {
	        return !this.isReorderHandleEnabled()
	            ? undefined
	            : this.wrapInDragReorderable(index, React.createElement("div", { className: Classes.TABLE_REORDER_HANDLE_TARGET },
	                React.createElement("div", { className: Classes.TABLE_REORDER_HANDLE },
	                    React.createElement("span", { className: classNames(core_1.Classes.ICON_STANDARD, core_1.IconClasses.DRAG_HANDLE_VERTICAL) }))));
	    };
	    Header.prototype.isColumnHeader = function () {
	        return this.props.fullRegionCardinality === regions_1.RegionCardinality.FULL_COLUMNS;
	    };
	    Header.prototype.wrapInDragReorderable = function (index, children, disabled) {
	        return (React.createElement(reorderable_1.DragReorderable, { disabled: disabled, key: this.props.getIndexClass(index), locateClick: this.locateClick, locateDrag: this.locateDragForReordering, onReordered: this.props.onReordered, onReordering: this.props.onReordering, onSelection: this.props.onSelection, onFocus: this.props.onFocus, selectedRegions: this.props.selectedRegions, toRegion: this.props.toRegion }, children));
	    };
	    return Header;
	}(React.Component));
	exports.Header = Header;
	
	//# sourceMappingURL=header.js.map


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(8);
	var requestIdleCallback_1 = __webpack_require__(44);
	/**
	 * This class helps batch updates to large lists.
	 *
	 * For example, if your React component has many children, updating them all at
	 * once may cause jank when reconciling the DOM. This class helps you update
	 * only a few children per frame.
	 *
	 * A typical usage would be:
	 *
	 * ```tsx
	 * public renderChildren = (allChildrenKeys: string[]) => {
	 *
	 *     batcher.startNewBatch();
	 *
	 *     allChildrenKeys.forEach((prop1: string, index: number) => {
	 *         batcher.addArgsToBatch(prop1, "prop2", index);
	 *     });
	 *
	 *     batcher.removeOldAddNew((prop1: string, prop2: string, other: number) => {
	 *         return <Child prop1={prop1} prop2={prop2} other={other} />;
	 *     });
	 *
	 *     if (!batcher.isDone()) {
	 *         batcher.idleCallback(this.forceUpdate());
	 *     }
	 *
	 *     const currentChildren = batcher.getList();
	 *     return currentChildren;
	 * }
	 *
	 * ```
	 */
	var Batcher = (function () {
	    function Batcher() {
	        var _this = this;
	        this.currentObjects = {};
	        this.oldObjects = {};
	        this.batchArgs = {};
	        this.done = true;
	        this.handleIdleCallback = function () {
	            var callback = _this.callback;
	            delete _this.callback;
	            core_1.Utils.safeInvoke(callback);
	        };
	        this.mapCurrentObjectKey = function (key) {
	            return _this.currentObjects[key];
	        };
	    }
	    /**
	     * Resets the "batch" and "current" sets. This essentially clears the cache
	     * and prevents accidental re-use of "current" objects.
	     */
	    Batcher.prototype.reset = function () {
	        this.batchArgs = {};
	        this.oldObjects = this.currentObjects;
	        this.currentObjects = {};
	    };
	    /**
	     * Starts a new "batch" argument set
	     */
	    Batcher.prototype.startNewBatch = function () {
	        this.batchArgs = {};
	    };
	    /**
	     * Stores the variadic arguments to be later batched together.
	     *
	     * The arguments must be simple stringifyable objects.
	     */
	    Batcher.prototype.addArgsToBatch = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        this.batchArgs[args.join(Batcher.ARG_DELIMITER)] = args;
	    };
	    /**
	     * Compares the set of "batch" arguments to the "current" set. Creates any
	     * new objects using the callback as a factory. Removes old objects.
	     *
	     * Arguments that are in the "current" set but were not part of the last
	     * "batch" set are considered candidates for removal. Similarly, Arguments
	     * that are part of the "batch" set but not the "current" set are candidates
	     * for addition.
	     *
	     * The number of objects added and removed may be limited with the
	     * `...Limit` parameters.
	     *
	     * Finally, the batcher determines if the batching is complete if the
	     * "current" arguments match the "batch" arguments.
	     */
	    Batcher.prototype.removeOldAddNew = function (callback, addNewLimit, removeOldLimit, updateLimit) {
	        var _this = this;
	        if (addNewLimit === void 0) { addNewLimit = Batcher.DEFAULT_ADD_LIMIT; }
	        if (removeOldLimit === void 0) { removeOldLimit = Batcher.DEFAULT_REMOVE_LIMIT; }
	        if (updateLimit === void 0) { updateLimit = Batcher.DEFAULT_UPDATE_LIMIT; }
	        // remove old
	        var keysToRemove = this.setKeysDifference(this.currentObjects, this.batchArgs, removeOldLimit);
	        keysToRemove.forEach(function (key) { return delete _this.currentObjects[key]; });
	        // remove ALL old objects not in batch
	        var keysToRemoveOld = this.setKeysDifference(this.oldObjects, this.batchArgs, -1);
	        keysToRemoveOld.forEach(function (key) { return delete _this.oldObjects[key]; });
	        // copy ALL old objects into current objects if not defined
	        var keysToShallowCopy = Object.keys(this.oldObjects);
	        keysToShallowCopy.forEach(function (key) {
	            if (_this.currentObjects[key] == null) {
	                _this.currentObjects[key] = _this.oldObjects[key];
	            }
	        });
	        // update old objects with factory
	        var keysToUpdate = this.setKeysIntersection(this.oldObjects, this.currentObjects, updateLimit);
	        keysToUpdate.forEach(function (key) {
	            delete _this.oldObjects[key];
	            _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]);
	        });
	        // add new objects with factory
	        var keysToAdd = this.setKeysDifference(this.batchArgs, this.currentObjects, addNewLimit);
	        keysToAdd.forEach(function (key) { return _this.currentObjects[key] = callback.apply(undefined, _this.batchArgs[key]); });
	        // set `done` to true of sets match exactly after add/remove and there
	        // are no "old objects" remaining
	        this.done = this.setHasSameKeys(this.batchArgs, this.currentObjects)
	            && Object.keys(this.oldObjects).length === 0;
	    };
	    /**
	     * Returns true of the "current" set matches the "batch" set.
	     */
	    Batcher.prototype.isDone = function () {
	        return this.done;
	    };
	    /**
	     * Returns all the objects in the "current" set.
	     */
	    Batcher.prototype.getList = function () {
	        return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey);
	    };
	    /**
	     * Registers a callback to be invoked on the next idle frame. If a callback
	     * has already been registered, we do not register a new one.
	     */
	    Batcher.prototype.idleCallback = function (callback) {
	        if (!this.callback) {
	            this.callback = callback;
	            requestIdleCallback_1.requestIdleCallback(this.handleIdleCallback);
	        }
	    };
	    Batcher.prototype.cancelOutstandingCallback = function () {
	        delete this.callback;
	    };
	    Batcher.prototype.setKeysDifference = function (a, b, limit) {
	        return this.setKeysOperation(a, b, "difference", limit);
	    };
	    Batcher.prototype.setKeysIntersection = function (a, b, limit) {
	        return this.setKeysOperation(a, b, "intersect", limit);
	    };
	    /**
	     * Compares the keys of A from B -- and performs an "intersection" or
	     * "difference" operation on the keys.
	     *
	     * Note that the order of operands A and B matters for the "difference"
	     * operation.
	     *
	     * Returns an array of at most `limit` keys.
	     */
	    Batcher.prototype.setKeysOperation = function (a, b, operation, limit) {
	        var result = [];
	        var aKeys = Object.keys(a);
	        for (var i = 0; i < aKeys.length && (limit < 0 || result.length < limit); i++) {
	            var key = aKeys[i];
	            if ((operation === "difference" && a[key] && !b[key]) ||
	                (operation === "intersect" && a[key] && b[key])) {
	                result.push(key);
	            }
	        }
	        return result;
	    };
	    /**
	     * Returns true of objects `a` and `b` have exactly the same keys.
	     */
	    Batcher.prototype.setHasSameKeys = function (a, b) {
	        var aKeys = Object.keys(a);
	        var bKeys = Object.keys(b);
	        if (aKeys.length !== bKeys.length) {
	            return false;
	        }
	        for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
	            var aKey = aKeys_1[_i];
	            if (b[aKey] === undefined) {
	                return false;
	            }
	        }
	        return true;
	    };
	    return Batcher;
	}());
	Batcher.DEFAULT_ADD_LIMIT = 20;
	Batcher.DEFAULT_UPDATE_LIMIT = 20;
	Batcher.DEFAULT_REMOVE_LIMIT = 20;
	Batcher.ARG_DELIMITER = "|";
	exports.Batcher = Batcher;
	
	//# sourceMappingURL=batcher.js.map


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Event name for `postMessage`
	 */
	var MESSAGE_EVENT_DATA = "blueprint-table-post-message";
	/**
	 * Object that holds state for managing idle callbacks
	 */
	var IDLE_STATE = {
	    callbacks: [],
	    triggered: false,
	};
	var handleIdle = function (event) {
	    if (event.source !== window || event.data !== MESSAGE_EVENT_DATA) {
	        return;
	    }
	    IDLE_STATE.triggered = false;
	    var callback = null;
	    if (IDLE_STATE.callbacks.length > 0) {
	        callback = IDLE_STATE.callbacks.shift();
	    }
	    if (IDLE_STATE.callbacks.length > 0) {
	        triggerIdleFrame();
	    }
	    // finally, invoke the callback. exceptions will be propagated
	    if (callback) {
	        callback();
	    }
	};
	// check for window since we might be in a headless server environment
	if (typeof window !== "undefined") {
	    if (window.addEventListener != null) {
	        window.addEventListener("message", handleIdle, false);
	    }
	}
	var triggerIdleFrame = function () {
	    if (IDLE_STATE.triggered) {
	        return;
	    }
	    IDLE_STATE.triggered = true;
	    /**
	     * This is the magic that will wait for the browser to be "idle" before
	     * invoking the callback.
	     *
	     * First, we use nested calls to `requestAnimationFrame` which will cause
	     * the inner callback to be invoked on the NEXT FRAME.
	     *
	     * Then, we call to `postMessage` to invoke the `handleIdle` method only
	     * once the current stack frame is empty.
	     *
	     * With this approach, the idle callback will be invoked at most once per
	     * frame and only after the stack frame is empty.
	     */
	    requestAnimationFrame(function () {
	        requestAnimationFrame(function () {
	            postMessage(MESSAGE_EVENT_DATA, "*");
	        });
	    });
	};
	/**
	 * Invokes the provided callback on the next available frame after the stack
	 * frame is empty.
	 *
	 * At most one callback per frame is invoked, and the callback may be delayed
	 * multiple frames until the page is idle.
	 *
	 * TODO: return a token from this method that allows you to cancel the callback
	 * (otherwise the callback list may increase without bound).
	 */
	exports.requestIdleCallback = function (callback) {
	    IDLE_STATE.callbacks.push(callback);
	    triggerIdleFrame();
	};
	
	//# sourceMappingURL=requestIdleCallback.js.map


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var utils_1 = __webpack_require__(7);
	var draggable_1 = __webpack_require__(16);
	var regions_1 = __webpack_require__(24);
	var DragReorderable = (function (_super) {
	    tslib_1.__extends(DragReorderable, _super);
	    function DragReorderable() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.handleActivate = function (event) {
	            if (!utils_1.Utils.isLeftClick(event) || _this.props.disabled) {
	                return false;
	            }
	            var region = _this.props.locateClick(event);
	            if (!regions_1.Regions.isValid(region)) {
	                return false;
	            }
	            var cardinality = regions_1.Regions.getRegionCardinality(region);
	            var isColumnHeader = cardinality === regions_1.RegionCardinality.FULL_COLUMNS;
	            var isRowHeader = cardinality === regions_1.RegionCardinality.FULL_ROWS;
	            if (!isColumnHeader && !isRowHeader) {
	                return false;
	            }
	            var selectedRegions = _this.props.selectedRegions;
	            var selectedRegionIndex = regions_1.Regions.findContainingRegion(selectedRegions, region);
	            if (selectedRegionIndex >= 0) {
	                var selectedRegion = selectedRegions[selectedRegionIndex];
	                if (regions_1.Regions.getRegionCardinality(selectedRegion) !== cardinality) {
	                    // ignore FULL_TABLE selections
	                    return false;
	                }
	                // cache for easy access later in the lifecycle
	                var selectedInterval = isRowHeader ? selectedRegion.rows : selectedRegion.cols;
	                _this.selectedRegionStartIndex = selectedInterval[0];
	                // add 1 because the selected interval is inclusive, which simple subtraction doesn't
	                // account for (e.g. in a FULL_COLUMNS range from 3 to 6, 6 - 3 = 3, but the selection
	                // actually includes four columns: 3, 4, 5, and 6)
	                _this.selectedRegionLength = selectedInterval[1] - selectedInterval[0] + 1;
	            }
	            else {
	                // select the new region to avoid complex and unintuitive UX w/r/t the existing selection
	                _this.maybeSelectRegion(region);
	                var regionRange = isRowHeader ? region.rows : region.cols;
	                _this.selectedRegionStartIndex = regionRange[0];
	                _this.selectedRegionLength = regionRange[1] - regionRange[0] + 1;
	            }
	            return true;
	        };
	        _this.handleDragMove = function (event, coords) {
	            var oldIndex = _this.selectedRegionStartIndex;
	            var guideIndex = _this.props.locateDrag(event, coords);
	            var length = _this.selectedRegionLength;
	            var reorderedIndex = utils_1.Utils.guideIndexToReorderedIndex(oldIndex, guideIndex, length);
	            _this.props.onReordering(oldIndex, reorderedIndex, length);
	        };
	        _this.handleDragEnd = function (event, coords) {
	            var oldIndex = _this.selectedRegionStartIndex;
	            var guideIndex = _this.props.locateDrag(event, coords);
	            var length = _this.selectedRegionLength;
	            var reorderedIndex = utils_1.Utils.guideIndexToReorderedIndex(oldIndex, guideIndex, length);
	            _this.props.onReordered(oldIndex, reorderedIndex, length);
	            // the newly reordered region becomes the only selection
	            var newRegion = _this.props.toRegion(reorderedIndex, reorderedIndex + length - 1);
	            _this.maybeSelectRegion(newRegion);
	            // resetting is not strictly required, but it's cleaner
	            _this.selectedRegionStartIndex = undefined;
	            _this.selectedRegionLength = undefined;
	        };
	        return _this;
	    }
	    DragReorderable.prototype.render = function () {
	        var draggableProps = this.getDraggableProps();
	        return (React.createElement(draggable_1.Draggable, tslib_1.__assign({}, draggableProps, { preventDefault: false }), this.props.children));
	    };
	    DragReorderable.prototype.getDraggableProps = function () {
	        return this.props.onReordered == null ? {} : {
	            onActivate: this.handleActivate,
	            onDragEnd: this.handleDragEnd,
	            onDragMove: this.handleDragMove,
	        };
	    };
	    DragReorderable.prototype.maybeSelectRegion = function (region) {
	        var nextSelectedRegions = [region];
	        if (!utils_1.Utils.deepCompareKeys(nextSelectedRegions, this.props.selectedRegions)) {
	            this.props.onSelection(nextSelectedRegions);
	            // move the focused cell into the newly selected region
	            this.props.onFocus(tslib_1.__assign({}, regions_1.Regions.getFocusCellCoordinatesFromRegion(region), { focusSelectionIndex: 0 }));
	        }
	    };
	    return DragReorderable;
	}(React.Component));
	DragReorderable.defaultProps = {
	    selectedRegions: [],
	};
	DragReorderable = tslib_1.__decorate([
	    PureRender
	], DragReorderable);
	exports.DragReorderable = DragReorderable;
	
	//# sourceMappingURL=reorderable.js.map


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	var index_1 = __webpack_require__(21);
	var resizeHandle_1 = __webpack_require__(31);
	var Resizable = (function (_super) {
	    tslib_1.__extends(Resizable, _super);
	    function Resizable(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.onResizeMove = function (_offset, delta) {
	            _this.offsetSize(delta);
	            if (_this.props.onSizeChanged != null) {
	                _this.props.onSizeChanged(_this.state.size);
	            }
	        };
	        _this.onResizeEnd = function (_offset) {
	            // reset "unclamped" size on end
	            _this.setState({ unclampedSize: _this.state.size });
	            if (_this.props.onResizeEnd != null) {
	                _this.props.onResizeEnd(_this.state.size);
	            }
	        };
	        var size = props.size;
	        _this.state = {
	            size: size,
	            unclampedSize: size,
	        };
	        return _this;
	    }
	    Resizable.prototype.componentWillReceiveProps = function (nextProps) {
	        var size = nextProps.size;
	        this.setState({
	            size: size,
	            unclampedSize: size,
	        });
	    };
	    Resizable.prototype.render = function () {
	        var child = React.Children.only(this.props.children);
	        var style = tslib_1.__assign({}, child.props.style, this.getStyle());
	        if (this.props.isResizable === false) {
	            return React.cloneElement(child, { style: style });
	        }
	        var resizeHandle = this.renderResizeHandle();
	        return React.cloneElement(child, { style: style, resizeHandle: resizeHandle });
	    };
	    Resizable.prototype.renderResizeHandle = function () {
	        var _a = this.props, onLayoutLock = _a.onLayoutLock, onDoubleClick = _a.onDoubleClick, orientation = _a.orientation;
	        return (React.createElement(resizeHandle_1.ResizeHandle, { key: "resize-handle", onDoubleClick: onDoubleClick, onLayoutLock: onLayoutLock, onResizeEnd: this.onResizeEnd, onResizeMove: this.onResizeMove, orientation: orientation }));
	    };
	    /**
	     * Returns the CSS style to apply to the child element given the state's
	     * size value.
	     */
	    Resizable.prototype.getStyle = function () {
	        if (this.props.orientation === resizeHandle_1.Orientation.VERTICAL) {
	            return {
	                flexBasis: this.state.size + "px",
	                minWidth: "0px",
	                width: this.state.size + "px",
	            };
	        }
	        else {
	            return {
	                flexBasis: this.state.size + "px",
	                height: this.state.size + "px",
	                minHeight: "0px",
	            };
	        }
	    };
	    Resizable.prototype.offsetSize = function (offset) {
	        var unclampedSize = this.state.unclampedSize + offset;
	        this.setState({
	            size: index_1.Utils.clamp(unclampedSize, this.props.minSize, this.props.maxSize),
	            unclampedSize: unclampedSize,
	        });
	    };
	    return Resizable;
	}(React.Component));
	Resizable.defaultProps = {
	    isResizable: true,
	    minSize: 0,
	};
	Resizable = tslib_1.__decorate([
	    PureRender
	], Resizable);
	exports.Resizable = Resizable;
	
	//# sourceMappingURL=resizable.js.map


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var resizeHandle_1 = __webpack_require__(31);
	var regions_1 = __webpack_require__(24);
	var header_1 = __webpack_require__(42);
	var rowHeaderCell_1 = __webpack_require__(37);
	var RowHeader = (function (_super) {
	    tslib_1.__extends(RowHeader, _super);
	    function RowHeader() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.defaultProps = {
	            renderRowHeader: renderDefaultRowHeader,
	        };
	        _this.wrapCells = function (cells) {
	            var _a = _this.props, rowIndexStart = _a.rowIndexStart, grid = _a.grid;
	            var tableHeight = grid.getRect().height;
	            var scrollTopCorrection = _this.props.grid.getCumulativeHeightBefore(rowIndexStart);
	            var style = {
	                // reduce the height to clamp the sliding window as we approach the final headers; otherwise,
	                // we'll have tons of useless whitespace at the end.
	                height: tableHeight - scrollTopCorrection,
	                // only header cells in view will render, but we need to reposition them to stay in view
	                // as we scroll vertically.
	                transform: "translateY(" + (scrollTopCorrection || 0) + "px)",
	            };
	            // add a wrapper set to the full-table height to ensure container styles stretch from the first
	            // cell all the way to the last
	            return (React.createElement("div", { style: { height: tableHeight } },
	                React.createElement("div", { className: Classes.TABLE_ROW_HEADERS_CELLS_CONTAINER, style: style }, cells)));
	        };
	        _this.convertPointToRow = function (clientXOrY, useMidpoint) {
	            var locator = _this.props.locator;
	            return locator != null ? locator.convertPointToRow(clientXOrY, useMidpoint) : null;
	        };
	        _this.getCellExtremaClasses = function (index, indexEnd) {
	            return _this.props.grid.getExtremaClasses(index, 0, indexEnd, 1);
	        };
	        _this.getRowHeight = function (index) {
	            return _this.props.grid.getRowRect(index).height;
	        };
	        _this.getDragCoordinate = function (clientCoords) {
	            return clientCoords[1]; // y-coordinate
	        };
	        _this.getMouseCoordinate = function (event) {
	            return event.clientY;
	        };
	        _this.handleResizeEnd = function (index, size) {
	            _this.props.onResizeGuide(null);
	            _this.props.onRowHeightChanged(index, size);
	        };
	        _this.handleSizeChanged = function (index, size) {
	            var rect = _this.props.grid.getRowRect(index);
	            _this.props.onResizeGuide([rect.top + size]);
	        };
	        _this.isCellSelected = function (index) {
	            return regions_1.Regions.hasFullRow(_this.props.selectedRegions, index);
	        };
	        _this.isGhostIndex = function (index) {
	            return _this.props.grid.isGhostIndex(index, -1);
	        };
	        _this.renderGhostCell = function (index, extremaClasses) {
	            var rect = _this.props.grid.getGhostCellRect(index, 0);
	            return (React.createElement(rowHeaderCell_1.RowHeaderCell, { className: classNames(extremaClasses), index: index, key: Classes.rowIndexClass(index), loading: _this.props.loading, style: { height: rect.height + "px" } }));
	        };
	        _this.toRegion = function (index1, index2) {
	            // the `this` value is messed up for Regions.row, so we have to have a wrapper function here
	            return regions_1.Regions.row(index1, index2);
	        };
	        return _this;
	    }
	    RowHeader.prototype.render = function () {
	        var _a = this.props, 
	        // from IRowHeaderProps
	        onRowHeightChanged = _a.onRowHeightChanged, renderHeaderCell = _a.renderRowHeader, 
	        // from IRowHeights
	        minSize = _a.minRowHeight, maxSize = _a.maxRowHeight, defaultRowHeight = _a.defaultRowHeight, 
	        // from IRowIndices
	        indexStart = _a.rowIndexStart, indexEnd = _a.rowIndexEnd, 
	        // from IHeaderProps
	        spreadableProps = tslib_1.__rest(_a, ["onRowHeightChanged", "renderRowHeader", "minRowHeight", "maxRowHeight", "defaultRowHeight", "rowIndexStart", "rowIndexEnd"]);
	        return (React.createElement(header_1.Header, tslib_1.__assign({ convertPointToIndex: this.convertPointToRow, fullRegionCardinality: regions_1.RegionCardinality.FULL_ROWS, getCellExtremaClasses: this.getCellExtremaClasses, getCellIndexClass: Classes.rowCellIndexClass, getCellSize: this.getRowHeight, getDragCoordinate: this.getDragCoordinate, getIndexClass: Classes.rowIndexClass, getMouseCoordinate: this.getMouseCoordinate, handleResizeEnd: this.handleResizeEnd, handleSizeChanged: this.handleSizeChanged, headerCellIsReorderablePropName: "isRowReorderable", headerCellIsSelectedPropName: "isRowSelected", indexEnd: indexEnd, indexStart: indexStart, isCellSelected: this.isCellSelected, isGhostIndex: this.isGhostIndex, maxSize: maxSize, minSize: minSize, renderGhostCell: this.renderGhostCell, renderHeaderCell: renderHeaderCell, resizeOrientation: resizeHandle_1.Orientation.HORIZONTAL, toRegion: this.toRegion, wrapCells: this.wrapCells }, spreadableProps)));
	    };
	    return RowHeader;
	}(React.Component));
	exports.RowHeader = RowHeader;
	/**
	 * A default implementation of `IRowHeaderRenderer` that displays 1-indexed
	 * numbers for each row.
	 */
	function renderDefaultRowHeader(rowIndex) {
	    return React.createElement(rowHeaderCell_1.RowHeaderCell, { index: rowIndex, name: "" + (rowIndex + 1) });
	}
	exports.renderDefaultRowHeader = renderDefaultRowHeader;
	
	//# sourceMappingURL=rowHeader.js.map


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(6);
	/**
	 * Efficiently detect when an HTMLElement is resized.
	 *
	 * Attaches an invisible "resize-sensor" div to the element. Then it checks
	 * the element's offsetWidth and offsetHeight whenever a scroll event is
	 * triggered on the "resize-sensor" children. These events are further
	 * debounced using requestAnimationFrame.
	 *
	 * Inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js
	 */
	var ResizeSensor = (function () {
	    function ResizeSensor() {
	    }
	    ResizeSensor.attach = function (element, callback) {
	        var lifecycle = ResizeSensor.debounce(callback);
	        var resizeSensor = document.createElement("div");
	        resizeSensor.className = Classes.TABLE_RESIZE_SENSOR;
	        resizeSensor.style.cssText = ResizeSensor.RESIZE_SENSOR_STYLE;
	        resizeSensor.innerHTML = ResizeSensor.RESIZE_SENSOR_HTML;
	        element.appendChild(resizeSensor);
	        if (getComputedStyle(element, null).getPropertyValue("position") === "static") {
	            element.style.position = "relative";
	        }
	        var expand = resizeSensor.childNodes[0];
	        var expandChild = expand.childNodes[0];
	        var shrink = resizeSensor.childNodes[1];
	        var reset = function () {
	            expandChild.style.width = "100000px";
	            expandChild.style.height = "100000px";
	            expand.scrollLeft = 100000;
	            expand.scrollTop = 100000;
	            shrink.scrollLeft = 100000;
	            shrink.scrollTop = 100000;
	        };
	        reset();
	        var lastWidth;
	        var lastHeight;
	        var onScroll = function () {
	            var currentWidth = element.offsetWidth;
	            var currentHeight = element.offsetHeight;
	            if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
	                lastWidth = currentWidth;
	                lastHeight = currentHeight;
	                lifecycle.trigger();
	            }
	            reset();
	        };
	        expand.addEventListener("scroll", onScroll);
	        shrink.addEventListener("scroll", onScroll);
	        return function () {
	            element.removeChild(resizeSensor);
	            lifecycle.cancelled = true;
	        };
	    };
	    ResizeSensor.debounce = function (callback) {
	        var scope = {
	            cancelled: false,
	            trigger: function () {
	                if (scope.triggered || scope.cancelled) {
	                    return;
	                }
	                scope.triggered = true;
	                requestAnimationFrame(function () {
	                    scope.triggered = false;
	                    if (!scope.cancelled) {
	                        callback();
	                    }
	                });
	            },
	            triggered: false,
	        };
	        return scope;
	    };
	    return ResizeSensor;
	}());
	ResizeSensor.RESIZE_SENSOR_STYLE = "position: absolute; left: 0; top: 0; right: 0; " +
	    "bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;";
	ResizeSensor.RESIZE_SENSOR_HTML = "<div class=\"" + Classes.TABLE_RESIZE_SENSOR_EXPAND + "\"\n        style=\"" + ResizeSensor.RESIZE_SENSOR_STYLE + "\"><div style=\"position: absolute; left: 0; top: 0; transition: 0s;\"\n        ></div></div><div class=\"" + Classes.TABLE_RESIZE_SENSOR_SHRINK + "\" style=\"" + ResizeSensor.RESIZE_SENSOR_STYLE + "\"\n        ><div style=\"position: absolute; left: 0; top: 0; transition: 0s; width: 200%; height: 200%;\"></div></div>";
	exports.ResizeSensor = ResizeSensor;
	
	//# sourceMappingURL=resizeSensor.js.map


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var GuideLayer = (function (_super) {
	    tslib_1.__extends(GuideLayer, _super);
	    function GuideLayer() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderVerticalGuide = function (offset, index) {
	            var style = {
	                left: offset + "px",
	            };
	            var className = classNames(Classes.TABLE_OVERLAY, Classes.TABLE_VERTICAL_GUIDE, {
	                "bp-table-vertical-guide-flush-left": offset === 0,
	            });
	            return (React.createElement("div", { className: className, key: index, style: style }));
	        };
	        _this.renderHorizontalGuide = function (offset, index) {
	            var style = {
	                top: offset + "px",
	            };
	            var className = classNames(Classes.TABLE_OVERLAY, Classes.TABLE_HORIZONTAL_GUIDE, {
	                "bp-table-horizontal-guide-flush-top": offset === 0,
	            });
	            return (React.createElement("div", { className: className, key: index, style: style }));
	        };
	        return _this;
	    }
	    GuideLayer.prototype.shouldComponentUpdate = function (nextProps) {
	        if (this.props.className !== nextProps.className) {
	            return true;
	        }
	        // shallow-comparing guide arrays leads to tons of unnecessary re-renders, so we check the
	        // array contents explicitly.
	        return !utils_1.Utils.arraysEqual(this.props.verticalGuides, nextProps.verticalGuides)
	            || !utils_1.Utils.arraysEqual(this.props.horizontalGuides, nextProps.horizontalGuides);
	    };
	    GuideLayer.prototype.render = function () {
	        var _a = this.props, verticalGuides = _a.verticalGuides, horizontalGuides = _a.horizontalGuides, className = _a.className;
	        var verticals = (verticalGuides == null) ? undefined : verticalGuides.map(this.renderVerticalGuide);
	        var horizontals = (horizontalGuides == null) ? undefined : horizontalGuides.map(this.renderHorizontalGuide);
	        return (React.createElement("div", { className: classNames(className, Classes.TABLE_OVERLAY_LAYER) },
	            verticals,
	            horizontals));
	    };
	    return GuideLayer;
	}(React.Component));
	exports.GuideLayer = GuideLayer;
	
	//# sourceMappingURL=guides.js.map


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var regions_1 = __webpack_require__(24);
	// don't include "regions" or "regionStyles" in here, because they can't be shallowly compared
	var UPDATE_PROPS_KEYS = [
	    "className",
	];
	var RegionLayer = (function (_super) {
	    tslib_1.__extends(RegionLayer, _super);
	    function RegionLayer() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.renderRegion = function (_region, index) {
	            var _a = _this.props, className = _a.className, regionStyles = _a.regionStyles;
	            return (React.createElement("div", { className: classNames(Classes.TABLE_OVERLAY, Classes.TABLE_REGION, className), key: index, style: regionStyles[index] }));
	        };
	        return _this;
	    }
	    RegionLayer.prototype.shouldComponentUpdate = function (nextProps) {
	        // shallowly comparable props like "className" tend not to change in the default table
	        // implementation, so do that check last with hope that we return earlier and avoid it
	        // altogether.
	        return !utils_1.Utils.arraysEqual(this.props.regions, nextProps.regions, regions_1.Regions.regionsEqual)
	            || !utils_1.Utils.arraysEqual(this.props.regionStyles, nextProps.regionStyles, utils_1.Utils.shallowCompareKeys)
	            || !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { include: UPDATE_PROPS_KEYS });
	    };
	    RegionLayer.prototype.render = function () {
	        return React.createElement("div", { className: Classes.TABLE_OVERLAY_LAYER }, this.renderRegionChildren());
	    };
	    RegionLayer.prototype.renderRegionChildren = function () {
	        var regions = this.props.regions;
	        if (regions == null) {
	            return undefined;
	        }
	        return regions.map(this.renderRegion);
	    };
	    return RegionLayer;
	}(React.Component));
	exports.RegionLayer = RegionLayer;
	
	//# sourceMappingURL=regions.js.map


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var Classes = __webpack_require__(6);
	var rect_1 = __webpack_require__(25);
	var utils_1 = __webpack_require__(7);
	var Locator = (function () {
	    function Locator(tableElement, bodyElement) {
	        var _this = this;
	        this.tableElement = tableElement;
	        this.bodyElement = bodyElement;
	        this.rowHeaderWidth = 0;
	        this.columnHeaderHeight = 0;
	        this.numFrozenRows = 0;
	        this.numFrozenColumns = 0;
	        this.convertCellIndexToClientX = function (index) {
	            return _this.grid.getCumulativeWidthAt(index);
	        };
	        this.convertCellMidpointToClientX = function (index) {
	            var cellLeft = _this.grid.getCumulativeWidthBefore(index);
	            var cellRight = _this.grid.getCumulativeWidthAt(index);
	            return (cellLeft + cellRight) / 2;
	        };
	        this.convertCellIndexToClientY = function (index) {
	            return _this.grid.getCumulativeHeightAt(index);
	        };
	        this.convertCellMidpointToClientY = function (index) {
	            var cellTop = _this.grid.getCumulativeHeightBefore(index);
	            var cellBottom = _this.grid.getCumulativeHeightAt(index);
	            return (cellTop + cellBottom) / 2;
	        };
	        this.toGridX = function (clientX) {
	            var tableOffsetFromPageLeft = _this.tableElement.getBoundingClientRect().left;
	            var cursorOffsetFromTableLeft = clientX - tableOffsetFromPageLeft;
	            var cursorOffsetFromGridLeft = cursorOffsetFromTableLeft - _this.rowHeaderWidth;
	            var scrollOffsetFromTableLeft = _this.bodyElement.scrollLeft;
	            var isCursorWithinFrozenColumns = _this.numFrozenColumns != null
	                && _this.numFrozenColumns > 0
	                && cursorOffsetFromGridLeft <= _this.grid.getCumulativeWidthBefore(_this.numFrozenColumns);
	            // the frozen-column region doesn't scroll, so ignore the scroll distance in that case
	            return isCursorWithinFrozenColumns
	                ? cursorOffsetFromGridLeft
	                : cursorOffsetFromGridLeft + scrollOffsetFromTableLeft;
	        };
	        this.toGridY = function (clientY) {
	            var tableOffsetFromPageTop = _this.tableElement.getBoundingClientRect().top;
	            var cursorOffsetFromTableTop = clientY - tableOffsetFromPageTop;
	            var cursorOffsetFromGridTop = cursorOffsetFromTableTop - _this.columnHeaderHeight;
	            var scrollOffsetFromTableTop = _this.bodyElement.scrollTop;
	            var isCursorWithinFrozenRows = _this.numFrozenRows != null
	                && _this.numFrozenRows > 0
	                && cursorOffsetFromGridTop <= _this.grid.getCumulativeHeightBefore(_this.numFrozenRows);
	            return isCursorWithinFrozenRows
	                ? cursorOffsetFromGridTop
	                : cursorOffsetFromGridTop + scrollOffsetFromTableTop;
	        };
	        // empty constructor
	    }
	    // Setters
	    // =======
	    Locator.prototype.setGrid = function (grid) {
	        this.grid = grid;
	        return this;
	    };
	    Locator.prototype.setNumFrozenRows = function (numFrozenRows) {
	        this.numFrozenRows = numFrozenRows;
	        return this;
	    };
	    Locator.prototype.setNumFrozenColumns = function (numFrozenColumns) {
	        this.numFrozenColumns = numFrozenColumns;
	        return this;
	    };
	    Locator.prototype.setColumnHeaderHeight = function (columnHeaderHeight) {
	        this.columnHeaderHeight = columnHeaderHeight;
	        return this;
	    };
	    Locator.prototype.setRowHeaderWidth = function (rowHeaderWidth) {
	        this.rowHeaderWidth = rowHeaderWidth;
	        return this;
	    };
	    // Getters
	    // =======
	    Locator.prototype.getViewportRect = function () {
	        return new rect_1.Rect(this.bodyElement.scrollLeft, this.bodyElement.scrollTop, this.bodyElement.clientWidth, this.bodyElement.clientHeight);
	    };
	    Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {
	        var cells = this.tableElement.getElementsByClassName(Classes.columnCellIndexClass(columnIndex));
	        var max = 0;
	        for (var i = 0; i < cells.length; i++) {
	            var contentWidth = utils_1.Utils.measureElementTextContent(cells.item(i)).width;
	            var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;
	            if (cellWidth > max) {
	                max = cellWidth;
	            }
	        }
	        return max;
	    };
	    Locator.prototype.getTallestVisibleCellInColumn = function (columnIndex) {
	        var cells = this.tableElement
	            .getElementsByClassName(Classes.columnCellIndexClass(columnIndex) + " " + Classes.TABLE_CELL);
	        var max = 0;
	        for (var i = 0; i < cells.length; i++) {
	            var cellValue = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_VALUE);
	            var cellTruncatedFormatText = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_FORMAT_TEXT);
	            var cellTruncatedText = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_TEXT);
	            var height = 0;
	            if (cellValue != null) {
	                height = cellValue.scrollHeight;
	            }
	            else if (cellTruncatedFormatText != null) {
	                height = cellTruncatedFormatText.scrollHeight;
	            }
	            else if (cellTruncatedText != null) {
	                height = cellTruncatedText.scrollHeight;
	            }
	            else {
	                // it's not anything we recognize, just use the current height of the cell
	                height = cells.item(i).scrollHeight;
	            }
	            if (height > max) {
	                max = height;
	            }
	        }
	        return max;
	    };
	    // Converters
	    // ==========
	    Locator.prototype.convertPointToColumn = function (clientX, useMidpoint) {
	        var tableRect = this.getTableRect();
	        if (!tableRect.containsX(clientX)) {
	            return -1;
	        }
	        var gridX = this.toGridX(clientX);
	        var limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;
	        var lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;
	        return utils_1.Utils.binarySearch(gridX, limit, lookupFn);
	    };
	    Locator.prototype.convertPointToRow = function (clientY, useMidpoint) {
	        var tableRect = this.getTableRect();
	        if (!tableRect.containsY(clientY)) {
	            return -1;
	        }
	        var gridY = this.toGridY(clientY);
	        var limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;
	        var lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;
	        return utils_1.Utils.binarySearch(gridY, limit, lookupFn);
	    };
	    Locator.prototype.convertPointToCell = function (clientX, clientY) {
	        var gridX = this.toGridX(clientX);
	        var gridY = this.toGridY(clientY);
	        var col = utils_1.Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);
	        var row = utils_1.Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);
	        return { col: col, row: row };
	    };
	    // Private helpers
	    // ===============
	    Locator.prototype.getTableRect = function () {
	        return rect_1.Rect.wrap(this.tableElement.getBoundingClientRect());
	    };
	    return Locator;
	}());
	Locator.CELL_HORIZONTAL_PADDING = 10;
	exports.Locator = Locator;
	
	//# sourceMappingURL=locator.js.map


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var Errors = __webpack_require__(34);
	var QuadrantType;
	(function (QuadrantType) {
	    /**
	     * The main quadrant beneath any frozen rows or columns.
	     */
	    QuadrantType[QuadrantType["MAIN"] = 0] = "MAIN";
	    /**
	     * The top quadrant, containing column headers and frozen rows.
	     */
	    QuadrantType[QuadrantType["TOP"] = 1] = "TOP";
	    /**
	     * The left quadrant, containing row headers and frozen columns.
	     */
	    QuadrantType[QuadrantType["LEFT"] = 2] = "LEFT";
	    /**
	     * The top-left quadrant, containing the headers and cells common to both the frozen columns and
	     * frozen rows.
	     */
	    QuadrantType[QuadrantType["TOP_LEFT"] = 3] = "TOP_LEFT";
	})(QuadrantType = exports.QuadrantType || (exports.QuadrantType = {}));
	var TableQuadrant = (function (_super) {
	    tslib_1.__extends(TableQuadrant, _super);
	    function TableQuadrant() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TableQuadrant.prototype.render = function () {
	        var _a = this.props, isRowHeaderShown = _a.isRowHeaderShown, quadrantType = _a.quadrantType;
	        var showFrozenRowsOnly = quadrantType === QuadrantType.TOP || quadrantType === QuadrantType.TOP_LEFT;
	        var showFrozenColumnsOnly = quadrantType === QuadrantType.LEFT || quadrantType === QuadrantType.TOP_LEFT;
	        var className = classNames(Classes.TABLE_QUADRANT, this.getQuadrantCssClass(), this.props.className);
	        var maybeMenu = isRowHeaderShown ? this.props.renderMenu() : undefined;
	        var maybeRowHeader = isRowHeaderShown ? this.props.renderRowHeader(showFrozenRowsOnly) : undefined;
	        var columnHeader = this.props.renderColumnHeader(showFrozenColumnsOnly);
	        // need to set bottom container size to prevent overlay clipping on scroll
	        var bottomContainerStyle = {
	            height: this.props.grid.getHeight(),
	            width: this.props.grid.getWidth(),
	        };
	        return (React.createElement("div", { className: className, style: this.props.style, ref: this.props.quadrantRef },
	            React.createElement("div", { className: Classes.TABLE_QUADRANT_SCROLL_CONTAINER, ref: this.props.scrollContainerRef, onScroll: this.props.onScroll, onWheel: this.props.onWheel },
	                React.createElement("div", { className: Classes.TABLE_TOP_CONTAINER },
	                    maybeMenu,
	                    columnHeader),
	                React.createElement("div", { className: Classes.TABLE_BOTTOM_CONTAINER, style: bottomContainerStyle },
	                    maybeRowHeader,
	                    React.createElement("div", { className: Classes.TABLE_QUADRANT_BODY_CONTAINER, ref: this.props.bodyRef }, this.props.renderBody(quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly))))));
	    };
	    TableQuadrant.prototype.validateProps = function (nextProps) {
	        var quadrantType = nextProps.quadrantType;
	        if (nextProps.onScroll != null && quadrantType !== QuadrantType.MAIN) {
	            console.warn(Errors.QUADRANT_ON_SCROLL_UNNECESSARILY_DEFINED);
	        }
	    };
	    TableQuadrant.prototype.getQuadrantCssClass = function () {
	        switch (this.props.quadrantType) {
	            case QuadrantType.MAIN:
	                return Classes.TABLE_QUADRANT_MAIN;
	            case QuadrantType.TOP:
	                return Classes.TABLE_QUADRANT_TOP;
	            case QuadrantType.LEFT:
	                return Classes.TABLE_QUADRANT_LEFT;
	            case QuadrantType.TOP_LEFT:
	                return Classes.TABLE_QUADRANT_TOP_LEFT;
	            default:
	                return undefined;
	        }
	    };
	    return TableQuadrant;
	}(core_1.AbstractComponent));
	// we want the user to explicitly pass a quadrantType. define defaultProps as a Partial to avoid
	// declaring that and other required props here.
	TableQuadrant.defaultProps = {
	    isRowHeaderShown: true,
	};
	exports.TableQuadrant = TableQuadrant;
	
	//# sourceMappingURL=tableQuadrant.js.map


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var React = __webpack_require__(5);
	var Classes = __webpack_require__(6);
	var utils_1 = __webpack_require__(7);
	var tableQuadrant_1 = __webpack_require__(52);
	var TableQuadrantStack = (function (_super) {
	    tslib_1.__extends(TableQuadrantStack, _super);
	    function TableQuadrantStack(props, context) {
	        var _this = _super.call(this, props, context) || this;
	        _this.quadrantRefs = (_a = {},
	            _a[tableQuadrant_1.QuadrantType.MAIN] = {},
	            _a[tableQuadrant_1.QuadrantType.TOP] = {},
	            _a[tableQuadrant_1.QuadrantType.LEFT] = {},
	            _a[tableQuadrant_1.QuadrantType.TOP_LEFT] = {},
	            _a);
	        _this.quadrantRefHandlers = (_b = {},
	            _b[tableQuadrant_1.QuadrantType.MAIN] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.MAIN),
	            _b[tableQuadrant_1.QuadrantType.TOP] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.TOP),
	            _b[tableQuadrant_1.QuadrantType.LEFT] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.LEFT),
	            _b[tableQuadrant_1.QuadrantType.TOP_LEFT] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.TOP_LEFT),
	            _b);
	        // this flag helps us avoid redundant work in the MAIN quadrant's onScroll callback, if the
	        // callback was triggered from a manual scrollTop/scrollLeft update within an onWheel.
	        _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
	        // Quadrant-specific renderers
	        // ===========================
	        // Menu
	        _this.renderMainQuadrantMenu = function () {
	            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].menu);
	        };
	        _this.renderTopQuadrantMenu = function () {
	            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].menu);
	        };
	        _this.renderLeftQuadrantMenu = function () {
	            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].menu);
	        };
	        _this.renderTopLeftQuadrantMenu = function () {
	            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].menu);
	        };
	        // Column header
	        _this.renderMainQuadrantColumnHeader = function (showFrozenColumnsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].columnHeader;
	            var resizeHandler = _this.handleColumnResizeGuideMain;
	            var reorderingHandler = _this.handleColumnsReorderingMain;
	            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
	        };
	        _this.renderTopQuadrantColumnHeader = function (showFrozenColumnsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].columnHeader;
	            var resizeHandler = _this.handleColumnResizeGuideTop;
	            var reorderingHandler = _this.handleColumnsReorderingTop;
	            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
	        };
	        _this.renderLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].columnHeader;
	            var resizeHandler = _this.handleColumnResizeGuideLeft;
	            var reorderingHandler = _this.handleColumnsReorderingLeft;
	            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
	        };
	        _this.renderTopLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].columnHeader;
	            var resizeHandler = _this.handleColumnResizeGuideTopLeft;
	            var reorderingHandler = _this.handleColumnsReorderingTopLeft;
	            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
	        };
	        // Row header
	        _this.renderMainQuadrantRowHeader = function (showFrozenRowsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].rowHeader;
	            var resizeHandler = _this.handleRowResizeGuideMain;
	            var reorderingHandler = _this.handleRowsReorderingMain;
	            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
	        };
	        _this.renderTopQuadrantRowHeader = function (showFrozenRowsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].rowHeader;
	            var resizeHandler = _this.handleRowResizeGuideTop;
	            var reorderingHandler = _this.handleRowsReorderingTop;
	            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
	        };
	        _this.renderLeftQuadrantRowHeader = function (showFrozenRowsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].rowHeader;
	            var resizeHandler = _this.handleRowResizeGuideLeft;
	            var reorderingHandler = _this.handleRowsReorderingLeft;
	            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
	        };
	        _this.renderTopLeftQuadrantRowHeader = function (showFrozenRowsOnly) {
	            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].rowHeader;
	            var resizeHandler = _this.handleRowResizeGuideTopLeft;
	            var reorderingHandler = _this.handleRowsReorderingTopLeft;
	            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
	        };
	        // Event handlers
	        // ==============
	        // Scrolling
	        // ---------
	        // use the more generic "scroll" event for the main quadrant, which captures both click+dragging
	        // on the scrollbar and trackpad/mousewheel gestures
	        _this.handleMainQuadrantScroll = function (event) {
	            if (_this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback) {
	                _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
	                return;
	            }
	            var nextScrollTop = _this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer.scrollTop;
	            var nextScrollLeft = _this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer.scrollLeft;
	            _this.quadrantRefs[tableQuadrant_1.QuadrantType.LEFT].scrollContainer.scrollTop = nextScrollTop;
	            _this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].scrollContainer.scrollLeft = nextScrollLeft;
	            _this.props.onScroll(event);
	        };
	        // recall that we've already invoked event.preventDefault() when defining the throttled versions
	        // of these onWheel callbacks, so now we need to manually update the affected quadrant's scroll
	        // position too.
	        _this.handleWheel = function (event) {
	            _this.handleDirectionalWheel("horizontal", event.deltaX, tableQuadrant_1.QuadrantType.MAIN, [tableQuadrant_1.QuadrantType.TOP]);
	            _this.handleDirectionalWheel("vertical", event.deltaY, tableQuadrant_1.QuadrantType.MAIN, [tableQuadrant_1.QuadrantType.LEFT]);
	            _this.props.onScroll(event);
	        };
	        // Resizing
	        // --------
	        // Columns
	        _this.handleColumnResizeGuideMain = function (verticalGuides) {
	            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.MAIN);
	        };
	        _this.handleColumnResizeGuideTop = function (verticalGuides) {
	            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP);
	        };
	        _this.handleColumnResizeGuideLeft = function (verticalGuides) {
	            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.LEFT);
	        };
	        _this.handleColumnResizeGuideTopLeft = function (verticalGuides) {
	            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP_LEFT);
	        };
	        _this.invokeColumnResizeHandler = function (verticalGuides, quadrantType) {
	            var adjustedGuides = _this.adjustVerticalGuides(verticalGuides, quadrantType);
	            _this.props.handleColumnResizeGuide(adjustedGuides);
	        };
	        // Rows
	        _this.handleRowResizeGuideMain = function (verticalGuides) {
	            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.MAIN);
	        };
	        _this.handleRowResizeGuideTop = function (verticalGuides) {
	            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP);
	        };
	        _this.handleRowResizeGuideLeft = function (verticalGuides) {
	            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.LEFT);
	        };
	        _this.handleRowResizeGuideTopLeft = function (verticalGuides) {
	            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP_LEFT);
	        };
	        _this.invokeRowResizeHandler = function (verticalGuides, quadrantType) {
	            var adjustedGuides = _this.adjustHorizontalGuides(verticalGuides, quadrantType);
	            _this.props.handleRowResizeGuide(adjustedGuides);
	        };
	        // Reordering
	        // ----------
	        // Columns
	        _this.handleColumnsReorderingMain = function (oldIndex, newIndex, length) {
	            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleColumnsReorderingTop = function (oldIndex, newIndex, length) {
	            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleColumnsReorderingLeft = function (oldIndex, newIndex, length) {
	            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleColumnsReorderingTopLeft = function (oldIndex, newIndex, length) {
	            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.invokeColumnsReorderingHandler = function (oldIndex, newIndex, length) {
	            var guideIndex = utils_1.Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);
	            var leftOffset = _this.props.grid.getCumulativeWidthBefore(guideIndex);
	            var quadrantType = guideIndex <= _this.props.numFrozenColumns ? tableQuadrant_1.QuadrantType.TOP_LEFT : tableQuadrant_1.QuadrantType.TOP;
	            var verticalGuides = _this.adjustVerticalGuides([leftOffset], quadrantType);
	            _this.props.handleColumnsReordering(verticalGuides);
	        };
	        // Rows
	        _this.handleRowsReorderingMain = function (oldIndex, newIndex, length) {
	            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleRowsReorderingTop = function (oldIndex, newIndex, length) {
	            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleRowsReorderingLeft = function (oldIndex, newIndex, length) {
	            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.handleRowsReorderingTopLeft = function (oldIndex, newIndex, length) {
	            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
	        };
	        _this.invokeRowsReorderingHandler = function (oldIndex, newIndex, length) {
	            var guideIndex = utils_1.Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);
	            var topOffset = _this.props.grid.getCumulativeHeightBefore(guideIndex);
	            var quadrantType = guideIndex <= _this.props.numFrozenRows ? tableQuadrant_1.QuadrantType.TOP_LEFT : tableQuadrant_1.QuadrantType.LEFT;
	            var horizontalGuides = _this.adjustHorizontalGuides([topOffset], quadrantType);
	            _this.props.handleRowsReordering(horizontalGuides);
	        };
	        _this.handleDirectionalWheel = function (direction, delta, quadrantType, quadrantTypesToSync) {
	            var isHorizontal = direction === "horizontal";
	            var scrollKey = isHorizontal
	                ? "scrollLeft"
	                : "scrollTop";
	            var isScrollDisabled = isHorizontal
	                ? _this.props.isHorizontalScrollDisabled
	                : _this.props.isVerticalScrollDisabled;
	            if (!isScrollDisabled) {
	                _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = true;
	                // sync the corresponding scroll position of all dependent quadrants
	                var nextScrollPosition_1 = _this.quadrantRefs[quadrantType].scrollContainer[scrollKey] + delta;
	                _this.quadrantRefs[quadrantType].scrollContainer[scrollKey] = nextScrollPosition_1;
	                quadrantTypesToSync.forEach(function (quadrantTypeToSync) {
	                    _this.quadrantRefs[quadrantTypeToSync].scrollContainer[scrollKey] = nextScrollPosition_1;
	                });
	            }
	        };
	        // a few points here:
	        // - we throttle onScroll/onWheel callbacks to making scrolling look more fluid.
	        // - we declare throttled functions on the component instance, since they're stateful.
	        // - "wheel"-ing triggers super-fluid onScroll behavior by default, but relying on that
	        //   causes sync'd quadrants to lag behind. thus, we preventDefault for onWheel and instead
	        //   manually update all relevant quadrants using event.delta{X,Y} later, in the callback.
	        //   this keeps every sync'd quadrant visually aligned in each animation frame.
	        _this.throttledHandleMainQuadrantScroll = core_1.Utils.throttleReactEventCallback(_this.handleMainQuadrantScroll);
	        _this.throttledHandleWheel = core_1.Utils.throttleReactEventCallback(_this.handleWheel, { preventDefault: true });
	        return _this;
	        var _a, _b;
	    }
	    /**
	     * Scroll the main quadrant to the specified scroll offset, keeping all other quadrants in sync.
	     */
	    TableQuadrantStack.prototype.scrollToPosition = function (scrollLeft, scrollTop) {
	        var scrollContainer = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer;
	        this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
	        // this will trigger the main quadrant's scroll callback below
	        scrollContainer.scrollLeft = scrollLeft;
	        scrollContainer.scrollTop = scrollTop;
	    };
	    TableQuadrantStack.prototype.componentDidMount = function () {
	        this.emitRefs();
	        this.syncQuadrantSizes();
	        this.syncQuadrantMenuElementWidths();
	        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.findColumnHeader(tableQuadrant_1.QuadrantType.MAIN));
	        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.findRowHeader(tableQuadrant_1.QuadrantType.MAIN));
	    };
	    TableQuadrantStack.prototype.componentDidUpdate = function () {
	        this.emitRefs();
	        this.syncQuadrantSizes();
	        this.syncQuadrantMenuElementWidths();
	        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.findColumnHeader(tableQuadrant_1.QuadrantType.MAIN));
	        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.findRowHeader(tableQuadrant_1.QuadrantType.MAIN));
	    };
	    TableQuadrantStack.prototype.render = function () {
	        var _a = this.props, grid = _a.grid, isRowHeaderShown = _a.isRowHeaderShown, renderBody = _a.renderBody;
	        return (React.createElement("div", { className: Classes.TABLE_QUADRANT_STACK },
	            React.createElement(tableQuadrant_1.TableQuadrant, { bodyRef: this.props.bodyRef, grid: grid, isRowHeaderShown: isRowHeaderShown, onScroll: this.throttledHandleMainQuadrantScroll, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].quadrant, quadrantType: tableQuadrant_1.QuadrantType.MAIN, renderBody: renderBody, renderColumnHeader: this.renderMainQuadrantColumnHeader, renderMenu: this.renderMainQuadrantMenu, renderRowHeader: this.renderMainQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].scrollContainer }),
	            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].quadrant, quadrantType: tableQuadrant_1.QuadrantType.TOP, renderBody: renderBody, renderColumnHeader: this.renderTopQuadrantColumnHeader, renderMenu: this.renderTopQuadrantMenu, renderRowHeader: this.renderTopQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].scrollContainer }),
	            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].quadrant, quadrantType: tableQuadrant_1.QuadrantType.LEFT, renderBody: renderBody, renderColumnHeader: this.renderLeftQuadrantColumnHeader, renderMenu: this.renderLeftQuadrantMenu, renderRowHeader: this.renderLeftQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].scrollContainer }),
	            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].quadrant, quadrantType: tableQuadrant_1.QuadrantType.TOP_LEFT, renderBody: renderBody, renderColumnHeader: this.renderTopLeftQuadrantColumnHeader, renderMenu: this.renderTopLeftQuadrantMenu, renderRowHeader: this.renderTopLeftQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].scrollContainer })));
	    };
	    // Ref handlers
	    // ============
	    TableQuadrantStack.prototype.generateQuadrantRefHandlers = function (quadrantType) {
	        var _this = this;
	        var reducer = function (agg, key) {
	            agg[key] = function (ref) { return _this.quadrantRefs[quadrantType][key] = ref; };
	            return agg;
	        };
	        return ["columnHeader", "menu", "quadrant", "rowHeader", "scrollContainer"].reduce(reducer, {});
	    };
	    // Emitters
	    // ========
	    TableQuadrantStack.prototype.emitRefs = function () {
	        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].columnHeader);
	        core_1.Utils.safeInvoke(this.props.quadrantRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].quadrant);
	        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].rowHeader);
	        core_1.Utils.safeInvoke(this.props.scrollContainerRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer);
	    };
	    // Size syncing
	    // ============
	    TableQuadrantStack.prototype.syncQuadrantMenuElementWidths = function () {
	        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.MAIN);
	        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.TOP);
	        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.LEFT);
	        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.TOP_LEFT);
	    };
	    TableQuadrantStack.prototype.syncQuadrantMenuElementWidth = function (quadrantType) {
	        var mainQuadrantMenu = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].menu;
	        var mainQuadrantRowHeader = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].rowHeader;
	        var quadrantMenu = this.quadrantRefs[quadrantType].menu;
	        // the main quadrant menu informs the size of every other quadrant menu
	        if (mainQuadrantMenu != null && mainQuadrantRowHeader != null && quadrantMenu != null) {
	            var width = mainQuadrantRowHeader.getBoundingClientRect().width;
	            quadrantMenu.style.width = width + "px";
	            // no need to use the main quadrant's menu to set its *own* height
	            if (quadrantType !== tableQuadrant_1.QuadrantType.MAIN) {
	                var height = mainQuadrantMenu.getBoundingClientRect().height;
	                quadrantMenu.style.height = height + "px";
	            }
	        }
	    };
	    TableQuadrantStack.prototype.syncQuadrantSizes = function () {
	        var mainQuadrantScrollElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer;
	        var topQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].quadrant;
	        var topQuadrantRowHeaderElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].rowHeader;
	        var leftQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.LEFT].quadrant;
	        var topLeftQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP_LEFT].quadrant;
	        var topLeftQuadrantRowHeaderElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP_LEFT].rowHeader;
	        var _a = this.props, grid = _a.grid, numFrozenColumns = _a.numFrozenColumns, numFrozenRows = _a.numFrozenRows;
	        // if there are no frozen rows or columns, we still want the quadrant to be 1px bigger to
	        // reveal the header border.
	        var BORDER_WIDTH_CORRECTION = 1;
	        var leftQuadrantGridContentWidth = numFrozenColumns > 0
	            ? grid.getCumulativeWidthAt(numFrozenColumns - 1)
	            : BORDER_WIDTH_CORRECTION;
	        var topQuadrantGridContentHeight = numFrozenRows > 0
	            ? grid.getCumulativeHeightAt(numFrozenRows - 1)
	            : BORDER_WIDTH_CORRECTION;
	        // all menus are the same size, so arbitrarily use the one from the main quadrant.
	        // assumes that the menu element width has already been sync'd after the last render
	        var _b = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN], rowHeader = _b.rowHeader, columnHeader = _b.columnHeader;
	        var rowHeaderWidth = rowHeader == null ? 0 : rowHeader.getBoundingClientRect().width;
	        var columnHeaderHeight = columnHeader == null ? 0 : columnHeader.getBoundingClientRect().height;
	        // no need to sync the main quadrant, because it fills the entire viewport
	        topQuadrantElement.style.height = topQuadrantGridContentHeight + columnHeaderHeight + "px";
	        leftQuadrantElement.style.width = leftQuadrantGridContentWidth + rowHeaderWidth + "px";
	        topLeftQuadrantElement.style.width = leftQuadrantGridContentWidth + rowHeaderWidth + "px";
	        topLeftQuadrantElement.style.height = topQuadrantGridContentHeight + columnHeaderHeight + "px";
	        // resize the top and left quadrants to keep the main quadrant's scrollbar visible
	        var scrollbarWidth = mainQuadrantScrollElement.offsetWidth - mainQuadrantScrollElement.clientWidth;
	        var scrollbarHeight = mainQuadrantScrollElement.offsetHeight - mainQuadrantScrollElement.clientHeight;
	        topQuadrantElement.style.right = scrollbarWidth + "px";
	        leftQuadrantElement.style.bottom = scrollbarHeight + "px";
	        // resize top and top-left quadrant row headers if main quadrant scrolls
	        this.maybeSyncRowHeaderSize(topQuadrantRowHeaderElement, rowHeaderWidth);
	        this.maybeSyncRowHeaderSize(topLeftQuadrantRowHeaderElement, rowHeaderWidth);
	    };
	    TableQuadrantStack.prototype.maybeSyncRowHeaderSize = function (rowHeaderElement, width) {
	        if (rowHeaderElement == null) {
	            return;
	        }
	        var selector = "." + Classes.TABLE_ROW_HEADERS_CELLS_CONTAINER;
	        // this child element dictates the width of all row-header cells
	        var elementToResize = rowHeaderElement.querySelector(selector);
	        elementToResize.style.width = width + "px";
	    };
	    // Helpers
	    // =======
	    TableQuadrantStack.prototype.findColumnHeader = function (quadrantType) {
	        var quadrantElement = this.quadrantRefs[quadrantType].quadrant;
	        return quadrantElement.querySelector("." + Classes.TABLE_COLUMN_HEADERS);
	    };
	    TableQuadrantStack.prototype.findRowHeader = function (quadrantType) {
	        var quadrantElement = this.quadrantRefs[quadrantType].quadrant;
	        return quadrantElement.querySelector("." + Classes.TABLE_ROW_HEADERS);
	    };
	    // Resizing
	    TableQuadrantStack.prototype.adjustVerticalGuides = function (verticalGuides, quadrantType) {
	        var scrollAmount = this.quadrantRefs[quadrantType].scrollContainer.scrollLeft;
	        var rowHeaderWidth = this.getRowHeaderWidth(quadrantType);
	        var adjustedVerticalGuides = verticalGuides != null
	            ? verticalGuides.map(function (verticalGuide) { return verticalGuide - scrollAmount + rowHeaderWidth; })
	            : verticalGuides;
	        return adjustedVerticalGuides;
	    };
	    TableQuadrantStack.prototype.adjustHorizontalGuides = function (horizontalGuides, quadrantType) {
	        var scrollAmount = this.quadrantRefs[quadrantType].scrollContainer.scrollTop;
	        var columnHeaderHeight = this.quadrantRefs[quadrantType].columnHeader.clientHeight;
	        var adjustedHorizontalGuides = horizontalGuides != null
	            ? horizontalGuides.map(function (horizontalGuide) { return horizontalGuide - scrollAmount + columnHeaderHeight; })
	            : horizontalGuides;
	        return adjustedHorizontalGuides;
	    };
	    TableQuadrantStack.prototype.getRowHeaderWidth = function (quadrantType) {
	        // unlike the column header, the row header can be toggled, so we need to handle the case
	        // when it's not showing
	        var rowHeader = this.quadrantRefs[quadrantType].rowHeader;
	        return rowHeader == null ? 0 : rowHeader.clientWidth;
	    };
	    return TableQuadrantStack;
	}(core_1.AbstractComponent));
	// we want the user to explicitly pass a quadrantType. define defaultProps as a Partial to avoid
	// declaring that and other required props here.
	TableQuadrantStack.defaultProps = {
	    isHorizontalScrollDisabled: false,
	    isRowHeaderShown: true,
	    isVerticalScrollDisabled: false,
	};
	exports.TableQuadrantStack = TableQuadrantStack;
	
	//# sourceMappingURL=tableQuadrantStack.js.map


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var classNames = __webpack_require__(4);
	var React = __webpack_require__(5);
	var cell_1 = __webpack_require__(2);
	var batcher_1 = __webpack_require__(43);
	var Classes = __webpack_require__(6);
	var contextMenuTargetWrapper_1 = __webpack_require__(55);
	var rect_1 = __webpack_require__(25);
	var renderMode_1 = __webpack_require__(26);
	var utils_1 = __webpack_require__(7);
	var menus_1 = __webpack_require__(28);
	var selectable_1 = __webpack_require__(32);
	var regions_1 = __webpack_require__(24);
	/**
	 * For perf, we want to ignore changes to the `ISelectableProps` part of the
	 * `ITableBodyProps` since those are only used when a context menu is launched.
	 */
	var UPDATE_PROPS_KEYS = [
	    "focusedCell",
	    "grid",
	    "locator",
	    "viewportRect",
	    "cellRenderer",
	    "rowIndexStart",
	    "rowIndexEnd",
	    "columnIndexStart",
	    "columnIndexEnd",
	    "selectedRegions",
	];
	/**
	 * We don't want to reset the batcher when this set of keys changes. Any other
	 * changes should reset the batcher's internal cache.
	 */
	var RESET_CELL_KEYS_BLACKLIST = [
	    "columnIndexEnd",
	    "columnIndexStart",
	    "rowIndexEnd",
	    "rowIndexStart",
	    "viewportRect",
	];
	var TableBody = (function (_super) {
	    tslib_1.__extends(TableBody, _super);
	    function TableBody() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.batcher = new batcher_1.Batcher();
	        _this.isRenderingBatchedCells = false;
	        _this.renderContextMenu = function (e) {
	            var _a = _this.props, grid = _a.grid, onFocus = _a.onFocus, onSelection = _a.onSelection, renderBodyContextMenu = _a.renderBodyContextMenu, selectedRegions = _a.selectedRegions;
	            var numRows = grid.numRows, numCols = grid.numCols;
	            if (renderBodyContextMenu == null) {
	                return undefined;
	            }
	            var targetRegion = _this.locateClick(e.nativeEvent);
	            var nextSelectedRegions = selectedRegions;
	            // if the event did not happen within a selected region, clear all
	            // selections and select the right-clicked cell.
	            var foundIndex = regions_1.Regions.findContainingRegion(selectedRegions, targetRegion);
	            if (foundIndex < 0) {
	                nextSelectedRegions = [targetRegion];
	                onSelection(nextSelectedRegions);
	                // move the focused cell to the new region.
	                var nextFocusedCell = tslib_1.__assign({}, regions_1.Regions.getFocusCellCoordinatesFromRegion(targetRegion), { focusSelectionIndex: 0 });
	                onFocus(nextFocusedCell);
	            }
	            var menuContext = new menus_1.MenuContext(targetRegion, nextSelectedRegions, numRows, numCols);
	            var contextMenu = renderBodyContextMenu(menuContext);
	            return contextMenu == null ? undefined : contextMenu;
	        };
	        // Cell renderers
	        // ==============
	        _this.renderNewCell = function (row, col) {
	            var _a = _this.props, columnIndexEnd = _a.columnIndexEnd, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd;
	            var extremaClasses = grid.getExtremaClasses(row, col, rowIndexEnd, columnIndexEnd);
	            var isGhost = grid.isGhostIndex(row, col);
	            return _this.renderCell(row, col, extremaClasses, isGhost);
	        };
	        _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {
	            var _a = _this.props, cellRenderer = _a.cellRenderer, loading = _a.loading, grid = _a.grid;
	            var baseCell = isGhost ? cell_1.emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);
	            var className = classNames(TableBody.cellClassNames(rowIndex, columnIndex), extremaClasses, (_b = {},
	                _b[Classes.TABLE_CELL_GHOST] = isGhost,
	                _b[Classes.TABLE_CELL_LEDGER_ODD] = (rowIndex % 2) === 1,
	                _b[Classes.TABLE_CELL_LEDGER_EVEN] = (rowIndex % 2) === 0,
	                _b), baseCell.props.className);
	            var key = TableBody.cellReactKey(rowIndex, columnIndex);
	            var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);
	            var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;
	            var style = tslib_1.__assign({}, baseCell.props.style, rect_1.Rect.style(rect));
	            return React.cloneElement(baseCell, { className: className, key: key, loading: cellLoading, style: style });
	            var _b;
	        };
	        // Callbacks
	        // =========
	        _this.handleSelectionEnd = function () {
	            _this.activationCell = null; // not strictly required, but good practice
	        };
	        _this.locateClick = function (event) {
	            _this.activationCell = _this.props.locator.convertPointToCell(event.clientX, event.clientY);
	            return regions_1.Regions.cell(_this.activationCell.row, _this.activationCell.col);
	        };
	        _this.locateDrag = function (_event, coords, returnEndOnly) {
	            if (returnEndOnly === void 0) { returnEndOnly = false; }
	            var start = _this.activationCell;
	            var end = _this.props.locator.convertPointToCell(coords.current[0], coords.current[1]);
	            return returnEndOnly
	                ? regions_1.Regions.cell(end.row, end.col)
	                : regions_1.Regions.cell(start.row, start.col, end.row, end.col);
	        };
	        return _this;
	    }
	    /**
	     * Returns the array of class names that must be applied to each table
	     * cell so that we can locate any cell based on its coordinate.
	     */
	    TableBody.cellClassNames = function (rowIndex, columnIndex) {
	        return [
	            Classes.rowCellIndexClass(rowIndex),
	            Classes.columnCellIndexClass(columnIndex),
	        ];
	    };
	    TableBody.cellReactKey = function (rowIndex, columnIndex) {
	        return "cell-" + rowIndex + "-" + columnIndex;
	    };
	    TableBody.prototype.componentDidMount = function () {
	        this.maybeInvokeOnCompleteRender();
	    };
	    TableBody.prototype.shouldComponentUpdate = function (nextProps) {
	        var propKeysWhitelist = { include: UPDATE_PROPS_KEYS };
	        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, propKeysWhitelist);
	    };
	    TableBody.prototype.componentWillUpdate = function (nextProps) {
	        var resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };
	        var shouldResetBatcher = !utils_1.Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);
	        if (shouldResetBatcher) {
	            this.batcher.reset();
	        }
	    };
	    TableBody.prototype.componentDidUpdate = function () {
	        this.maybeInvokeOnCompleteRender();
	    };
	    TableBody.prototype.componentWillUnmount = function () {
	        this.batcher.cancelOutstandingCallback();
	    };
	    TableBody.prototype.render = function () {
	        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, focusedCell = _a.focusedCell, grid = _a.grid, numFrozenColumns = _a.numFrozenColumns, numFrozenRows = _a.numFrozenRows, onFocus = _a.onFocus, onSelection = _a.onSelection, renderMode = _a.renderMode, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
	        var cells = (renderMode === renderMode_1.RenderMode.BATCH)
	            ? this.renderBatchedCells()
	            : this.renderAllCells();
	        var defaultStyle = grid.getRect().sizeStyle();
	        var style = {
	            height: (numFrozenRows != null) ? grid.getCumulativeHeightAt(numFrozenRows - 1) : defaultStyle.height,
	            width: (numFrozenColumns != null) ? grid.getCumulativeWidthAt(numFrozenColumns - 1) : defaultStyle.width,
	        };
	        return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, focusedCell: focusedCell, locateClick: this.locateClick, locateDrag: this.locateDrag, onFocus: onFocus, onSelection: onSelection, onSelectionEnd: this.handleSelectionEnd, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
	            React.createElement(contextMenuTargetWrapper_1.ContextMenuTargetWrapper, { className: classNames(Classes.TABLE_BODY_VIRTUAL_CLIENT, Classes.TABLE_CELL_CLIENT), renderContextMenu: this.renderContextMenu, style: style }, cells)));
	    };
	    // Render modes
	    // ============
	    TableBody.prototype.renderBatchedCells = function () {
	        var _this = this;
	        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;
	        // render cells in batches
	        this.batcher.startNewBatch();
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	                this.batcher.addArgsToBatch(rowIndex, columnIndex);
	            }
	        }
	        this.batcher.removeOldAddNew(this.renderNewCell);
	        if (!this.batcher.isDone()) {
	            this.batcher.idleCallback(function () { return _this.forceUpdate(); });
	        }
	        var cells = this.batcher.getList();
	        return cells;
	    };
	    TableBody.prototype.renderAllCells = function () {
	        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;
	        var cells = [];
	        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
	            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
	                var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);
	                var isGhost = grid.isGhostIndex(rowIndex, columnIndex);
	                cells.push(this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost));
	            }
	        }
	        return cells;
	    };
	    TableBody.prototype.maybeInvokeOnCompleteRender = function () {
	        var _a = this.props, onCompleteRender = _a.onCompleteRender, renderMode = _a.renderMode;
	        if (renderMode === renderMode_1.RenderMode.BATCH
	            && this.isRenderingBatchedCells
	            && this.batcher.isDone()) {
	            this.isRenderingBatchedCells = false;
	            core_1.Utils.safeInvoke(onCompleteRender);
	        }
	        else if (renderMode === renderMode_1.RenderMode.NONE) {
	            core_1.Utils.safeInvoke(onCompleteRender);
	        }
	    };
	    return TableBody;
	}(React.Component));
	TableBody.defaultProps = {
	    loading: false,
	    renderMode: renderMode_1.RenderMode.BATCH,
	};
	exports.TableBody = TableBody;
	
	//# sourceMappingURL=tableBody.js.map


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
	 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
	 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
	 * and https://github.com/palantir/blueprint/blob/master/PATENTS
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var tslib_1 = __webpack_require__(3);
	var core_1 = __webpack_require__(8);
	var PureRender = __webpack_require__(10);
	var React = __webpack_require__(5);
	/**
	 * Since the ContextMenuTarget uses the `onContextMenu` prop instead
	 * `element.addEventListener`, the prop can be lost. This wrapper helps us
	 * maintain context menu fuctionality when doing fancy React.cloneElement
	 * chains.
	 */
	var ContextMenuTargetWrapper = (function (_super) {
	    tslib_1.__extends(ContextMenuTargetWrapper, _super);
	    function ContextMenuTargetWrapper() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ContextMenuTargetWrapper.prototype.render = function () {
	        var _a = this.props, className = _a.className, children = _a.children, style = _a.style;
	        return React.createElement("div", { className: className, style: style }, children);
	    };
	    ContextMenuTargetWrapper.prototype.renderContextMenu = function (e) {
	        return this.props.renderContextMenu(e);
	    };
	    return ContextMenuTargetWrapper;
	}(React.Component));
	ContextMenuTargetWrapper = tslib_1.__decorate([
	    core_1.ContextMenuTarget,
	    PureRender
	], ContextMenuTargetWrapper);
	exports.ContextMenuTargetWrapper = ContextMenuTargetWrapper;
	
	//# sourceMappingURL=contextMenuTargetWrapper.js.map


/***/ })
/******/ ])
});
;
//# sourceMappingURL=table.bundle.js.map