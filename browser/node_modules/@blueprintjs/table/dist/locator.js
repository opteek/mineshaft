/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Classes = require("./common/classes");
var rect_1 = require("./common/rect");
var utils_1 = require("./common/utils");
var Locator = (function () {
    function Locator(tableElement, bodyElement) {
        var _this = this;
        this.tableElement = tableElement;
        this.bodyElement = bodyElement;
        this.rowHeaderWidth = 0;
        this.columnHeaderHeight = 0;
        this.numFrozenRows = 0;
        this.numFrozenColumns = 0;
        this.convertCellIndexToClientX = function (index) {
            return _this.grid.getCumulativeWidthAt(index);
        };
        this.convertCellMidpointToClientX = function (index) {
            var cellLeft = _this.grid.getCumulativeWidthBefore(index);
            var cellRight = _this.grid.getCumulativeWidthAt(index);
            return (cellLeft + cellRight) / 2;
        };
        this.convertCellIndexToClientY = function (index) {
            return _this.grid.getCumulativeHeightAt(index);
        };
        this.convertCellMidpointToClientY = function (index) {
            var cellTop = _this.grid.getCumulativeHeightBefore(index);
            var cellBottom = _this.grid.getCumulativeHeightAt(index);
            return (cellTop + cellBottom) / 2;
        };
        this.toGridX = function (clientX) {
            var tableOffsetFromPageLeft = _this.tableElement.getBoundingClientRect().left;
            var cursorOffsetFromTableLeft = clientX - tableOffsetFromPageLeft;
            var cursorOffsetFromGridLeft = cursorOffsetFromTableLeft - _this.rowHeaderWidth;
            var scrollOffsetFromTableLeft = _this.bodyElement.scrollLeft;
            var isCursorWithinFrozenColumns = _this.numFrozenColumns != null
                && _this.numFrozenColumns > 0
                && cursorOffsetFromGridLeft <= _this.grid.getCumulativeWidthBefore(_this.numFrozenColumns);
            // the frozen-column region doesn't scroll, so ignore the scroll distance in that case
            return isCursorWithinFrozenColumns
                ? cursorOffsetFromGridLeft
                : cursorOffsetFromGridLeft + scrollOffsetFromTableLeft;
        };
        this.toGridY = function (clientY) {
            var tableOffsetFromPageTop = _this.tableElement.getBoundingClientRect().top;
            var cursorOffsetFromTableTop = clientY - tableOffsetFromPageTop;
            var cursorOffsetFromGridTop = cursorOffsetFromTableTop - _this.columnHeaderHeight;
            var scrollOffsetFromTableTop = _this.bodyElement.scrollTop;
            var isCursorWithinFrozenRows = _this.numFrozenRows != null
                && _this.numFrozenRows > 0
                && cursorOffsetFromGridTop <= _this.grid.getCumulativeHeightBefore(_this.numFrozenRows);
            return isCursorWithinFrozenRows
                ? cursorOffsetFromGridTop
                : cursorOffsetFromGridTop + scrollOffsetFromTableTop;
        };
        // empty constructor
    }
    // Setters
    // =======
    Locator.prototype.setGrid = function (grid) {
        this.grid = grid;
        return this;
    };
    Locator.prototype.setNumFrozenRows = function (numFrozenRows) {
        this.numFrozenRows = numFrozenRows;
        return this;
    };
    Locator.prototype.setNumFrozenColumns = function (numFrozenColumns) {
        this.numFrozenColumns = numFrozenColumns;
        return this;
    };
    Locator.prototype.setColumnHeaderHeight = function (columnHeaderHeight) {
        this.columnHeaderHeight = columnHeaderHeight;
        return this;
    };
    Locator.prototype.setRowHeaderWidth = function (rowHeaderWidth) {
        this.rowHeaderWidth = rowHeaderWidth;
        return this;
    };
    // Getters
    // =======
    Locator.prototype.getViewportRect = function () {
        return new rect_1.Rect(this.bodyElement.scrollLeft, this.bodyElement.scrollTop, this.bodyElement.clientWidth, this.bodyElement.clientHeight);
    };
    Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {
        var cells = this.tableElement.getElementsByClassName(Classes.columnCellIndexClass(columnIndex));
        var max = 0;
        for (var i = 0; i < cells.length; i++) {
            var contentWidth = utils_1.Utils.measureElementTextContent(cells.item(i)).width;
            var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;
            if (cellWidth > max) {
                max = cellWidth;
            }
        }
        return max;
    };
    Locator.prototype.getTallestVisibleCellInColumn = function (columnIndex) {
        var cells = this.tableElement
            .getElementsByClassName(Classes.columnCellIndexClass(columnIndex) + " " + Classes.TABLE_CELL);
        var max = 0;
        for (var i = 0; i < cells.length; i++) {
            var cellValue = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_VALUE);
            var cellTruncatedFormatText = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_FORMAT_TEXT);
            var cellTruncatedText = cells.item(i).querySelector("." + Classes.TABLE_TRUNCATED_TEXT);
            var height = 0;
            if (cellValue != null) {
                height = cellValue.scrollHeight;
            }
            else if (cellTruncatedFormatText != null) {
                height = cellTruncatedFormatText.scrollHeight;
            }
            else if (cellTruncatedText != null) {
                height = cellTruncatedText.scrollHeight;
            }
            else {
                // it's not anything we recognize, just use the current height of the cell
                height = cells.item(i).scrollHeight;
            }
            if (height > max) {
                max = height;
            }
        }
        return max;
    };
    // Converters
    // ==========
    Locator.prototype.convertPointToColumn = function (clientX, useMidpoint) {
        var tableRect = this.getTableRect();
        if (!tableRect.containsX(clientX)) {
            return -1;
        }
        var gridX = this.toGridX(clientX);
        var limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;
        var lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;
        return utils_1.Utils.binarySearch(gridX, limit, lookupFn);
    };
    Locator.prototype.convertPointToRow = function (clientY, useMidpoint) {
        var tableRect = this.getTableRect();
        if (!tableRect.containsY(clientY)) {
            return -1;
        }
        var gridY = this.toGridY(clientY);
        var limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;
        var lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;
        return utils_1.Utils.binarySearch(gridY, limit, lookupFn);
    };
    Locator.prototype.convertPointToCell = function (clientX, clientY) {
        var gridX = this.toGridX(clientX);
        var gridY = this.toGridY(clientY);
        var col = utils_1.Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);
        var row = utils_1.Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);
        return { col: col, row: row };
    };
    // Private helpers
    // ===============
    Locator.prototype.getTableRect = function () {
        return rect_1.Rect.wrap(this.tableElement.getBoundingClientRect());
    };
    return Locator;
}());
Locator.CELL_HORIZONTAL_PADDING = 10;
exports.Locator = Locator;

//# sourceMappingURL=locator.js.map
