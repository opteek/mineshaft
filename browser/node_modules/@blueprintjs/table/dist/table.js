/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var core_2 = require("@blueprintjs/core");
var classNames = require("classnames");
var React = require("react");
var column_1 = require("./column");
var Classes = require("./common/classes");
var clipboard_1 = require("./common/clipboard");
var Errors = require("./common/errors");
var grid_1 = require("./common/grid");
var FocusedCellUtils = require("./common/internal/focusedCellUtils");
var ScrollUtils = require("./common/internal/scrollUtils");
var rect_1 = require("./common/rect");
var renderMode_1 = require("./common/renderMode");
var utils_1 = require("./common/utils");
var columnHeader_1 = require("./headers/columnHeader");
var columnHeaderCell_1 = require("./headers/columnHeaderCell");
var rowHeader_1 = require("./headers/rowHeader");
var resizeSensor_1 = require("./interactions/resizeSensor");
var guides_1 = require("./layers/guides");
var regions_1 = require("./layers/regions");
var locator_1 = require("./locator");
var tableQuadrant_1 = require("./quadrants/tableQuadrant");
var tableQuadrantStack_1 = require("./quadrants/tableQuadrantStack");
var regions_2 = require("./regions");
var tableBody_1 = require("./tableBody");
var Table = Table_1 = (function (_super) {
    tslib_1.__extends(Table, _super);
    function Table(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.refHandlers = {
            columnHeader: function (ref) { return _this.columnHeaderElement = ref; },
            mainQuadrant: function (ref) { return _this.mainQuadrantElement = ref; },
            quadrantStack: function (ref) { return _this.quadrantStackInstance = ref; },
            rowHeader: function (ref) { return _this.rowHeaderElement = ref; },
            scrollContainer: function (ref) { return _this.scrollContainerElement = ref; },
        };
        _this.handleCopy = function (e) {
            var grid = _this.grid;
            var _a = _this.props, getCellClipboardData = _a.getCellClipboardData, onCopy = _a.onCopy;
            var selectedRegions = _this.state.selectedRegions;
            if (getCellClipboardData == null) {
                return;
            }
            // prevent "real" copy from being called
            e.preventDefault();
            e.stopPropagation();
            var cells = regions_2.Regions.enumerateUniqueCells(selectedRegions, grid.numRows, grid.numCols);
            var sparse = regions_2.Regions.sparseMapCells(cells, getCellClipboardData);
            if (sparse != null) {
                var success = clipboard_1.Clipboard.copyCells(sparse);
                core_1.Utils.safeInvoke(onCopy, success);
            }
        };
        _this.renderMenu = function (refHandler) {
            var classes = classNames(Classes.TABLE_MENU, (_a = {},
                _a[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE),
                _a));
            return (React.createElement("div", { className: classes, ref: refHandler, onMouseDown: _this.handleMenuMouseDown }, _this.maybeRenderRegions(_this.styleMenuRegion)));
            var _a;
        };
        _this.handleMenuMouseDown = function (e) {
            // the shift+click interaction expands the region from the focused cell.
            // thus, if shift is pressed we shouldn't move the focused cell.
            _this.selectAll(!e.shiftKey);
        };
        _this.selectAll = function (shouldUpdateFocusedCell) {
            var selectionHandler = _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_TABLE);
            // clicking on upper left hand corner sets selection to "all"
            // regardless of current selection state (clicking twice does not deselect table)
            selectionHandler([regions_2.Regions.table()]);
            if (shouldUpdateFocusedCell) {
                var newFocusedCellCoordinates = regions_2.Regions.getFocusCellCoordinatesFromRegion(regions_2.Regions.table());
                _this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));
            }
        };
        _this.handleSelectAllHotkey = function (e) {
            // prevent "real" select all from happening as well
            e.preventDefault();
            e.stopPropagation();
            // selecting-all via the keyboard should not move the focused cell.
            _this.selectAll(false);
        };
        _this.columnHeaderCellRenderer = function (columnIndex) {
            var props = _this.getColumnProps(columnIndex);
            var id = props.id, loadingOptions = props.loadingOptions, renderCell = props.renderCell, renderColumnHeader = props.renderColumnHeader, spreadableProps = tslib_1.__rest(props, ["id", "loadingOptions", "renderCell", "renderColumnHeader"]);
            var columnLoading = _this.hasLoadingOption(loadingOptions, regions_2.ColumnLoadingOption.HEADER);
            if (renderColumnHeader != null) {
                var columnHeader = renderColumnHeader(columnIndex);
                var columnHeaderLoading = columnHeader.props.loading;
                return React.cloneElement(columnHeader, {
                    loading: columnHeaderLoading != null ? columnHeaderLoading : columnLoading,
                });
            }
            var baseProps = tslib_1.__assign({ index: columnIndex, loading: columnLoading }, spreadableProps);
            if (props.name != null) {
                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, baseProps));
            }
            else {
                return React.createElement(columnHeaderCell_1.ColumnHeaderCell, tslib_1.__assign({}, baseProps, { name: utils_1.Utils.toBase26Alpha(columnIndex) }));
            }
        };
        _this.renderColumnHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly) {
            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }
            var _a = _this, grid = _a.grid, locator = _a.locator;
            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, isColumnReorderable = _c.isColumnReorderable, isColumnResizable = _c.isColumnResizable, loadingOptions = _c.loadingOptions, maxColumnWidth = _c.maxColumnWidth, minColumnWidth = _c.minColumnWidth, selectedRegionTransform = _c.selectedRegionTransform;
            var classes = classNames(Classes.TABLE_COLUMN_HEADERS, (_d = {},
                _d[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_COLUMNS),
                _d));
            var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;
            var columnIndexEnd = showFrozenColumnsOnly ? _this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;
            return (React.createElement("div", { className: classes, ref: refHandler },
                React.createElement(columnHeader_1.ColumnHeader, { allowMultipleSelection: allowMultipleSelection, cellRenderer: _this.columnHeaderCellRenderer, focusedCell: focusedCell, grid: grid, isReorderable: isColumnReorderable, isResizable: isColumnResizable, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS), locator: locator, maxColumnWidth: maxColumnWidth, minColumnWidth: minColumnWidth, onColumnWidthChanged: _this.handleColumnWidthChanged, onFocus: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onReordered: _this.handleColumnsReordered, onReordering: reorderingHandler, onResizeGuide: resizeHandler, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd }, _this.props.children),
                _this.maybeRenderRegions(_this.styleColumnHeaderRegion)));
            var _d;
        };
        _this.renderRowHeader = function (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly) {
            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }
            var _a = _this, grid = _a.grid, locator = _a.locator;
            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, isRowReorderable = _c.isRowReorderable, isRowResizable = _c.isRowResizable, loadingOptions = _c.loadingOptions, maxRowHeight = _c.maxRowHeight, minRowHeight = _c.minRowHeight, renderRowHeader = _c.renderRowHeader, selectedRegionTransform = _c.selectedRegionTransform;
            var classes = classNames(Classes.TABLE_ROW_HEADERS, (_d = {},
                _d[Classes.TABLE_SELECTION_ENABLED] = _this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_ROWS),
                _d));
            var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;
            var rowIndexEnd = showFrozenRowsOnly ? _this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;
            return (React.createElement("div", { className: classes, ref: refHandler },
                React.createElement(rowHeader_1.RowHeader, { allowMultipleSelection: allowMultipleSelection, focusedCell: focusedCell, grid: grid, locator: locator, isReorderable: isRowReorderable, isResizable: isRowResizable, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocus: _this.handleFocus, onLayoutLock: _this.handleLayoutLock, onResizeGuide: resizeHandler, onReordered: _this.handleRowsReordered, onReordering: reorderingHandler, onRowHeightChanged: _this.handleRowHeightChanged, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.FULL_ROWS), renderRowHeader: renderRowHeader, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd }),
                _this.maybeRenderRegions(_this.styleRowHeaderRegion)));
            var _d;
        };
        _this.bodyCellRenderer = function (rowIndex, columnIndex) {
            var columnProps = _this.getColumnProps(columnIndex);
            var cell = columnProps.renderCell(rowIndex, columnIndex);
            var cellLoading = cell.props.loading;
            var loading = cellLoading != null
                ? cellLoading
                : _this.hasLoadingOption(columnProps.loadingOptions, regions_2.ColumnLoadingOption.CELLS);
            return React.cloneElement(cell, tslib_1.__assign({}, columnProps, { loading: loading }));
        };
        _this.renderBody = function (quadrantType, showFrozenRowsOnly, showFrozenColumnsOnly) {
            if (showFrozenRowsOnly === void 0) { showFrozenRowsOnly = false; }
            if (showFrozenColumnsOnly === void 0) { showFrozenColumnsOnly = false; }
            var _a = _this, grid = _a.grid, locator = _a.locator;
            var _b = _this.state, focusedCell = _b.focusedCell, selectedRegions = _b.selectedRegions, viewportRect = _b.viewportRect;
            var _c = _this.props, allowMultipleSelection = _c.allowMultipleSelection, fillBodyWithGhostCells = _c.fillBodyWithGhostCells, loadingOptions = _c.loadingOptions, renderBodyContextMenu = _c.renderBodyContextMenu, renderMode = _c.renderMode, selectedRegionTransform = _c.selectedRegionTransform;
            var numFrozenColumns = _this.getNumFrozenColumnsClamped();
            var numFrozenRows = _this.getNumFrozenRowsClamped();
            var rowIndices = grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
            var columnIndices = grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
            var columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;
            var columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns : columnIndices.columnIndexEnd;
            var rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;
            var rowIndexEnd = showFrozenRowsOnly ? numFrozenRows : rowIndices.rowIndexEnd;
            // the main quadrant contains all cells in the table, so listen only to that quadrant
            var onCompleteRender = quadrantType === tableQuadrant_1.QuadrantType.MAIN
                ? _this.handleCompleteRender
                : undefined;
            return (React.createElement("div", null,
                React.createElement(tableBody_1.TableBody, { allowMultipleSelection: allowMultipleSelection, cellRenderer: _this.bodyCellRenderer, focusedCell: focusedCell, grid: grid, loading: _this.hasLoadingOption(loadingOptions, regions_2.TableLoadingOption.CELLS), locator: locator, onCompleteRender: onCompleteRender, onFocus: _this.handleFocus, onSelection: _this.getEnabledSelectionHandler(regions_2.RegionCardinality.CELLS), renderBodyContextMenu: renderBodyContextMenu, renderMode: renderMode, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd, numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined, numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined }),
                _this.maybeRenderRegions(_this.styleBodyRegion, quadrantType)));
        };
        _this.handleCompleteRender = function () {
            // the first onCompleteRender is triggered before the viewportRect is
            // defined and the second after the viewportRect has been set. the cells
            // will only actually render once the viewportRect is defined though, so
            // we defer invoking onCompleteRender until that check passes.
            if (_this.state.viewportRect != null) {
                core_1.Utils.safeInvoke(_this.props.onCompleteRender);
            }
        };
        _this.handleFocusMoveLeft = function (e) { return _this.handleFocusMove(e, "left"); };
        _this.handleFocusMoveLeftInternal = function (e) { return _this.handleFocusMoveInternal(e, "left"); };
        _this.handleFocusMoveRight = function (e) { return _this.handleFocusMove(e, "right"); };
        _this.handleFocusMoveRightInternal = function (e) { return _this.handleFocusMoveInternal(e, "right"); };
        _this.handleFocusMoveUp = function (e) { return _this.handleFocusMove(e, "up"); };
        _this.handleFocusMoveUpInternal = function (e) { return _this.handleFocusMoveInternal(e, "up"); };
        _this.handleFocusMoveDown = function (e) { return _this.handleFocusMove(e, "down"); };
        _this.handleFocusMoveDownInternal = function (e) { return _this.handleFocusMoveInternal(e, "down"); };
        _this.styleBodyRegion = function (region, quadrantType) {
            var numFrozenColumns = _this.props.numFrozenColumns;
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = _this.grid.getRegionStyle(region);
            // ensure we're not showing borders at the boundary of the frozen-columns area
            var canHideRightBorder = (quadrantType === tableQuadrant_1.QuadrantType.TOP_LEFT || quadrantType === tableQuadrant_1.QuadrantType.LEFT)
                && numFrozenColumns != null && numFrozenColumns > 0;
            var fixedHeight = _this.grid.getHeight();
            var fixedWidth = _this.grid.getWidth();
            // include a correction in some cases to hide borders along quadrant boundaries
            var alignmentCorrection = 1;
            var alignmentCorrectionString = "-" + alignmentCorrection + "px";
            switch (cardinality) {
                case regions_2.RegionCardinality.CELLS:
                    return style;
                case regions_2.RegionCardinality.FULL_COLUMNS:
                    style.top = alignmentCorrectionString;
                    style.height = fixedHeight + alignmentCorrection;
                    return style;
                case regions_2.RegionCardinality.FULL_ROWS:
                    style.left = alignmentCorrectionString;
                    style.width = fixedWidth + alignmentCorrection;
                    if (canHideRightBorder) {
                        style.right = alignmentCorrectionString;
                    }
                    return style;
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.left = alignmentCorrectionString;
                    style.top = alignmentCorrectionString;
                    style.width = fixedWidth + alignmentCorrection;
                    style.height = fixedHeight + alignmentCorrection;
                    if (canHideRightBorder) {
                        style.right = alignmentCorrectionString;
                    }
                    return style;
                default:
                    return { display: "none" };
            }
        };
        _this.styleMenuRegion = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.right = "0px";
                    style.bottom = "0px";
                    style.top = "0px";
                    style.left = "0px";
                    style.borderBottom = "none";
                    style.borderRight = "none";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        _this.styleColumnHeaderRegion = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.left = "-1px";
                    style.borderLeft = "none";
                    style.bottom = "-1px";
                    return style;
                case regions_2.RegionCardinality.FULL_COLUMNS:
                    style.bottom = "-1px";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        _this.styleRowHeaderRegion = function (region) {
            var grid = _this.grid;
            var viewportRect = _this.state.viewportRect;
            if (viewportRect == null) {
                return {};
            }
            var cardinality = regions_2.Regions.getRegionCardinality(region);
            var style = grid.getRegionStyle(region);
            switch (cardinality) {
                case regions_2.RegionCardinality.FULL_TABLE:
                    style.top = "-1px";
                    style.borderTop = "none";
                    style.right = "-1px";
                    return style;
                case regions_2.RegionCardinality.FULL_ROWS:
                    style.right = "-1px";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        _this.handleColumnWidthChanged = function (columnIndex, width) {
            var selectedRegions = _this.state.selectedRegions;
            var columnWidths = _this.state.columnWidths.slice();
            if (regions_2.Regions.hasFullTable(selectedRegions)) {
                for (var col = 0; col < columnWidths.length; col++) {
                    columnWidths[col] = width;
                }
            }
            if (regions_2.Regions.hasFullColumn(selectedRegions, columnIndex)) {
                regions_2.Regions.eachUniqueFullColumn(selectedRegions, function (col) {
                    columnWidths[col] = width;
                });
            }
            else {
                columnWidths[columnIndex] = width;
            }
            _this.invalidateGrid();
            _this.setState({ columnWidths: columnWidths });
            var onColumnWidthChanged = _this.props.onColumnWidthChanged;
            if (onColumnWidthChanged != null) {
                onColumnWidthChanged(columnIndex, width);
            }
        };
        _this.handleRowHeightChanged = function (rowIndex, height) {
            var selectedRegions = _this.state.selectedRegions;
            var rowHeights = _this.state.rowHeights.slice();
            if (regions_2.Regions.hasFullTable(selectedRegions)) {
                for (var row = 0; row < rowHeights.length; row++) {
                    rowHeights[row] = height;
                }
            }
            if (regions_2.Regions.hasFullRow(selectedRegions, rowIndex)) {
                regions_2.Regions.eachUniqueFullRow(selectedRegions, function (row) {
                    rowHeights[row] = height;
                });
            }
            else {
                rowHeights[rowIndex] = height;
            }
            _this.invalidateGrid();
            _this.setState({ rowHeights: rowHeights });
            var onRowHeightChanged = _this.props.onRowHeightChanged;
            if (onRowHeightChanged != null) {
                onRowHeightChanged(rowIndex, height);
            }
        };
        _this.handleRootScroll = function (_event) {
            // Bug #211 - Native browser text selection events can cause the root
            // element to scroll even though it has a overflow:hidden style. The
            // only viable solution to this is to unscroll the element after the
            // browser scrolls it.
            if (_this.rootTableElement != null) {
                _this.rootTableElement.scrollLeft = 0;
                _this.rootTableElement.scrollTop = 0;
            }
        };
        _this.handleBodyScroll = function (event) {
            // Prevent the event from propagating to avoid a resize event on the
            // resize sensor.
            event.stopPropagation();
            if (_this.locator != null && !_this.state.isLayoutLocked) {
                var viewportRect = _this.locator.getViewportRect();
                _this.updateViewportRect(viewportRect);
            }
        };
        _this.clearSelection = function (_selectedRegions) {
            _this.handleSelection([]);
        };
        // no good way to call arrow-key keyboard events from tests
        /* istanbul ignore next */
        _this.handleFocusMove = function (e, direction) {
            e.preventDefault();
            e.stopPropagation();
            var focusedCell = _this.state.focusedCell;
            if (focusedCell == null) {
                // halt early if we have a selectedRegionTransform or something else in play that nixes
                // the focused cell.
                return;
            }
            var newFocusedCell = { col: focusedCell.col, row: focusedCell.row, focusSelectionIndex: 0 };
            var grid = _this.grid;
            switch (direction) {
                case "up":
                    newFocusedCell.row -= 1;
                    break;
                case "down":
                    newFocusedCell.row += 1;
                    break;
                case "left":
                    newFocusedCell.col -= 1;
                    break;
                case "right":
                    newFocusedCell.col += 1;
                    break;
                default:
                    break;
            }
            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
                return;
            }
            // change selection to match new focus cell location
            var newSelectionRegions = [regions_2.Regions.cell(newFocusedCell.row, newFocusedCell.col)];
            _this.handleSelection(newSelectionRegions);
            _this.handleFocus(newFocusedCell);
            // keep the focused cell in view
            _this.scrollBodyToFocusedCell(newFocusedCell);
        };
        // no good way to call arrow-key keyboard events from tests
        /* istanbul ignore next */
        _this.handleFocusMoveInternal = function (e, direction) {
            e.preventDefault();
            e.stopPropagation();
            var _a = _this.state, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;
            var grid = _this.grid;
            if (focusedCell == null) {
                // halt early if we have a selectedRegionTransform or something else in play that nixes
                // the focused cell.
                return;
            }
            var newFocusedCell = {
                col: focusedCell.col,
                focusSelectionIndex: focusedCell.focusSelectionIndex,
                row: focusedCell.row,
            };
            // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one
            if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {
                var focusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[0], grid.numRows, grid.numCols);
                newFocusedCell = {
                    col: focusCellRegion.cols[0],
                    focusSelectionIndex: 0,
                    row: focusCellRegion.rows[0],
                };
            }
            else {
                if (selectedRegions.length === 0) {
                    _this.handleFocusMove(e, direction);
                    return;
                }
                var focusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], grid.numRows, grid.numCols);
                if (focusCellRegion.cols[0] === focusCellRegion.cols[1]
                    && focusCellRegion.rows[0] === focusCellRegion.rows[1]
                    && selectedRegions.length === 1) {
                    _this.handleFocusMove(e, direction);
                    return;
                }
                switch (direction) {
                    case "up":
                        newFocusedCell = _this.moveFocusCell("row", "col", true, newFocusedCell, focusCellRegion);
                        break;
                    case "left":
                        newFocusedCell = _this.moveFocusCell("col", "row", true, newFocusedCell, focusCellRegion);
                        break;
                    case "down":
                        newFocusedCell = _this.moveFocusCell("row", "col", false, newFocusedCell, focusCellRegion);
                        break;
                    case "right":
                        newFocusedCell = _this.moveFocusCell("col", "row", false, newFocusedCell, focusCellRegion);
                        break;
                    default:
                        break;
                }
            }
            if (newFocusedCell.row < 0 || newFocusedCell.row >= grid.numRows ||
                newFocusedCell.col < 0 || newFocusedCell.col >= grid.numCols) {
                return;
            }
            _this.handleFocus(newFocusedCell);
            // keep the focused cell in view
            _this.scrollBodyToFocusedCell(newFocusedCell);
        };
        _this.scrollBodyToFocusedCell = function (focusedCell) {
            var row = focusedCell.row, col = focusedCell.col;
            var viewportRect = _this.state.viewportRect;
            // sort keys in normal CSS position order (per the trusty TRBL/"trouble" acronym)
            // tslint:disable:object-literal-sort-keys
            var viewportBounds = {
                top: viewportRect.top,
                right: viewportRect.left + viewportRect.width,
                bottom: viewportRect.top + viewportRect.height,
                left: viewportRect.left,
            };
            var focusedCellBounds = {
                top: _this.grid.getCumulativeHeightBefore(row),
                right: _this.grid.getCumulativeWidthAt(col),
                bottom: _this.grid.getCumulativeHeightAt(row),
                left: _this.grid.getCumulativeWidthBefore(col),
            };
            // tslint:enable:object-literal-sort-keys
            var focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;
            var focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;
            var isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;
            var isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;
            var nextScrollTop = viewportRect.top;
            var nextScrollLeft = viewportRect.left;
            // keep the top end of an overly tall focused cell in view when moving left and right
            // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)
            if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {
                // scroll up (minus one pixel to avoid clipping the focused-cell border)
                nextScrollTop = Math.max(0, focusedCellBounds.top - 1);
            }
            else if (focusedCellBounds.bottom > viewportBounds.bottom) {
                // scroll down
                var scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;
                nextScrollTop = viewportBounds.top + scrollDelta;
            }
            // keep the left end of an overly wide focused cell in view when moving up and down
            if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {
                // scroll left (again minus one additional pixel)
                nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);
            }
            else if (focusedCellBounds.right > viewportBounds.right) {
                // scroll right
                var scrollDelta = focusedCellBounds.right - viewportBounds.right;
                nextScrollLeft = viewportBounds.left + scrollDelta;
            }
            _this.syncViewportPosition(nextScrollLeft, nextScrollTop);
        };
        _this.handleFocus = function (focusedCell) {
            if (!_this.props.enableFocus) {
                // don't set focus state if focus is not allowed
                return;
            }
            // only set focused cell state if not specified in props
            if (_this.props.focusedCell == null) {
                _this.setState({ focusedCell: focusedCell });
            }
            core_1.Utils.safeInvoke(_this.props.onFocus, focusedCell);
        };
        _this.handleSelection = function (selectedRegions) {
            // only set selectedRegions state if not specified in props
            if (_this.props.selectedRegions == null) {
                _this.setState({ selectedRegions: selectedRegions });
            }
            var onSelection = _this.props.onSelection;
            if (onSelection != null) {
                onSelection(selectedRegions);
            }
        };
        _this.handleColumnsReordering = function (verticalGuides) {
            _this.setState({ isReordering: true, verticalGuides: verticalGuides });
        };
        _this.handleColumnsReordered = function (oldIndex, newIndex, length) {
            _this.setState({ isReordering: false, verticalGuides: undefined });
            core_1.Utils.safeInvoke(_this.props.onColumnsReordered, oldIndex, newIndex, length);
        };
        _this.handleRowsReordering = function (horizontalGuides) {
            _this.setState({ isReordering: true, horizontalGuides: horizontalGuides });
        };
        _this.handleRowsReordered = function (oldIndex, newIndex, length) {
            _this.setState({ isReordering: false, horizontalGuides: undefined });
            core_1.Utils.safeInvoke(_this.props.onRowsReordered, oldIndex, newIndex, length);
        };
        _this.handleLayoutLock = function (isLayoutLocked) {
            if (isLayoutLocked === void 0) { isLayoutLocked = false; }
            _this.setState({ isLayoutLocked: isLayoutLocked });
        };
        _this.hasLoadingOption = function (loadingOptions, loadingOption) {
            if (loadingOptions == null) {
                return undefined;
            }
            return loadingOptions.indexOf(loadingOption) >= 0;
        };
        _this.updateViewportRect = function (nextViewportRect) {
            _this.setState({ viewportRect: nextViewportRect });
            var viewportRect = _this.state.viewportRect;
            var didViewportChange = (viewportRect != null && !viewportRect.equals(nextViewportRect))
                || (viewportRect == null && nextViewportRect != null);
            if (didViewportChange) {
                _this.invokeOnVisibleCellsChangeCallback(nextViewportRect);
            }
        };
        _this.getMaxFrozenColumnIndex = function () {
            var numFrozenColumns = _this.getNumFrozenColumnsClamped();
            return (numFrozenColumns != null) ? numFrozenColumns - 1 : undefined;
        };
        _this.getMaxFrozenRowIndex = function () {
            var numFrozenRows = _this.getNumFrozenRowsClamped();
            return (numFrozenRows != null) ? numFrozenRows - 1 : undefined;
        };
        _this.handleColumnResizeGuide = function (verticalGuides) {
            _this.setState({ verticalGuides: verticalGuides });
        };
        _this.handleRowResizeGuide = function (horizontalGuides) {
            _this.setState({ horizontalGuides: horizontalGuides });
        };
        _this.setBodyRef = function (ref) { return _this.bodyElement = ref; };
        _this.setRootTableRef = function (ref) { return _this.rootTableElement = ref; };
        var _a = _this.props, children = _a.children, columnWidths = _a.columnWidths, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth, numRows = _a.numRows, rowHeights = _a.rowHeights;
        _this.childrenArray = React.Children.toArray(children);
        _this.columnIdToIndex = Table_1.createColumnIdIndex(_this.childrenArray);
        // Create height/width arrays using the lengths from props and
        // children, the default values from props, and finally any sparse
        // arrays passed into props.
        var newColumnWidths = _this.childrenArray.map(function () { return defaultColumnWidth; });
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
        var newRowHeights = utils_1.Utils.times(numRows, function () { return defaultRowHeight; });
        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
        var selectedRegions = (props.selectedRegions == null) ? [] : props.selectedRegions;
        var focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocus, props.focusedCell, undefined, selectedRegions);
        _this.state = {
            columnWidths: newColumnWidths,
            focusedCell: focusedCell,
            isLayoutLocked: false,
            isReordering: false,
            rowHeights: newRowHeights,
            selectedRegions: selectedRegions,
        };
        return _this;
    }
    Table.createColumnIdIndex = function (children) {
        var columnIdToIndex = {};
        for (var i = 0; i < children.length; i++) {
            var key = children[i].props.id;
            if (key != null) {
                columnIdToIndex[String(key)] = i;
            }
        }
        return columnIdToIndex;
    };
    // Instance methods
    // ================
    /**
     * Resize all rows in the table to the height of the tallest visible cell in the specified columns.
     * If no indices are provided, default to using the tallest visible cell from all columns in view.
     */
    Table.prototype.resizeRowsByTallestCell = function (columnIndices) {
        var _this = this;
        var tallest = 0;
        if (columnIndices == null) {
            // Consider all columns currently in viewport
            var viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);
            for (var col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {
                tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));
            }
        }
        else {
            var columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];
            var tallestByColumns = columnIndicesArray.map(function (col) { return _this.locator.getTallestVisibleCellInColumn(col); });
            tallest = Math.max.apply(Math, tallestByColumns);
        }
        var rowHeights = Array(this.state.rowHeights.length).fill(tallest);
        this.invalidateGrid();
        this.setState({ rowHeights: rowHeights });
    };
    /**
     * Scrolls the table to the target region in a fashion appropriate to the target region's
     * cardinality:
     *
     * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.
     * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.
     * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.
     * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.
     *
     * If there are active frozen rows and/or columns, the target region will be positioned in the
     * top-left corner of the non-frozen area (unless the target region itself is in the frozen
     * area).
     *
     * If the target region is close to the bottom-right corner of the table, this function will
     * simply scroll the target region as close to the top-left as possible until the bottom-right
     * corner is reached.
     */
    Table.prototype.scrollToRegion = function (region) {
        var _a = this.state.viewportRect, currScrollLeft = _a.left, currScrollTop = _a.top;
        var numFrozenRows = this.getNumFrozenRowsClamped();
        var numFrozenColumns = this.getNumFrozenColumnsClamped();
        var _b = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns), scrollLeft = _b.scrollLeft, scrollTop = _b.scrollTop;
        var correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;
        var correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop;
        // defer to the quadrant stack to keep all quadrant positions in sync
        this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);
    };
    // React lifecycle
    // ===============
    Table.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var propKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST };
        var stateKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST };
        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, propKeysBlacklist)
            || !utils_1.Utils.shallowCompareKeys(this.state, nextState, stateKeysBlacklist)
            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST)
            || !utils_1.Utils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST);
    };
    Table.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var children = nextProps.children, columnWidths = nextProps.columnWidths, defaultColumnWidth = nextProps.defaultColumnWidth, defaultRowHeight = nextProps.defaultRowHeight, enableFocus = nextProps.enableFocus, focusedCell = nextProps.focusedCell, numRows = nextProps.numRows, rowHeights = nextProps.rowHeights, selectedRegions = nextProps.selectedRegions, selectionModes = nextProps.selectionModes;
        var newChildArray = React.Children.toArray(children);
        var numCols = newChildArray.length;
        // Try to maintain widths of columns by looking up the width of the
        // column that had the same `ID` prop. If none is found, use the
        // previous width at the same index.
        var previousColumnWidths = newChildArray.map(function (child, index) {
            var mappedIndex = _this.columnIdToIndex[child.props.id];
            return _this.state.columnWidths[mappedIndex != null ? mappedIndex : index];
        });
        // Make sure the width/height arrays have the correct length, but keep
        // as many existing widths/heights when possible. Also, apply the
        // sparse width/heights from props.
        var newColumnWidths = this.state.columnWidths;
        newColumnWidths = utils_1.Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, previousColumnWidths);
        newColumnWidths = utils_1.Utils.assignSparseValues(newColumnWidths, columnWidths);
        var newRowHeights = this.state.rowHeights;
        newRowHeights = utils_1.Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);
        newRowHeights = utils_1.Utils.assignSparseValues(newRowHeights, rowHeights);
        var newSelectedRegions = selectedRegions;
        if (selectedRegions == null) {
            // if we're in uncontrolled mode, filter out all selected regions that don't
            // fit in the current new table dimensions
            newSelectedRegions = this.state.selectedRegions.filter(function (region) {
                var regionCardinality = regions_2.Regions.getRegionCardinality(region);
                var isSelectionModeEnabled = selectionModes.indexOf(regionCardinality) >= 0;
                return isSelectionModeEnabled && regions_2.Regions.isRegionValidForTable(region, numRows, numCols);
            });
        }
        var newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocus, focusedCell, this.state.focusedCell, newSelectedRegions);
        this.childrenArray = newChildArray;
        this.columnIdToIndex = Table_1.createColumnIdIndex(this.childrenArray);
        this.invalidateGrid();
        this.setState({
            columnWidths: newColumnWidths,
            focusedCell: newFocusedCell,
            rowHeights: newRowHeights,
            selectedRegions: newSelectedRegions,
        });
    };
    Table.prototype.render = function () {
        var _a = this.props, className = _a.className, isRowHeaderShown = _a.isRowHeaderShown;
        var _b = this.state, horizontalGuides = _b.horizontalGuides, verticalGuides = _b.verticalGuides;
        this.validateGrid();
        var classes = classNames(Classes.TABLE_CONTAINER, (_c = {},
            _c[Classes.TABLE_REORDERING] = this.state.isReordering,
            _c[Classes.TABLE_NO_VERTICAL_SCROLL] = this.shouldDisableVerticalScroll(),
            _c[Classes.TABLE_NO_HORIZONTAL_SCROLL] = this.shouldDisableHorizontalScroll(),
            _c[Classes.TABLE_SELECTION_ENABLED] = this.isSelectionModeEnabled(regions_2.RegionCardinality.CELLS),
            _c), className);
        return (React.createElement("div", { className: classes, ref: this.setRootTableRef, onScroll: this.handleRootScroll },
            React.createElement(tableQuadrantStack_1.TableQuadrantStack, { bodyRef: this.setBodyRef, columnHeaderRef: this.refHandlers.columnHeader, grid: this.grid, handleColumnResizeGuide: this.handleColumnResizeGuide, handleColumnsReordering: this.handleColumnsReordering, handleRowResizeGuide: this.handleRowResizeGuide, handleRowsReordering: this.handleRowsReordering, isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(), isRowHeaderShown: isRowHeaderShown, isVerticalScrollDisabled: this.shouldDisableVerticalScroll(), numFrozenColumns: this.getNumFrozenColumnsClamped(), numFrozenRows: this.getNumFrozenRowsClamped(), onScroll: this.handleBodyScroll, quadrantRef: this.refHandlers.mainQuadrant, ref: this.refHandlers.quadrantStack, renderBody: this.renderBody, renderColumnHeader: this.renderColumnHeader, renderMenu: this.renderMenu, renderRowHeader: this.renderRowHeader, rowHeaderRef: this.refHandlers.rowHeader, scrollContainerRef: this.refHandlers.scrollContainer }),
            React.createElement("div", { className: classNames(Classes.TABLE_OVERLAY_LAYER, "bp-table-reordering-cursor-overlay") }),
            React.createElement(guides_1.GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides })));
        var _c;
    };
    Table.prototype.renderHotkeys = function () {
        var hotkeys = [this.maybeRenderCopyHotkey(), this.maybeRenderSelectAllHotkey(), this.maybeRenderFocusHotkeys()];
        return (React.createElement(core_2.Hotkeys, null, hotkeys.filter(function (element) { return element !== undefined; })));
    };
    /**
     * When the component mounts, the HTML Element refs will be available, so
     * we constructor the Locator, which queries the elements' bounding
     * ClientRects.
     */
    Table.prototype.componentDidMount = function () {
        var _this = this;
        this.validateGrid();
        this.locator = new locator_1.Locator(this.mainQuadrantElement, this.scrollContainerElement);
        this.updateLocator();
        this.updateViewportRect(this.locator.getViewportRect());
        this.resizeSensorDetach = resizeSensor_1.ResizeSensor.attach(this.rootTableElement, function () {
            if (!_this.state.isLayoutLocked) {
                _this.updateViewportRect(_this.locator.getViewportRect());
            }
        });
    };
    Table.prototype.componentWillUnmount = function () {
        if (this.resizeSensorDetach != null) {
            this.resizeSensorDetach();
            delete this.resizeSensorDetach;
        }
    };
    Table.prototype.componentDidUpdate = function () {
        if (this.locator != null) {
            this.validateGrid();
            this.updateLocator();
        }
        this.maybeScrollTableIntoView();
    };
    Table.prototype.validateProps = function (props) {
        var children = props.children, numFrozenColumns = props.numFrozenColumns, numFrozenRows = props.numFrozenRows, numRows = props.numRows;
        var numColumns = React.Children.count(children);
        React.Children.forEach(children, function (child) {
            // save as a variable so that union type narrowing works
            var childType = child.type;
            if (typeof childType === "string") {
                console.warn(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);
            }
            else {
                var isColumn = childType.prototype === column_1.Column.prototype || column_1.Column.prototype.isPrototypeOf(childType);
                if (!isColumn) {
                    console.warn(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);
                }
            }
        });
        if (numFrozenColumns != null && (numFrozenColumns < 0 || numFrozenColumns > numColumns)) {
            console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);
        }
        if (numFrozenRows != null && (numFrozenRows < 0 || (numRows != null && numFrozenRows > numRows))) {
            console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);
        }
    };
    // Quadrant refs
    // =============
    Table.prototype.moveFocusCell = function (primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {
        var grid = this.grid;
        var selectedRegions = this.state.selectedRegions;
        var primaryAxisPlural = primaryAxis === "row" ? "rows" : "cols";
        var secondaryAxisPlural = secondaryAxis === "row" ? "rows" : "cols";
        var movementDirection = isUpOrLeft ? -1 : +1;
        var regionIntervalIndex = isUpOrLeft ? 1 : 0;
        // try moving the cell in the direction along the primary axis
        newFocusedCell[primaryAxis] += movementDirection;
        var isPrimaryIndexOutOfBounds = isUpOrLeft
            ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0]
            : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];
        if (isPrimaryIndexOutOfBounds) {
            // if we moved outside the bounds of selection region,
            // move to the start (or end) of the primary axis, and move one along the secondary
            newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];
            newFocusedCell[secondaryAxis] += movementDirection;
            var isSecondaryIndexOutOfBounds = isUpOrLeft
                ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0]
                : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];
            if (isSecondaryIndexOutOfBounds) {
                // if moving along the secondary also moves us outside
                // go to the start (or end) of the next (or previous region)
                // (note that if there's only one region you'll be moving to the opposite corner, which is fine)
                var newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection;
                // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around
                if (isUpOrLeft
                    ? newFocusCellSelectionIndex < 0
                    : newFocusCellSelectionIndex >= selectedRegions.length) {
                    newFocusCellSelectionIndex = isUpOrLeft
                        ? selectedRegions.length - 1
                        : 0;
                }
                var newFocusCellRegion = regions_2.Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], grid.numRows, grid.numCols);
                newFocusedCell = {
                    col: newFocusCellRegion.cols[regionIntervalIndex],
                    focusSelectionIndex: newFocusCellSelectionIndex,
                    row: newFocusCellRegion.rows[regionIntervalIndex],
                };
            }
        }
        return newFocusedCell;
    };
    Table.prototype.shouldDisableVerticalScroll = function () {
        var fillBodyWithGhostCells = this.props.fillBodyWithGhostCells;
        var viewportRect = this.state.viewportRect;
        var rowIndices = this.grid.getRowIndicesInRect(viewportRect, fillBodyWithGhostCells);
        var isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;
        var areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, regions_2.TableLoadingOption.ROW_HEADERS);
        var areGhostRowsVisible = fillBodyWithGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);
        return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);
    };
    Table.prototype.shouldDisableHorizontalScroll = function () {
        var fillBodyWithGhostCells = this.props.fillBodyWithGhostCells;
        var viewportRect = this.state.viewportRect;
        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect, fillBodyWithGhostCells);
        var isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;
        var areGhostColumnsVisible = fillBodyWithGhostCells && this.grid.isGhostIndex(0, columnIndices.columnIndexEnd);
        var areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, regions_2.TableLoadingOption.COLUMN_HEADERS);
        return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);
    };
    Table.prototype.maybeScrollTableIntoView = function () {
        var viewportRect = this.state.viewportRect;
        var tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);
        var tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);
        var nextScrollTop = (tableBottom < viewportRect.top + viewportRect.height)
            ? Math.max(0, tableBottom - viewportRect.height)
            : viewportRect.top;
        var nextScrollLeft = (tableRight < viewportRect.left + viewportRect.width)
            ? Math.max(0, tableRight - viewportRect.width)
            : viewportRect.left;
        this.syncViewportPosition(nextScrollLeft, nextScrollTop);
    };
    Table.prototype.getColumnProps = function (columnIndex) {
        var column = this.childrenArray[columnIndex];
        return column.props;
    };
    Table.prototype.isGuidesShowing = function () {
        return this.state.verticalGuides != null || this.state.horizontalGuides != null;
    };
    Table.prototype.isSelectionModeEnabled = function (selectionMode) {
        return this.props.selectionModes.indexOf(selectionMode) >= 0;
    };
    Table.prototype.getEnabledSelectionHandler = function (selectionMode) {
        if (!this.isSelectionModeEnabled(selectionMode)) {
            // If the selection mode isn't enabled, return a callback that
            // will clear the selection. For example, if row selection is
            // disabled, clicking on the row header will clear the table's
            // selection. If all selection modes are enabled, clicking on the
            // same region twice will clear the selection.
            return this.clearSelection;
        }
        else {
            return this.handleSelection;
        }
    };
    Table.prototype.invalidateGrid = function () {
        this.grid = null;
    };
    Table.prototype.validateGrid = function () {
        if (this.grid == null) {
            var _a = this.props, defaultRowHeight = _a.defaultRowHeight, defaultColumnWidth = _a.defaultColumnWidth;
            var _b = this.state, rowHeights = _b.rowHeights, columnWidths = _b.columnWidths;
            this.grid = new grid_1.Grid(rowHeights, columnWidths, grid_1.Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);
            this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);
        }
    };
    /**
     * Renders a `RegionLayer`, applying styles to the regions using the
     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so
     * the `IRegionStyler` should be a new instance on every render if we
     * intend to redraw the region layer.
     */
    Table.prototype.maybeRenderRegions = function (getRegionStyle, quadrantType) {
        if (this.isGuidesShowing() && !this.state.isReordering) {
            // we want to show guides *and* the selection styles when reordering rows or columns
            return undefined;
        }
        var regionGroups = regions_2.Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);
        return regionGroups.map(function (regionGroup, index) {
            var regionStyles = regionGroup.regions.map(function (region) { return getRegionStyle(region, quadrantType); });
            return (React.createElement(regions_1.RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, regionStyles: regionStyles }));
        });
    };
    Table.prototype.maybeRenderCopyHotkey = function () {
        var getCellClipboardData = this.props.getCellClipboardData;
        if (getCellClipboardData != null) {
            return (React.createElement(core_2.Hotkey, { key: "copy-hotkey", label: "Copy selected table cells", group: "Table", combo: "mod+c", onKeyDown: this.handleCopy }));
        }
        else {
            return undefined;
        }
    };
    Table.prototype.maybeRenderFocusHotkeys = function () {
        var enableFocus = this.props.enableFocus;
        if (enableFocus != null) {
            return [
                React.createElement(core_2.Hotkey, { key: "move left", label: "Move focus cell left", group: "Table", combo: "left", onKeyDown: this.handleFocusMoveLeft }),
                React.createElement(core_2.Hotkey, { key: "move right", label: "Move focus cell right", group: "Table", combo: "right", onKeyDown: this.handleFocusMoveRight }),
                React.createElement(core_2.Hotkey, { key: "move up", label: "Move focus cell up", group: "Table", combo: "up", onKeyDown: this.handleFocusMoveUp }),
                React.createElement(core_2.Hotkey, { key: "move down", label: "Move focus cell down", group: "Table", combo: "down", onKeyDown: this.handleFocusMoveDown }),
                React.createElement(core_2.Hotkey, { key: "move tab", label: "Move focus cell tab", group: "Table", combo: "tab", onKeyDown: this.handleFocusMoveRightInternal }),
                React.createElement(core_2.Hotkey, { key: "move shift-tab", label: "Move focus cell shift tab", group: "Table", combo: "shift+tab", onKeyDown: this.handleFocusMoveLeftInternal }),
                React.createElement(core_2.Hotkey, { key: "move enter", label: "Move focus cell enter", group: "Table", combo: "enter", onKeyDown: this.handleFocusMoveDownInternal }),
                React.createElement(core_2.Hotkey, { key: "move shift-enter", label: "Move focus cell shift enter", group: "Table", combo: "shift+enter", onKeyDown: this.handleFocusMoveUpInternal }),
            ];
        }
        else {
            return [];
        }
    };
    Table.prototype.maybeRenderSelectAllHotkey = function () {
        if (this.isSelectionModeEnabled(regions_2.RegionCardinality.FULL_TABLE)) {
            return (React.createElement(core_2.Hotkey, { key: "select-all-hotkey", label: "Select all", group: "Table", combo: "mod+a", onKeyDown: this.handleSelectAllHotkey }));
        }
        else {
            return undefined;
        }
    };
    Table.prototype.syncViewportPosition = function (nextScrollLeft, nextScrollTop) {
        var viewportRect = this.state.viewportRect;
        var didScrollTopChange = nextScrollTop !== viewportRect.top;
        var didScrollLeftChange = nextScrollLeft !== viewportRect.left;
        if (didScrollTopChange || didScrollLeftChange) {
            // we need to modify the scroll container explicitly for the viewport to shift. in so
            // doing, we add the size of the header elements, which are not technically part of the
            // "grid" concept (the grid only consists of body cells at present).
            if (didScrollTopChange) {
                var topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;
                this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;
            }
            if (didScrollLeftChange) {
                var leftCorrection = this.shouldDisableHorizontalScroll() ? 0 : this.rowHeaderElement.clientWidth;
                this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;
            }
            var nextViewportRect = new rect_1.Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);
            this.updateViewportRect(nextViewportRect);
        }
    };
    Table.prototype.updateLocator = function () {
        var rowHeaderWidth = this.rowHeaderElement == null ? 0 : this.rowHeaderElement.getBoundingClientRect().width;
        var columnHeaderHeight = this.columnHeaderElement == null ? 0 : this.columnHeaderElement.getBoundingClientRect().height;
        this.locator.setGrid(this.grid)
            .setNumFrozenRows(this.getNumFrozenRowsClamped())
            .setNumFrozenColumns(this.getNumFrozenColumnsClamped())
            .setRowHeaderWidth(rowHeaderWidth)
            .setColumnHeaderHeight(columnHeaderHeight);
    };
    Table.prototype.invokeOnVisibleCellsChangeCallback = function (viewportRect) {
        var columnIndices = this.grid.getColumnIndicesInRect(viewportRect);
        var rowIndices = this.grid.getRowIndicesInRect(viewportRect);
        core_1.Utils.safeInvoke(this.props.onVisibleCellsChange, rowIndices, columnIndices);
    };
    Table.prototype.getNumFrozenColumnsClamped = function (props) {
        if (props === void 0) { props = this.props; }
        var numFrozenColumns = props.numFrozenColumns;
        var numColumns = React.Children.count(props.children);
        return utils_1.Utils.clamp(numFrozenColumns, 0, numColumns);
    };
    Table.prototype.getNumFrozenRowsClamped = function (props) {
        if (props === void 0) { props = this.props; }
        var numFrozenRows = props.numFrozenRows, numRows = props.numRows;
        return utils_1.Utils.clamp(numFrozenRows, 0, numRows);
    };
    return Table;
}(core_1.AbstractComponent));
Table.defaultProps = {
    allowMultipleSelection: true,
    defaultColumnWidth: 150,
    defaultRowHeight: 20,
    enableFocus: false,
    fillBodyWithGhostCells: false,
    isRowHeaderShown: true,
    loadingOptions: [],
    minColumnWidth: 50,
    minRowHeight: 20,
    numRows: 0,
    renderMode: renderMode_1.RenderMode.BATCH,
    renderRowHeader: rowHeader_1.renderDefaultRowHeader,
    selectionModes: regions_2.SelectionModes.ALL,
};
Table.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [
    "selectedRegions",
];
Table.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST = [
    "selectedRegions",
    "viewportRect",
];
Table = Table_1 = tslib_1.__decorate([
    core_2.HotkeysTarget
], Table);
exports.Table = Table;
var Table_1;

//# sourceMappingURL=table.js.map
