/**
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var React = require("react");
var Classes = require("../common/classes");
var utils_1 = require("../common/utils");
var tableQuadrant_1 = require("./tableQuadrant");
var TableQuadrantStack = (function (_super) {
    tslib_1.__extends(TableQuadrantStack, _super);
    function TableQuadrantStack(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.quadrantRefs = (_a = {},
            _a[tableQuadrant_1.QuadrantType.MAIN] = {},
            _a[tableQuadrant_1.QuadrantType.TOP] = {},
            _a[tableQuadrant_1.QuadrantType.LEFT] = {},
            _a[tableQuadrant_1.QuadrantType.TOP_LEFT] = {},
            _a);
        _this.quadrantRefHandlers = (_b = {},
            _b[tableQuadrant_1.QuadrantType.MAIN] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.MAIN),
            _b[tableQuadrant_1.QuadrantType.TOP] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.TOP),
            _b[tableQuadrant_1.QuadrantType.LEFT] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.LEFT),
            _b[tableQuadrant_1.QuadrantType.TOP_LEFT] = _this.generateQuadrantRefHandlers(tableQuadrant_1.QuadrantType.TOP_LEFT),
            _b);
        // this flag helps us avoid redundant work in the MAIN quadrant's onScroll callback, if the
        // callback was triggered from a manual scrollTop/scrollLeft update within an onWheel.
        _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
        // Quadrant-specific renderers
        // ===========================
        // Menu
        _this.renderMainQuadrantMenu = function () {
            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].menu);
        };
        _this.renderTopQuadrantMenu = function () {
            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].menu);
        };
        _this.renderLeftQuadrantMenu = function () {
            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].menu);
        };
        _this.renderTopLeftQuadrantMenu = function () {
            return _this.props.renderMenu(_this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].menu);
        };
        // Column header
        _this.renderMainQuadrantColumnHeader = function (showFrozenColumnsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].columnHeader;
            var resizeHandler = _this.handleColumnResizeGuideMain;
            var reorderingHandler = _this.handleColumnsReorderingMain;
            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
        };
        _this.renderTopQuadrantColumnHeader = function (showFrozenColumnsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].columnHeader;
            var resizeHandler = _this.handleColumnResizeGuideTop;
            var reorderingHandler = _this.handleColumnsReorderingTop;
            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
        };
        _this.renderLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].columnHeader;
            var resizeHandler = _this.handleColumnResizeGuideLeft;
            var reorderingHandler = _this.handleColumnsReorderingLeft;
            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
        };
        _this.renderTopLeftQuadrantColumnHeader = function (showFrozenColumnsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].columnHeader;
            var resizeHandler = _this.handleColumnResizeGuideTopLeft;
            var reorderingHandler = _this.handleColumnsReorderingTopLeft;
            return _this.props.renderColumnHeader(refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly);
        };
        // Row header
        _this.renderMainQuadrantRowHeader = function (showFrozenRowsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].rowHeader;
            var resizeHandler = _this.handleRowResizeGuideMain;
            var reorderingHandler = _this.handleRowsReorderingMain;
            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
        };
        _this.renderTopQuadrantRowHeader = function (showFrozenRowsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].rowHeader;
            var resizeHandler = _this.handleRowResizeGuideTop;
            var reorderingHandler = _this.handleRowsReorderingTop;
            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
        };
        _this.renderLeftQuadrantRowHeader = function (showFrozenRowsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].rowHeader;
            var resizeHandler = _this.handleRowResizeGuideLeft;
            var reorderingHandler = _this.handleRowsReorderingLeft;
            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
        };
        _this.renderTopLeftQuadrantRowHeader = function (showFrozenRowsOnly) {
            var refHandler = _this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].rowHeader;
            var resizeHandler = _this.handleRowResizeGuideTopLeft;
            var reorderingHandler = _this.handleRowsReorderingTopLeft;
            return _this.props.renderRowHeader(refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly);
        };
        // Event handlers
        // ==============
        // Scrolling
        // ---------
        // use the more generic "scroll" event for the main quadrant, which captures both click+dragging
        // on the scrollbar and trackpad/mousewheel gestures
        _this.handleMainQuadrantScroll = function (event) {
            if (_this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback) {
                _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
                return;
            }
            var nextScrollTop = _this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer.scrollTop;
            var nextScrollLeft = _this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer.scrollLeft;
            _this.quadrantRefs[tableQuadrant_1.QuadrantType.LEFT].scrollContainer.scrollTop = nextScrollTop;
            _this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].scrollContainer.scrollLeft = nextScrollLeft;
            _this.props.onScroll(event);
        };
        // recall that we've already invoked event.preventDefault() when defining the throttled versions
        // of these onWheel callbacks, so now we need to manually update the affected quadrant's scroll
        // position too.
        _this.handleWheel = function (event) {
            _this.handleDirectionalWheel("horizontal", event.deltaX, tableQuadrant_1.QuadrantType.MAIN, [tableQuadrant_1.QuadrantType.TOP]);
            _this.handleDirectionalWheel("vertical", event.deltaY, tableQuadrant_1.QuadrantType.MAIN, [tableQuadrant_1.QuadrantType.LEFT]);
            _this.props.onScroll(event);
        };
        // Resizing
        // --------
        // Columns
        _this.handleColumnResizeGuideMain = function (verticalGuides) {
            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.MAIN);
        };
        _this.handleColumnResizeGuideTop = function (verticalGuides) {
            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP);
        };
        _this.handleColumnResizeGuideLeft = function (verticalGuides) {
            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.LEFT);
        };
        _this.handleColumnResizeGuideTopLeft = function (verticalGuides) {
            _this.invokeColumnResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP_LEFT);
        };
        _this.invokeColumnResizeHandler = function (verticalGuides, quadrantType) {
            var adjustedGuides = _this.adjustVerticalGuides(verticalGuides, quadrantType);
            _this.props.handleColumnResizeGuide(adjustedGuides);
        };
        // Rows
        _this.handleRowResizeGuideMain = function (verticalGuides) {
            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.MAIN);
        };
        _this.handleRowResizeGuideTop = function (verticalGuides) {
            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP);
        };
        _this.handleRowResizeGuideLeft = function (verticalGuides) {
            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.LEFT);
        };
        _this.handleRowResizeGuideTopLeft = function (verticalGuides) {
            _this.invokeRowResizeHandler(verticalGuides, tableQuadrant_1.QuadrantType.TOP_LEFT);
        };
        _this.invokeRowResizeHandler = function (verticalGuides, quadrantType) {
            var adjustedGuides = _this.adjustHorizontalGuides(verticalGuides, quadrantType);
            _this.props.handleRowResizeGuide(adjustedGuides);
        };
        // Reordering
        // ----------
        // Columns
        _this.handleColumnsReorderingMain = function (oldIndex, newIndex, length) {
            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleColumnsReorderingTop = function (oldIndex, newIndex, length) {
            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleColumnsReorderingLeft = function (oldIndex, newIndex, length) {
            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleColumnsReorderingTopLeft = function (oldIndex, newIndex, length) {
            _this.invokeColumnsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.invokeColumnsReorderingHandler = function (oldIndex, newIndex, length) {
            var guideIndex = utils_1.Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);
            var leftOffset = _this.props.grid.getCumulativeWidthBefore(guideIndex);
            var quadrantType = guideIndex <= _this.props.numFrozenColumns ? tableQuadrant_1.QuadrantType.TOP_LEFT : tableQuadrant_1.QuadrantType.TOP;
            var verticalGuides = _this.adjustVerticalGuides([leftOffset], quadrantType);
            _this.props.handleColumnsReordering(verticalGuides);
        };
        // Rows
        _this.handleRowsReorderingMain = function (oldIndex, newIndex, length) {
            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleRowsReorderingTop = function (oldIndex, newIndex, length) {
            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleRowsReorderingLeft = function (oldIndex, newIndex, length) {
            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.handleRowsReorderingTopLeft = function (oldIndex, newIndex, length) {
            _this.invokeRowsReorderingHandler(oldIndex, newIndex, length);
        };
        _this.invokeRowsReorderingHandler = function (oldIndex, newIndex, length) {
            var guideIndex = utils_1.Utils.reorderedIndexToGuideIndex(oldIndex, newIndex, length);
            var topOffset = _this.props.grid.getCumulativeHeightBefore(guideIndex);
            var quadrantType = guideIndex <= _this.props.numFrozenRows ? tableQuadrant_1.QuadrantType.TOP_LEFT : tableQuadrant_1.QuadrantType.LEFT;
            var horizontalGuides = _this.adjustHorizontalGuides([topOffset], quadrantType);
            _this.props.handleRowsReordering(horizontalGuides);
        };
        _this.handleDirectionalWheel = function (direction, delta, quadrantType, quadrantTypesToSync) {
            var isHorizontal = direction === "horizontal";
            var scrollKey = isHorizontal
                ? "scrollLeft"
                : "scrollTop";
            var isScrollDisabled = isHorizontal
                ? _this.props.isHorizontalScrollDisabled
                : _this.props.isVerticalScrollDisabled;
            if (!isScrollDisabled) {
                _this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = true;
                // sync the corresponding scroll position of all dependent quadrants
                var nextScrollPosition_1 = _this.quadrantRefs[quadrantType].scrollContainer[scrollKey] + delta;
                _this.quadrantRefs[quadrantType].scrollContainer[scrollKey] = nextScrollPosition_1;
                quadrantTypesToSync.forEach(function (quadrantTypeToSync) {
                    _this.quadrantRefs[quadrantTypeToSync].scrollContainer[scrollKey] = nextScrollPosition_1;
                });
            }
        };
        // a few points here:
        // - we throttle onScroll/onWheel callbacks to making scrolling look more fluid.
        // - we declare throttled functions on the component instance, since they're stateful.
        // - "wheel"-ing triggers super-fluid onScroll behavior by default, but relying on that
        //   causes sync'd quadrants to lag behind. thus, we preventDefault for onWheel and instead
        //   manually update all relevant quadrants using event.delta{X,Y} later, in the callback.
        //   this keeps every sync'd quadrant visually aligned in each animation frame.
        _this.throttledHandleMainQuadrantScroll = core_1.Utils.throttleReactEventCallback(_this.handleMainQuadrantScroll);
        _this.throttledHandleWheel = core_1.Utils.throttleReactEventCallback(_this.handleWheel, { preventDefault: true });
        return _this;
        var _a, _b;
    }
    /**
     * Scroll the main quadrant to the specified scroll offset, keeping all other quadrants in sync.
     */
    TableQuadrantStack.prototype.scrollToPosition = function (scrollLeft, scrollTop) {
        var scrollContainer = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer;
        this.wasMainQuadrantScrollChangedFromOtherOnWheelCallback = false;
        // this will trigger the main quadrant's scroll callback below
        scrollContainer.scrollLeft = scrollLeft;
        scrollContainer.scrollTop = scrollTop;
    };
    TableQuadrantStack.prototype.componentDidMount = function () {
        this.emitRefs();
        this.syncQuadrantSizes();
        this.syncQuadrantMenuElementWidths();
        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.findColumnHeader(tableQuadrant_1.QuadrantType.MAIN));
        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.findRowHeader(tableQuadrant_1.QuadrantType.MAIN));
    };
    TableQuadrantStack.prototype.componentDidUpdate = function () {
        this.emitRefs();
        this.syncQuadrantSizes();
        this.syncQuadrantMenuElementWidths();
        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.findColumnHeader(tableQuadrant_1.QuadrantType.MAIN));
        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.findRowHeader(tableQuadrant_1.QuadrantType.MAIN));
    };
    TableQuadrantStack.prototype.render = function () {
        var _a = this.props, grid = _a.grid, isRowHeaderShown = _a.isRowHeaderShown, renderBody = _a.renderBody;
        return (React.createElement("div", { className: Classes.TABLE_QUADRANT_STACK },
            React.createElement(tableQuadrant_1.TableQuadrant, { bodyRef: this.props.bodyRef, grid: grid, isRowHeaderShown: isRowHeaderShown, onScroll: this.throttledHandleMainQuadrantScroll, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].quadrant, quadrantType: tableQuadrant_1.QuadrantType.MAIN, renderBody: renderBody, renderColumnHeader: this.renderMainQuadrantColumnHeader, renderMenu: this.renderMainQuadrantMenu, renderRowHeader: this.renderMainQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.MAIN].scrollContainer }),
            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].quadrant, quadrantType: tableQuadrant_1.QuadrantType.TOP, renderBody: renderBody, renderColumnHeader: this.renderTopQuadrantColumnHeader, renderMenu: this.renderTopQuadrantMenu, renderRowHeader: this.renderTopQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP].scrollContainer }),
            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].quadrant, quadrantType: tableQuadrant_1.QuadrantType.LEFT, renderBody: renderBody, renderColumnHeader: this.renderLeftQuadrantColumnHeader, renderMenu: this.renderLeftQuadrantMenu, renderRowHeader: this.renderLeftQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.LEFT].scrollContainer }),
            React.createElement(tableQuadrant_1.TableQuadrant, { grid: grid, isRowHeaderShown: isRowHeaderShown, onWheel: this.throttledHandleWheel, quadrantRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].quadrant, quadrantType: tableQuadrant_1.QuadrantType.TOP_LEFT, renderBody: renderBody, renderColumnHeader: this.renderTopLeftQuadrantColumnHeader, renderMenu: this.renderTopLeftQuadrantMenu, renderRowHeader: this.renderTopLeftQuadrantRowHeader, scrollContainerRef: this.quadrantRefHandlers[tableQuadrant_1.QuadrantType.TOP_LEFT].scrollContainer })));
    };
    // Ref handlers
    // ============
    TableQuadrantStack.prototype.generateQuadrantRefHandlers = function (quadrantType) {
        var _this = this;
        var reducer = function (agg, key) {
            agg[key] = function (ref) { return _this.quadrantRefs[quadrantType][key] = ref; };
            return agg;
        };
        return ["columnHeader", "menu", "quadrant", "rowHeader", "scrollContainer"].reduce(reducer, {});
    };
    // Emitters
    // ========
    TableQuadrantStack.prototype.emitRefs = function () {
        core_1.Utils.safeInvoke(this.props.columnHeaderRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].columnHeader);
        core_1.Utils.safeInvoke(this.props.quadrantRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].quadrant);
        core_1.Utils.safeInvoke(this.props.rowHeaderRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].rowHeader);
        core_1.Utils.safeInvoke(this.props.scrollContainerRef, this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer);
    };
    // Size syncing
    // ============
    TableQuadrantStack.prototype.syncQuadrantMenuElementWidths = function () {
        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.MAIN);
        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.TOP);
        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.LEFT);
        this.syncQuadrantMenuElementWidth(tableQuadrant_1.QuadrantType.TOP_LEFT);
    };
    TableQuadrantStack.prototype.syncQuadrantMenuElementWidth = function (quadrantType) {
        var mainQuadrantMenu = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].menu;
        var mainQuadrantRowHeader = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].rowHeader;
        var quadrantMenu = this.quadrantRefs[quadrantType].menu;
        // the main quadrant menu informs the size of every other quadrant menu
        if (mainQuadrantMenu != null && mainQuadrantRowHeader != null && quadrantMenu != null) {
            var width = mainQuadrantRowHeader.getBoundingClientRect().width;
            quadrantMenu.style.width = width + "px";
            // no need to use the main quadrant's menu to set its *own* height
            if (quadrantType !== tableQuadrant_1.QuadrantType.MAIN) {
                var height = mainQuadrantMenu.getBoundingClientRect().height;
                quadrantMenu.style.height = height + "px";
            }
        }
    };
    TableQuadrantStack.prototype.syncQuadrantSizes = function () {
        var mainQuadrantScrollElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN].scrollContainer;
        var topQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].quadrant;
        var topQuadrantRowHeaderElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP].rowHeader;
        var leftQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.LEFT].quadrant;
        var topLeftQuadrantElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP_LEFT].quadrant;
        var topLeftQuadrantRowHeaderElement = this.quadrantRefs[tableQuadrant_1.QuadrantType.TOP_LEFT].rowHeader;
        var _a = this.props, grid = _a.grid, numFrozenColumns = _a.numFrozenColumns, numFrozenRows = _a.numFrozenRows;
        // if there are no frozen rows or columns, we still want the quadrant to be 1px bigger to
        // reveal the header border.
        var BORDER_WIDTH_CORRECTION = 1;
        var leftQuadrantGridContentWidth = numFrozenColumns > 0
            ? grid.getCumulativeWidthAt(numFrozenColumns - 1)
            : BORDER_WIDTH_CORRECTION;
        var topQuadrantGridContentHeight = numFrozenRows > 0
            ? grid.getCumulativeHeightAt(numFrozenRows - 1)
            : BORDER_WIDTH_CORRECTION;
        // all menus are the same size, so arbitrarily use the one from the main quadrant.
        // assumes that the menu element width has already been sync'd after the last render
        var _b = this.quadrantRefs[tableQuadrant_1.QuadrantType.MAIN], rowHeader = _b.rowHeader, columnHeader = _b.columnHeader;
        var rowHeaderWidth = rowHeader == null ? 0 : rowHeader.getBoundingClientRect().width;
        var columnHeaderHeight = columnHeader == null ? 0 : columnHeader.getBoundingClientRect().height;
        // no need to sync the main quadrant, because it fills the entire viewport
        topQuadrantElement.style.height = topQuadrantGridContentHeight + columnHeaderHeight + "px";
        leftQuadrantElement.style.width = leftQuadrantGridContentWidth + rowHeaderWidth + "px";
        topLeftQuadrantElement.style.width = leftQuadrantGridContentWidth + rowHeaderWidth + "px";
        topLeftQuadrantElement.style.height = topQuadrantGridContentHeight + columnHeaderHeight + "px";
        // resize the top and left quadrants to keep the main quadrant's scrollbar visible
        var scrollbarWidth = mainQuadrantScrollElement.offsetWidth - mainQuadrantScrollElement.clientWidth;
        var scrollbarHeight = mainQuadrantScrollElement.offsetHeight - mainQuadrantScrollElement.clientHeight;
        topQuadrantElement.style.right = scrollbarWidth + "px";
        leftQuadrantElement.style.bottom = scrollbarHeight + "px";
        // resize top and top-left quadrant row headers if main quadrant scrolls
        this.maybeSyncRowHeaderSize(topQuadrantRowHeaderElement, rowHeaderWidth);
        this.maybeSyncRowHeaderSize(topLeftQuadrantRowHeaderElement, rowHeaderWidth);
    };
    TableQuadrantStack.prototype.maybeSyncRowHeaderSize = function (rowHeaderElement, width) {
        if (rowHeaderElement == null) {
            return;
        }
        var selector = "." + Classes.TABLE_ROW_HEADERS_CELLS_CONTAINER;
        // this child element dictates the width of all row-header cells
        var elementToResize = rowHeaderElement.querySelector(selector);
        elementToResize.style.width = width + "px";
    };
    // Helpers
    // =======
    TableQuadrantStack.prototype.findColumnHeader = function (quadrantType) {
        var quadrantElement = this.quadrantRefs[quadrantType].quadrant;
        return quadrantElement.querySelector("." + Classes.TABLE_COLUMN_HEADERS);
    };
    TableQuadrantStack.prototype.findRowHeader = function (quadrantType) {
        var quadrantElement = this.quadrantRefs[quadrantType].quadrant;
        return quadrantElement.querySelector("." + Classes.TABLE_ROW_HEADERS);
    };
    // Resizing
    TableQuadrantStack.prototype.adjustVerticalGuides = function (verticalGuides, quadrantType) {
        var scrollAmount = this.quadrantRefs[quadrantType].scrollContainer.scrollLeft;
        var rowHeaderWidth = this.getRowHeaderWidth(quadrantType);
        var adjustedVerticalGuides = verticalGuides != null
            ? verticalGuides.map(function (verticalGuide) { return verticalGuide - scrollAmount + rowHeaderWidth; })
            : verticalGuides;
        return adjustedVerticalGuides;
    };
    TableQuadrantStack.prototype.adjustHorizontalGuides = function (horizontalGuides, quadrantType) {
        var scrollAmount = this.quadrantRefs[quadrantType].scrollContainer.scrollTop;
        var columnHeaderHeight = this.quadrantRefs[quadrantType].columnHeader.clientHeight;
        var adjustedHorizontalGuides = horizontalGuides != null
            ? horizontalGuides.map(function (horizontalGuide) { return horizontalGuide - scrollAmount + columnHeaderHeight; })
            : horizontalGuides;
        return adjustedHorizontalGuides;
    };
    TableQuadrantStack.prototype.getRowHeaderWidth = function (quadrantType) {
        // unlike the column header, the row header can be toggled, so we need to handle the case
        // when it's not showing
        var rowHeader = this.quadrantRefs[quadrantType].rowHeader;
        return rowHeader == null ? 0 : rowHeader.clientWidth;
    };
    return TableQuadrantStack;
}(core_1.AbstractComponent));
// we want the user to explicitly pass a quadrantType. define defaultProps as a Partial to avoid
// declaring that and other required props here.
TableQuadrantStack.defaultProps = {
    isHorizontalScrollDisabled: false,
    isRowHeaderShown: true,
    isVerticalScrollDisabled: false,
};
exports.TableQuadrantStack = TableQuadrantStack;

//# sourceMappingURL=tableQuadrantStack.js.map
