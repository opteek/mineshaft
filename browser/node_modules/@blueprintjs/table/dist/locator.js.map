{"version":3,"sources":["../src/locator.ts"],"names":[],"mappings":"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","file":"locator.js","sourcesContent":["/**\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as Classes from \"./common/classes\";\nimport { Grid } from \"./common/grid\";\nimport { Rect } from \"./common/rect\";\nimport { Utils } from \"./common/utils\";\n\nexport interface ILocator {\n    /**\n     * Returns the width that a column must be to contain all the content of\n     * its cells without truncating or wrapping.\n     */\n    getWidestVisibleCellInColumn: (columnIndex: number) => number;\n\n    /**\n     * Returns the height of the tallest cell in a given column -- specifically,\n     * tallest as in how tall the cell would have to be to display all the content in it\n     */\n    getTallestVisibleCellInColumn: (columnIndex: number) => number;\n\n    /**\n     * Locates a column's index given the client X coordinate. Returns -1 if\n     * the coordinate is not over a column.\n     * If `useMidpoint` is `true`, returns the index of the column whose left\n     * edge is closest, splitting on the midpoint of each column.\n     */\n    convertPointToColumn: (clientX: number, useMidpoint?: boolean) => number;\n\n    /**\n     * Locates a row's index given the client Y coordinate. Returns -1 if\n     * the coordinate is not over a row.\n     * If `useMidpoint` is `true`, returns the index of the row whose top\n     * edge is closest, splitting on the midpoint of each row.\n     */\n    convertPointToRow: (clientY: number, useMidpoint?: boolean) => number;\n\n    /**\n     * Locates a cell's row and column index given the client X\n     * coordinate. Returns -1 if the coordinate is not over a table cell.\n     */\n    convertPointToCell: (clientX: number, clientY: number) => {col: number, row: number};\n}\n\nexport class Locator implements ILocator {\n    private static CELL_HORIZONTAL_PADDING = 10;\n\n    private grid: Grid;\n\n    private rowHeaderWidth = 0;\n    private columnHeaderHeight = 0;\n\n    private numFrozenRows = 0;\n    private numFrozenColumns = 0;\n\n    public constructor(\n        private tableElement: HTMLElement,\n        private bodyElement: HTMLElement,\n    ) {\n        // empty constructor\n    }\n\n    // Setters\n    // =======\n\n    public setGrid(grid: Grid) {\n        this.grid = grid;\n        return this;\n    }\n\n    public setNumFrozenRows(numFrozenRows: number) {\n        this.numFrozenRows = numFrozenRows;\n        return this;\n    }\n\n    public setNumFrozenColumns(numFrozenColumns: number) {\n        this.numFrozenColumns = numFrozenColumns;\n        return this;\n    }\n\n    public setColumnHeaderHeight(columnHeaderHeight: number) {\n        this.columnHeaderHeight = columnHeaderHeight;\n        return this;\n    }\n\n    public setRowHeaderWidth(rowHeaderWidth: number) {\n        this.rowHeaderWidth = rowHeaderWidth;\n        return this;\n    }\n\n    // Getters\n    // =======\n\n    public getViewportRect() {\n        return new Rect(\n            this.bodyElement.scrollLeft,\n            this.bodyElement.scrollTop,\n            this.bodyElement.clientWidth,\n            this.bodyElement.clientHeight,\n        );\n    }\n\n    public getWidestVisibleCellInColumn(columnIndex: number): number {\n        const cells = this.tableElement.getElementsByClassName(Classes.columnCellIndexClass(columnIndex));\n        let max = 0;\n        for (let i = 0; i < cells.length; i++) {\n            const contentWidth = Utils.measureElementTextContent(cells.item(i)).width;\n            const cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;\n            if (cellWidth > max) {\n                max = cellWidth;\n            }\n        }\n        return max;\n    }\n\n    public getTallestVisibleCellInColumn(columnIndex: number): number {\n        const cells = this.tableElement\n            .getElementsByClassName(`${Classes.columnCellIndexClass(columnIndex)} ${Classes.TABLE_CELL}`);\n        let max = 0;\n        for (let i = 0; i < cells.length; i++) {\n            const cellValue = cells.item(i).querySelector(`.${Classes.TABLE_TRUNCATED_VALUE}`);\n            const cellTruncatedFormatText = cells.item(i).querySelector(`.${Classes.TABLE_TRUNCATED_FORMAT_TEXT}`);\n            const cellTruncatedText = cells.item(i).querySelector(`.${Classes.TABLE_TRUNCATED_TEXT}`);\n            let height = 0;\n            if (cellValue != null) {\n                height = cellValue.scrollHeight;\n            } else if (cellTruncatedFormatText != null) {\n                height = cellTruncatedFormatText.scrollHeight;\n            } else if (cellTruncatedText != null) {\n                height = cellTruncatedText.scrollHeight;\n            } else {\n                // it's not anything we recognize, just use the current height of the cell\n                height = cells.item(i).scrollHeight;\n            }\n            if (height > max) {\n                max = height;\n            }\n        }\n        return max;\n    }\n\n    // Converters\n    // ==========\n\n    public convertPointToColumn(clientX: number, useMidpoint?: boolean): number {\n        const tableRect = this.getTableRect();\n        if (!tableRect.containsX(clientX)) {\n            return -1;\n        }\n        const gridX = this.toGridX(clientX);\n        const limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;\n        const lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;\n        return Utils.binarySearch(gridX, limit, lookupFn);\n    }\n\n    public convertPointToRow(clientY: number, useMidpoint?: boolean): number {\n        const tableRect = this.getTableRect();\n        if (!tableRect.containsY(clientY)) {\n            return -1;\n        }\n        const gridY = this.toGridY(clientY);\n        const limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;\n        const lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;\n        return Utils.binarySearch(gridY, limit, lookupFn);\n    }\n\n    public convertPointToCell(clientX: number, clientY: number) {\n        const gridX = this.toGridX(clientX);\n        const gridY = this.toGridY(clientY);\n        const col = Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n        const row = Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n        return {col, row};\n    }\n\n    // Private helpers\n    // ===============\n\n    private getTableRect() {\n        return Rect.wrap(this.tableElement.getBoundingClientRect());\n    }\n\n    private convertCellIndexToClientX = (index: number) => {\n        return this.grid.getCumulativeWidthAt(index);\n    }\n\n    private convertCellMidpointToClientX = (index: number) => {\n        const cellLeft = this.grid.getCumulativeWidthBefore(index);\n        const cellRight = this.grid.getCumulativeWidthAt(index);\n        return (cellLeft + cellRight) / 2;\n    }\n\n    private convertCellIndexToClientY = (index: number) => {\n        return this.grid.getCumulativeHeightAt(index);\n    }\n\n    private convertCellMidpointToClientY = (index: number) => {\n        const cellTop = this.grid.getCumulativeHeightBefore(index);\n        const cellBottom = this.grid.getCumulativeHeightAt(index);\n        return (cellTop + cellBottom) / 2;\n    }\n\n    private toGridX = (clientX: number) => {\n        const tableOffsetFromPageLeft = this.tableElement.getBoundingClientRect().left;\n        const cursorOffsetFromTableLeft = clientX - tableOffsetFromPageLeft;\n        const cursorOffsetFromGridLeft = cursorOffsetFromTableLeft - this.rowHeaderWidth;\n        const scrollOffsetFromTableLeft = this.bodyElement.scrollLeft;\n\n        const isCursorWithinFrozenColumns = this.numFrozenColumns != null\n            && this.numFrozenColumns > 0\n            && cursorOffsetFromGridLeft <= this.grid.getCumulativeWidthBefore(this.numFrozenColumns);\n\n        // the frozen-column region doesn't scroll, so ignore the scroll distance in that case\n        return isCursorWithinFrozenColumns\n            ? cursorOffsetFromGridLeft\n            : cursorOffsetFromGridLeft + scrollOffsetFromTableLeft;\n    }\n\n    private toGridY = (clientY: number) => {\n        const tableOffsetFromPageTop = this.tableElement.getBoundingClientRect().top;\n        const cursorOffsetFromTableTop = clientY - tableOffsetFromPageTop;\n        const cursorOffsetFromGridTop = cursorOffsetFromTableTop - this.columnHeaderHeight;\n        const scrollOffsetFromTableTop = this.bodyElement.scrollTop;\n\n        const isCursorWithinFrozenRows = this.numFrozenRows != null\n            && this.numFrozenRows > 0\n            && cursorOffsetFromGridTop <= this.grid.getCumulativeHeightBefore(this.numFrozenRows);\n\n        return isCursorWithinFrozenRows\n            ? cursorOffsetFromGridTop\n            : cursorOffsetFromGridTop + scrollOffsetFromTableTop;\n    }\n}\n"]}