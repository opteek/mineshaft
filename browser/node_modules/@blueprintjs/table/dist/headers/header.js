/**
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var classNames = require("classnames");
var React = require("react");
var batcher_1 = require("../common/batcher");
var Classes = require("../common/classes");
var utils_1 = require("../common/utils");
var reorderable_1 = require("../interactions/reorderable");
var resizable_1 = require("../interactions/resizable");
var selectable_1 = require("../interactions/selectable");
var regions_1 = require("../regions");
var SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [
    "focusedCell",
    "selectedRegions",
];
var RESET_CELL_KEYS_BLACKLIST = [
    "indexEnd",
    "indexStart",
];
var Header = (function (_super) {
    tslib_1.__extends(Header, _super);
    function Header(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            hasSelectionEnded: false,
        };
        _this.batcher = new batcher_1.Batcher();
        _this.locateClick = function (event) {
            var coord = _this.props.getMouseCoordinate(event);
            _this.activationIndex = _this.props.convertPointToIndex(coord);
            return _this.props.toRegion(_this.activationIndex);
        };
        _this.locateDragForSelection = function (_event, coords, returnEndOnly) {
            if (returnEndOnly === void 0) { returnEndOnly = false; }
            var coord = _this.props.getDragCoordinate(coords.current);
            var indexStart = _this.activationIndex;
            var indexEnd = _this.props.convertPointToIndex(coord);
            return returnEndOnly
                ? _this.props.toRegion(indexEnd)
                : _this.props.toRegion(indexStart, indexEnd);
        };
        _this.locateDragForReordering = function (_event, coords) {
            var coord = _this.props.getDragCoordinate(coords.current);
            var guideIndex = _this.props.convertPointToIndex(coord, true);
            return (guideIndex < 0) ? undefined : guideIndex;
        };
        _this.renderCells = function () {
            var _a = _this.props, indexStart = _a.indexStart, indexEnd = _a.indexEnd;
            _this.batcher.startNewBatch();
            for (var index = indexStart; index <= indexEnd; index++) {
                _this.batcher.addArgsToBatch(index);
            }
            _this.batcher.removeOldAddNew(_this.renderNewCell);
            if (!_this.batcher.isDone()) {
                _this.batcher.idleCallback(function () { return _this.forceUpdate(); });
            }
            return _this.batcher.getList();
        };
        _this.renderNewCell = function (index) {
            var extremaClasses = _this.props.getCellExtremaClasses(index, _this.props.indexEnd);
            var renderer = _this.props.isGhostIndex(index)
                ? _this.props.renderGhostCell
                : _this.renderCell;
            return renderer(index, extremaClasses);
        };
        _this.renderCell = function (index, extremaClasses) {
            var _a = _this.props, getIndexClass = _a.getIndexClass, selectedRegions = _a.selectedRegions;
            var cell = _this.props.renderHeaderCell(index);
            var isLoading = cell.props.loading != null ? cell.props.loading : _this.props.loading;
            var isSelected = _this.props.isCellSelected(index);
            var isEntireCellTargetReorderable = _this.isEntireCellTargetReorderable(isSelected);
            var className = classNames(extremaClasses, (_b = {},
                _b[Classes.TABLE_HEADER_REORDERABLE] = isEntireCellTargetReorderable,
                _b), _this.props.getCellIndexClass(index), cell.props.className);
            var cellProps = (_c = {
                    className: className,
                    index: index
                },
                _c[_this.props.headerCellIsSelectedPropName] = isSelected,
                _c[_this.props.headerCellIsReorderablePropName] = isEntireCellTargetReorderable,
                _c.loading = isLoading,
                _c.reorderHandle = _this.maybeRenderReorderHandle(index),
                _c);
            var modifiedHandleSizeChanged = function (size) { return _this.props.handleSizeChanged(index, size); };
            var modifiedHandleResizeEnd = function (size) { return _this.props.handleResizeEnd(index, size); };
            var modifiedHandleResizeHandleDoubleClick = function () { return _this.props.handleResizeDoubleClick(index); };
            var baseChildren = (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: _this.props.allowMultipleSelection, disabled: isEntireCellTargetReorderable, focusedCell: _this.props.focusedCell, ignoredSelectors: ["." + Classes.TABLE_REORDER_HANDLE_TARGET], key: getIndexClass(index), locateClick: _this.locateClick, locateDrag: _this.locateDragForSelection, onFocus: _this.props.onFocus, onSelection: _this.handleDragSelectableSelection, onSelectionEnd: _this.handleDragSelectableSelectionEnd, selectedRegions: selectedRegions, selectedRegionTransform: _this.props.selectedRegionTransform },
                React.createElement(resizable_1.Resizable, { isResizable: _this.props.isResizable, maxSize: _this.props.maxSize, minSize: _this.props.minSize, onDoubleClick: modifiedHandleResizeHandleDoubleClick, onLayoutLock: _this.props.onLayoutLock, onResizeEnd: modifiedHandleResizeEnd, onSizeChanged: modifiedHandleSizeChanged, orientation: _this.props.resizeOrientation, size: _this.props.getCellSize(index) }, React.cloneElement(cell, cellProps))));
            return _this.isReorderHandleEnabled()
                ? baseChildren // reordering will be handled by interacting with the reorder handle
                : _this.wrapInDragReorderable(index, baseChildren, !isEntireCellTargetReorderable);
            var _b, _c;
        };
        _this.handleDragSelectableSelection = function (selectedRegions) {
            _this.props.onSelection(selectedRegions);
            _this.setState({ hasSelectionEnded: false });
        };
        _this.handleDragSelectableSelectionEnd = function () {
            _this.activationIndex = null; // not strictly required, but good practice
            _this.setState({ hasSelectionEnded: true });
        };
        _this.isEntireCellTargetReorderable = function (isSelected) {
            var selectedRegions = _this.props.selectedRegions;
            // although reordering may be generally enabled for this row/column (via props.isReorderable), the
            // row/column shouldn't actually become reorderable from a user perspective until a few other
            // conditions are true:
            return _this.props.isReorderable
                && isSelected
                && _this.state.hasSelectionEnded
                && regions_1.Regions.getRegionCardinality(selectedRegions[0]) === _this.props.fullRegionCardinality
                && selectedRegions.length === 1
                && !_this.isReorderHandleEnabled();
        };
        return _this;
    }
    Header.prototype.componentDidMount = function () {
        if (this.props.selectedRegions != null && this.props.selectedRegions.length > 0) {
            // we already have a selection defined, so we'll want to enable reordering interactions
            // right away if other criteria are satisfied too.
            this.setState({ hasSelectionEnded: true });
        }
    };
    Header.prototype.componentWillUnmount = function () {
        this.batcher.cancelOutstandingCallback();
    };
    Header.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.selectedRegions != null && nextProps.selectedRegions.length > 0) {
            this.setState({ hasSelectionEnded: true });
        }
        else {
            this.setState({ hasSelectionEnded: false });
        }
    };
    Header.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return !utils_1.Utils.shallowCompareKeys(this.state, nextState)
            || !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: SHALLOW_COMPARE_PROP_KEYS_BLACKLIST })
            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, SHALLOW_COMPARE_PROP_KEYS_BLACKLIST);
    };
    Header.prototype.componentWillUpdate = function (nextProps, nextState) {
        var resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };
        var shouldResetBatcher = !utils_1.Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);
        shouldResetBatcher = shouldResetBatcher || !utils_1.Utils.shallowCompareKeys(this.state, nextState);
        if (shouldResetBatcher) {
            this.batcher.reset();
        }
    };
    Header.prototype.render = function () {
        return this.props.wrapCells(this.renderCells());
    };
    Header.prototype.isReorderHandleEnabled = function () {
        // the reorder handle can only appear in the column interaction bar
        return this.isColumnHeader() && this.props.isReorderable;
    };
    Header.prototype.maybeRenderReorderHandle = function (index) {
        return !this.isReorderHandleEnabled()
            ? undefined
            : this.wrapInDragReorderable(index, React.createElement("div", { className: Classes.TABLE_REORDER_HANDLE_TARGET },
                React.createElement("div", { className: Classes.TABLE_REORDER_HANDLE },
                    React.createElement("span", { className: classNames(core_1.Classes.ICON_STANDARD, core_1.IconClasses.DRAG_HANDLE_VERTICAL) }))));
    };
    Header.prototype.isColumnHeader = function () {
        return this.props.fullRegionCardinality === regions_1.RegionCardinality.FULL_COLUMNS;
    };
    Header.prototype.wrapInDragReorderable = function (index, children, disabled) {
        return (React.createElement(reorderable_1.DragReorderable, { disabled: disabled, key: this.props.getIndexClass(index), locateClick: this.locateClick, locateDrag: this.locateDragForReordering, onReordered: this.props.onReordered, onReordering: this.props.onReordering, onSelection: this.props.onSelection, onFocus: this.props.onFocus, selectedRegions: this.props.selectedRegions, toRegion: this.props.toRegion }, children));
    };
    return Header;
}(React.Component));
exports.Header = Header;

//# sourceMappingURL=header.js.map
