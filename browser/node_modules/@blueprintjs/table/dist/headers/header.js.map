{"version":3,"sources":["../src/headers/header.tsx"],"names":[],"mappings":"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","file":"header.js","sourcesContent":["/**\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { Classes as CoreClasses, IconClasses } from \"@blueprintjs/core\";\nimport * as classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { Grid } from \"../common\";\nimport { Batcher } from \"../common/batcher\";\nimport { IFocusedCellCoordinates } from \"../common/cell\";\nimport * as Classes from \"../common/classes\";\nimport { Utils } from \"../common/utils\";\nimport { IClientCoordinates, ICoordinateData } from \"../interactions/draggable\";\nimport { DragReorderable, IReorderableProps } from \"../interactions/reorderable\";\nimport { Resizable } from \"../interactions/resizable\";\nimport { ILockableLayout, Orientation } from \"../interactions/resizeHandle\";\nimport { DragSelectable, ISelectableProps } from \"../interactions/selectable\";\nimport { ILocator } from \"../locator\";\nimport { IRegion, RegionCardinality, Regions } from \"../regions\";\nimport { IHeaderCellProps } from \"./headerCell\";\n\nexport type IHeaderCellRenderer = (index: number) => React.ReactElement<IHeaderCellProps>;\n\nexport interface IHeaderProps extends ILockableLayout, IReorderableProps, ISelectableProps {\n    /**\n     * The currently focused cell.\n     */\n    focusedCell?: IFocusedCellCoordinates;\n\n    /**\n     * The grid computes sizes of cells, rows, or columns from the\n     * configurable `columnWidths` and `rowHeights`.\n     */\n    grid: Grid;\n\n    /**\n     * Enables/disables the reordering interaction.\n     * @internal\n     * @default false\n     */\n    isReorderable?: boolean;\n\n    /**\n     * Enables/disables the resize interaction.\n     * @default false\n     */\n    isResizable?: boolean;\n\n    /**\n     * Locates the row/column/cell given a mouse event.\n     */\n    locator: ILocator;\n\n    /**\n     * If true, all header cells render their loading state except for those\n     * who have their `loading` prop explicitly set to false.\n     * @default false;\n     */\n    loading?: boolean;\n\n    /**\n     * This callback is called while the user is resizing a header cell. The guides\n     * array contains pixel offsets for where to display the resize guides in\n     * the table body's overlay layer.\n     */\n    onResizeGuide: (guides: number[]) => void;\n}\n\n/**\n * These are additional props passed internally from ColumnHeader and RowHeader.\n * They don't need to be exposed to the outside world.\n */\nexport interface IInternalHeaderProps extends IHeaderProps {\n    /**\n     * The cardinality of a fully selected region. Should be FULL_COLUMNS for column headers and\n     * FULL_ROWS for row headers.\n     */\n    fullRegionCardinality: RegionCardinality;\n\n    /**\n     * An optional callback invoked when the user double-clicks a resize handle, if resizing is enabled.\n     */\n    handleResizeDoubleClick?: (index: number) => void;\n\n    /**\n     * The name of the header-cell prop specifying whether the header cell is reorderable or not.\n     */\n    headerCellIsReorderablePropName: string;\n\n    /**\n     * The name of the header-cell prop specifying whether the header cell is selected or not.\n     */\n    headerCellIsSelectedPropName: string;\n\n    /**\n     * The highest cell index to render.\n     */\n    indexEnd: number;\n\n    /**\n     * The lowest cell index to render.\n     */\n    indexStart: number;\n\n    /**\n     * The maximum permitted size of the header in pixels. Corresponds to a width for column headers and\n     * a height for row headers.\n     */\n    maxSize: number;\n\n    /**\n     * The minimum permitted size of the header in pixels. Corresponds to a width for column headers and\n     * a height for row headers.\n     */\n    minSize: number;\n\n    /**\n     * The orientation of the resize handle. Should be VERTICAL for column headers and HORIZONTAL\n     * for row headers.\n     */\n    resizeOrientation: Orientation;\n\n    /**\n     * An array containing the table's selection Regions.\n     */\n    selectedRegions: IRegion[];\n\n    /**\n     * Converts a point on the screen to a row or column index in the table grid.\n     */\n    convertPointToIndex?: (clientXOrY: number, useMidpoint?: boolean) => number;\n\n    /**\n     * Provides any extrema classes for the provided index range in the table grid.\n     */\n    getCellExtremaClasses: (index: number, indexEnd: number) => string[];\n\n    /**\n     * Provides the index class for the cell. Should be Classes.columnCellIndexClass for column\n     * headers or Classes.rowCellIndexClass for row headers.\n     */\n    getCellIndexClass: (index: number) => string;\n\n    /**\n     * Returns the size of the specified header cell in pixels. Corresponds to a width for column\n     * headers and a height for row headers.\n     */\n    getCellSize: (index: number) => number;\n\n    /**\n     * Returns the relevant single coordinate from the provided client coordinates. Should return\n     * the x coordinate for column headers and the y coordinate for row headers.\n     */\n    getDragCoordinate: (clientCoords: IClientCoordinates) => number;\n\n    /**\n     * A callback that returns the CSS index class for the specified index. Should be\n     * Classes.columnIndexClass for column headers and Classes.rowIndexClass for row headers.\n     */\n    getIndexClass: (index: number) => string;\n\n    /**\n     * Given a mouse event, returns the relevant client coordinate (clientX or clientY). Should be\n     * clientX for column headers and clientY for row headers.\n     */\n    getMouseCoordinate: (event: MouseEvent) => number;\n\n    /**\n     * Invoked when a resize interaction ends, if resizing is enabled.\n     */\n    handleResizeEnd: (index: number, size: number) => void;\n\n    /**\n     * Invoked whenever the size changes during a resize interaction, if resizing is enabled.\n     */\n    handleSizeChanged: (index: number, size: number) => void;\n\n    /**\n     * Returns true if the specified cell (and therefore the full column/row) is selected.\n     */\n    isCellSelected: (index: number) => boolean;\n\n    /**\n     * Returns true if the specified cell is at a ghost index.\n     */\n    isGhostIndex: (index: number) => boolean;\n\n    /**\n     * A callback that renders a ghost cell for the provided index.\n     */\n    renderGhostCell: (index: number, extremaClasses: string[]) => JSX.Element;\n\n    /**\n     * A callback that renders a regular header cell at the provided index.\n     */\n    renderHeaderCell: (index: number) => JSX.Element;\n\n    /**\n     * Converts a range to a region. This should be Regions.column for column headers and\n     * Regions.row for row headers.\n     */\n    toRegion: (index1: number, index2?: number) => IRegion;\n\n    /**\n     * A callback that wraps the rendered cell components in additional parent elements as needed.\n     */\n    wrapCells: (cells: Array<React.ReactElement<any>>) => JSX.Element;\n}\n\nexport interface IHeaderState {\n    /**\n     * Whether the drag-select interaction has finished (via mouseup). When\n     * true, DragReorderable will know that it can override the click-and-drag\n     * interactions that would normally be reserved for drag-select behavior.\n     */\n    hasSelectionEnded?: boolean;\n}\n\nconst SHALLOW_COMPARE_PROP_KEYS_BLACKLIST: Array<keyof IInternalHeaderProps> = [\n    \"focusedCell\",\n    \"selectedRegions\",\n];\n\nconst RESET_CELL_KEYS_BLACKLIST: Array<keyof IInternalHeaderProps> = [\n    \"indexEnd\",\n    \"indexStart\",\n];\n\nexport class Header extends React.Component<IInternalHeaderProps, IHeaderState> {\n    public state: IHeaderState = {\n        hasSelectionEnded: false,\n    };\n\n    protected activationIndex: number;\n    private batcher = new Batcher<JSX.Element>();\n\n    public constructor(props?: IHeaderProps, context?: any) {\n        super(props, context);\n    }\n\n    public componentDidMount() {\n        if (this.props.selectedRegions != null && this.props.selectedRegions.length > 0) {\n            // we already have a selection defined, so we'll want to enable reordering interactions\n            // right away if other criteria are satisfied too.\n            this.setState({ hasSelectionEnded: true });\n        }\n    }\n\n    public componentWillUnmount() {\n        this.batcher.cancelOutstandingCallback();\n    }\n\n    public componentWillReceiveProps(nextProps?: IInternalHeaderProps) {\n        if (nextProps.selectedRegions != null && nextProps.selectedRegions.length > 0) {\n            this.setState({ hasSelectionEnded: true });\n        } else {\n            this.setState({ hasSelectionEnded: false });\n        }\n    }\n\n    public shouldComponentUpdate(nextProps?: IInternalHeaderProps, nextState?: IHeaderState) {\n        return !Utils.shallowCompareKeys(this.state, nextState)\n            || !Utils.shallowCompareKeys(this.props, nextProps, { exclude: SHALLOW_COMPARE_PROP_KEYS_BLACKLIST })\n            || !Utils.deepCompareKeys(this.props, nextProps, SHALLOW_COMPARE_PROP_KEYS_BLACKLIST);\n    }\n\n    public componentWillUpdate(nextProps?: IInternalHeaderProps, nextState?: IHeaderState) {\n        const resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };\n        let shouldResetBatcher = !Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);\n        shouldResetBatcher = shouldResetBatcher || !Utils.shallowCompareKeys(this.state, nextState);\n        if (shouldResetBatcher) {\n            this.batcher.reset();\n        }\n    }\n\n    public render() {\n        return this.props.wrapCells(this.renderCells());\n    }\n\n    private locateClick = (event: MouseEvent): IRegion => {\n        const coord = this.props.getMouseCoordinate(event);\n        this.activationIndex = this.props.convertPointToIndex(coord);\n        return this.props.toRegion(this.activationIndex);\n    }\n\n    private locateDragForSelection = (_event: MouseEvent, coords: ICoordinateData, returnEndOnly = false): IRegion => {\n        const coord = this.props.getDragCoordinate(coords.current);\n        const indexStart = this.activationIndex;\n        const indexEnd = this.props.convertPointToIndex(coord);\n        return returnEndOnly\n            ? this.props.toRegion(indexEnd)\n            : this.props.toRegion(indexStart, indexEnd);\n    }\n\n    private locateDragForReordering = (_event: MouseEvent, coords: ICoordinateData): number => {\n        const coord = this.props.getDragCoordinate(coords.current);\n        const guideIndex = this.props.convertPointToIndex(coord, true);\n        return (guideIndex < 0) ? undefined : guideIndex;\n    }\n\n    private renderCells = () => {\n        const { indexStart, indexEnd } = this.props;\n\n        this.batcher.startNewBatch();\n        for (let index = indexStart; index <= indexEnd; index++) {\n            this.batcher.addArgsToBatch(index);\n        }\n        this.batcher.removeOldAddNew(this.renderNewCell);\n\n        if (!this.batcher.isDone()) {\n            this.batcher.idleCallback(() => this.forceUpdate());\n        }\n        return this.batcher.getList();\n    }\n\n    private renderNewCell = (index: number) => {\n        const extremaClasses = this.props.getCellExtremaClasses(index, this.props.indexEnd);\n        const renderer = this.props.isGhostIndex(index)\n            ? this.props.renderGhostCell\n            : this.renderCell;\n        return renderer(index, extremaClasses);\n    }\n\n    private renderCell = (index: number, extremaClasses: string[]) => {\n        const { getIndexClass, selectedRegions } = this.props;\n\n        const cell = this.props.renderHeaderCell(index);\n\n        const isLoading = cell.props.loading != null ? cell.props.loading : this.props.loading;\n        const isSelected = this.props.isCellSelected(index);\n        const isEntireCellTargetReorderable = this.isEntireCellTargetReorderable(isSelected);\n\n        const className = classNames(extremaClasses, {\n            [Classes.TABLE_HEADER_REORDERABLE]: isEntireCellTargetReorderable,\n        }, this.props.getCellIndexClass(index), cell.props.className);\n\n        const cellProps: IHeaderCellProps = {\n            className,\n            index,\n            [this.props.headerCellIsSelectedPropName]: isSelected,\n            [this.props.headerCellIsReorderablePropName]: isEntireCellTargetReorderable,\n            loading: isLoading,\n            reorderHandle: this.maybeRenderReorderHandle(index),\n        };\n\n        const modifiedHandleSizeChanged = (size: number) => this.props.handleSizeChanged(index, size);\n        const modifiedHandleResizeEnd = (size: number) => this.props.handleResizeEnd(index, size);\n        const modifiedHandleResizeHandleDoubleClick = () => this.props.handleResizeDoubleClick(index);\n\n        const baseChildren = (\n            <DragSelectable\n                allowMultipleSelection={this.props.allowMultipleSelection}\n                disabled={isEntireCellTargetReorderable}\n                focusedCell={this.props.focusedCell}\n                ignoredSelectors={[`.${Classes.TABLE_REORDER_HANDLE_TARGET}`]}\n                key={getIndexClass(index)}\n                locateClick={this.locateClick}\n                locateDrag={this.locateDragForSelection}\n                onFocus={this.props.onFocus}\n                onSelection={this.handleDragSelectableSelection}\n                onSelectionEnd={this.handleDragSelectableSelectionEnd}\n                selectedRegions={selectedRegions}\n                selectedRegionTransform={this.props.selectedRegionTransform}\n            >\n                <Resizable\n                    isResizable={this.props.isResizable}\n                    maxSize={this.props.maxSize}\n                    minSize={this.props.minSize}\n                    onDoubleClick={modifiedHandleResizeHandleDoubleClick}\n                    onLayoutLock={this.props.onLayoutLock}\n                    onResizeEnd={modifiedHandleResizeEnd}\n                    onSizeChanged={modifiedHandleSizeChanged}\n                    orientation={this.props.resizeOrientation}\n                    size={this.props.getCellSize(index)}\n                >\n                    {React.cloneElement(cell, cellProps)}\n                </Resizable>\n            </DragSelectable>\n        );\n\n        return this.isReorderHandleEnabled()\n            ? baseChildren // reordering will be handled by interacting with the reorder handle\n            : this.wrapInDragReorderable(index, baseChildren, !isEntireCellTargetReorderable);\n    }\n\n    private isReorderHandleEnabled() {\n        // the reorder handle can only appear in the column interaction bar\n        return this.isColumnHeader() && this.props.isReorderable;\n    }\n\n    private maybeRenderReorderHandle(index: number) {\n        return !this.isReorderHandleEnabled()\n            ? undefined\n            : this.wrapInDragReorderable(index,\n                <div className={Classes.TABLE_REORDER_HANDLE_TARGET}>\n                    <div className={Classes.TABLE_REORDER_HANDLE}>\n                        <span className={classNames(CoreClasses.ICON_STANDARD, IconClasses.DRAG_HANDLE_VERTICAL)} />\n                    </div>\n                </div>);\n    }\n\n    private isColumnHeader() {\n        return this.props.fullRegionCardinality === RegionCardinality.FULL_COLUMNS;\n    }\n\n    private wrapInDragReorderable(index: number, children: JSX.Element, disabled?: boolean) {\n        return (\n            <DragReorderable\n                disabled={disabled}\n                key={this.props.getIndexClass(index)}\n                locateClick={this.locateClick}\n                locateDrag={this.locateDragForReordering}\n                onReordered={this.props.onReordered}\n                onReordering={this.props.onReordering}\n                onSelection={this.props.onSelection}\n                onFocus={this.props.onFocus}\n                selectedRegions={this.props.selectedRegions}\n                toRegion={this.props.toRegion}\n            >\n                {children}\n            </DragReorderable>\n        );\n    }\n\n    private handleDragSelectableSelection = (selectedRegions: IRegion[]) => {\n        this.props.onSelection(selectedRegions);\n        this.setState({ hasSelectionEnded: false });\n    }\n\n    private handleDragSelectableSelectionEnd = () => {\n        this.activationIndex = null; // not strictly required, but good practice\n        this.setState({ hasSelectionEnded: true });\n    }\n\n    private isEntireCellTargetReorderable = (isSelected: boolean) => {\n        const { selectedRegions } = this.props;\n        // although reordering may be generally enabled for this row/column (via props.isReorderable), the\n        // row/column shouldn't actually become reorderable from a user perspective until a few other\n        // conditions are true:\n        return this.props.isReorderable\n            // the row/column should be the only selection (or it should be part of the only selection),\n            // because reordering multiple disjoint row/column selections is a UX morass with no clear best\n            // behavior.\n            && isSelected\n            && this.state.hasSelectionEnded\n            && Regions.getRegionCardinality(selectedRegions[0]) === this.props.fullRegionCardinality\n            // selected regions can be updated during mousedown+drag and before mouseup; thus, we\n            // add a final check to make sure we don't enable reordering until the selection\n            // interaction is complete. this prevents one click+drag interaction from triggering\n            // both selection and reordering behavior.\n            && selectedRegions.length === 1\n            // columns are reordered via a reorder handle, so drag-selection needn't be disabled\n            && !this.isReorderHandleEnabled();\n    }\n}\n"]}