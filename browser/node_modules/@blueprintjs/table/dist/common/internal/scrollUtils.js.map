{"version":3,"sources":["../src/common/internal/scrollUtils.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;AAEH,yCAAoE;AAEpE,oCACI,MAAe,EACf,cAAsB,EACtB,aAAqB,EACrB,aAA8C,EAC9C,YAA0C,EAC1C,aAAyB,EACzB,gBAA4B;IAD5B,8BAAA,EAAA,iBAAyB;IACzB,iCAAA,EAAA,oBAA4B;IAE5B,IAAM,WAAW,GAAG,iBAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAEzD,IAAI,SAAS,GAAG,aAAa,CAAC;IAC9B,IAAI,UAAU,GAAG,cAAc,CAAC;IAEhC,gGAAgG;IAChG,8EAA8E;IAC9E,IAAM,4BAA4B,GAAG,aAAa,CAAC,gBAAgB,CAAC,CAAC;IACrE,IAAM,0BAA0B,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC;IAE/D,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;QAClB,KAAK,2BAAiB,CAAC,KAAK,EAAE,CAAC;YAC3B,sDAAsD;YACtD,IAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACjD,SAAS,GAAG,wBAAwB,CAAC,SAAS,EAAE,0BAA0B,CAAC,CAAC;YAC5E,UAAU,GAAG,wBAAwB,CAAC,UAAU,EAAE,4BAA4B,CAAC,CAAC;YAChF,KAAK,CAAC;QACV,CAAC;QACD,KAAK,2BAAiB,CAAC,SAAS,EAAE,CAAC;YAC/B,qCAAqC;YACrC,IAAM,SAAS,GAAG,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YAC/C,SAAS,GAAG,wBAAwB,CAAC,SAAS,EAAE,0BAA0B,CAAC,CAAC;YAC5E,KAAK,CAAC;QACV,CAAC;QACD,KAAK,2BAAiB,CAAC,YAAY,EAAE,CAAC;YAClC,8CAA8C;YAC9C,IAAM,UAAU,GAAG,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACjD,UAAU,GAAG,wBAAwB,CAAC,UAAU,EAAE,4BAA4B,CAAC,CAAC;YAChF,KAAK,CAAC;QACV,CAAC;QACD,SAAS,CAAC;YACN,6EAA6E;YAC7E,SAAS,GAAG,CAAC,CAAC;YACd,UAAU,GAAG,CAAC,CAAC;YACf,KAAK,CAAC;QACV,CAAC;IACL,CAAC;IAED,MAAM,CAAC,EAAE,UAAU,YAAA,EAAE,SAAS,WAAA,EAAE,CAAC;AACrC,CAAC;AAjDD,gEAiDC;AAED;;GAEG;AACH,kCAAkC,YAAoB,EAAE,0BAAkC;IACtF,yEAAyE;IACzE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,GAAG,0BAA0B,EAAE,CAAC,CAAC,CAAC;AAClE,CAAC","file":"scrollUtils.js","sourcesContent":["/**\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { IRegion, RegionCardinality, Regions } from \"../../regions\";\n\nexport function getScrollPositionForRegion(\n    region: IRegion,\n    currScrollLeft: number,\n    currScrollTop: number,\n    getLeftOffset: (columnIndex: number) => number,\n    getTopOffset: (rowIndex: number) => number,\n    numFrozenRows: number = 0,\n    numFrozenColumns: number = 0,\n) {\n    const cardinality = Regions.getRegionCardinality(region);\n\n    let scrollTop = currScrollTop;\n    let scrollLeft = currScrollLeft;\n\n    // if these were max-frozen-index values, we would have added 1 before passing to the get*Offset\n    // functions, but the counts are already 1-indexed, so we can just pass those.\n    const frozenColumnsCumulativeWidth = getLeftOffset(numFrozenColumns);\n    const frozenRowsCumulativeHeight = getTopOffset(numFrozenRows);\n\n    switch (cardinality) {\n        case RegionCardinality.CELLS: {\n            // scroll to the top-left corner of the block of cells\n            const topOffset = getTopOffset(region.rows[0]);\n            const leftOffset = getLeftOffset(region.cols[0]);\n            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n            break;\n        }\n        case RegionCardinality.FULL_ROWS: {\n            // scroll to the top of the row block\n            const topOffset = getTopOffset(region.rows[0]);\n            scrollTop = getClampedScrollPosition(topOffset, frozenRowsCumulativeHeight);\n            break;\n        }\n        case RegionCardinality.FULL_COLUMNS: {\n            // scroll to the left side of the column block\n            const leftOffset = getLeftOffset(region.cols[0]);\n            scrollLeft = getClampedScrollPosition(leftOffset, frozenColumnsCumulativeWidth);\n            break;\n        }\n        default: {\n            // if it's a FULL_TABLE region, scroll back to the top-left cell of the table\n            scrollTop = 0;\n            scrollLeft = 0;\n            break;\n        }\n    }\n\n    return { scrollLeft, scrollTop };\n}\n\n/**\n * Adjust the scroll position to align content just beyond the frozen region, if necessary.\n */\nfunction getClampedScrollPosition(scrollOffset: number, frozenRegionCumulativeSize: number) {\n    // if the new scroll offset falls within the frozen region, clamp it to 0\n    return Math.max(scrollOffset - frozenRegionCumulativeSize, 0);\n}\n"]}