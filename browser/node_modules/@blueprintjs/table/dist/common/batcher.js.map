{"version":3,"sources":["../src/common/batcher.ts"],"names":[],"mappings":"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","file":"batcher.js","sourcesContent":["/**\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport { Utils } from \"@blueprintjs/core\";\nimport { requestIdleCallback } from \"./requestIdleCallback\";\n\nexport type SimpleStringifyable = string | number | null | undefined;\n\nexport type Callback = () => void;\n\n/**\n * This class helps batch updates to large lists.\n *\n * For example, if your React component has many children, updating them all at\n * once may cause jank when reconciling the DOM. This class helps you update\n * only a few children per frame.\n *\n * A typical usage would be:\n *\n * ```tsx\n * public renderChildren = (allChildrenKeys: string[]) => {\n *\n *     batcher.startNewBatch();\n *\n *     allChildrenKeys.forEach((prop1: string, index: number) => {\n *         batcher.addArgsToBatch(prop1, \"prop2\", index);\n *     });\n *\n *     batcher.removeOldAddNew((prop1: string, prop2: string, other: number) => {\n *         return <Child prop1={prop1} prop2={prop2} other={other} />;\n *     });\n *\n *     if (!batcher.isDone()) {\n *         batcher.idleCallback(this.forceUpdate());\n *     }\n *\n *     const currentChildren = batcher.getList();\n *     return currentChildren;\n * }\n *\n * ```\n */\nexport class Batcher<T> {\n    public static DEFAULT_ADD_LIMIT = 20;\n    public static DEFAULT_UPDATE_LIMIT = 20;\n    public static DEFAULT_REMOVE_LIMIT = 20;\n    public static ARG_DELIMITER = \"|\";\n\n    private currentObjects: Record<string, T> = {};\n    private oldObjects: Record<string, T> = {};\n    private batchArgs: Record<string, any[]> = {};\n    private done = true;\n    private callback: Callback;\n\n    /**\n     * Resets the \"batch\" and \"current\" sets. This essentially clears the cache\n     * and prevents accidental re-use of \"current\" objects.\n     */\n    public reset() {\n        this.batchArgs = {};\n        this.oldObjects = this.currentObjects;\n        this.currentObjects = {};\n    }\n\n    /**\n     * Starts a new \"batch\" argument set\n     */\n    public startNewBatch() {\n        this.batchArgs = {};\n    }\n\n    /**\n     * Stores the variadic arguments to be later batched together.\n     *\n     * The arguments must be simple stringifyable objects.\n     */\n    public addArgsToBatch(...args: SimpleStringifyable[]) {\n        this.batchArgs[args.join(Batcher.ARG_DELIMITER)] = args;\n    }\n\n    /**\n     * Compares the set of \"batch\" arguments to the \"current\" set. Creates any\n     * new objects using the callback as a factory. Removes old objects.\n     *\n     * Arguments that are in the \"current\" set but were not part of the last\n     * \"batch\" set are considered candidates for removal. Similarly, Arguments\n     * that are part of the \"batch\" set but not the \"current\" set are candidates\n     * for addition.\n     *\n     * The number of objects added and removed may be limited with the\n     * `...Limit` parameters.\n     *\n     * Finally, the batcher determines if the batching is complete if the\n     * \"current\" arguments match the \"batch\" arguments.\n     */\n    public removeOldAddNew(\n            callback: (...args: any[]) => T,\n            addNewLimit = Batcher.DEFAULT_ADD_LIMIT,\n            removeOldLimit = Batcher.DEFAULT_REMOVE_LIMIT,\n            updateLimit = Batcher.DEFAULT_UPDATE_LIMIT,\n    ) {\n        // remove old\n        const keysToRemove = this.setKeysDifference(this.currentObjects, this.batchArgs, removeOldLimit);\n        keysToRemove.forEach((key) => delete this.currentObjects[key]);\n\n        // remove ALL old objects not in batch\n        const keysToRemoveOld = this.setKeysDifference(this.oldObjects, this.batchArgs, -1);\n        keysToRemoveOld.forEach((key) => delete this.oldObjects[key]);\n\n        // copy ALL old objects into current objects if not defined\n        const keysToShallowCopy = Object.keys(this.oldObjects);\n        keysToShallowCopy.forEach((key) => {\n            if (this.currentObjects[key] == null) {\n                this.currentObjects[key] = this.oldObjects[key];\n            }\n        });\n\n        // update old objects with factory\n        const keysToUpdate = this.setKeysIntersection(this.oldObjects, this.currentObjects, updateLimit);\n        keysToUpdate.forEach((key) => {\n            delete this.oldObjects[key];\n            this.currentObjects[key] = callback.apply(undefined, this.batchArgs[key]);\n        });\n\n        // add new objects with factory\n        const keysToAdd = this.setKeysDifference(this.batchArgs, this.currentObjects, addNewLimit);\n        keysToAdd.forEach((key) => this.currentObjects[key] = callback.apply(undefined, this.batchArgs[key]));\n\n        // set `done` to true of sets match exactly after add/remove and there\n        // are no \"old objects\" remaining\n        this.done = this.setHasSameKeys(this.batchArgs, this.currentObjects)\n            && Object.keys(this.oldObjects).length === 0;\n    }\n\n    /**\n     * Returns true of the \"current\" set matches the \"batch\" set.\n     */\n    public isDone() {\n        return this.done;\n    }\n\n    /**\n     * Returns all the objects in the \"current\" set.\n     */\n    public getList(): T[] {\n        return Object.keys(this.currentObjects).map(this.mapCurrentObjectKey);\n    }\n\n    /**\n     * Registers a callback to be invoked on the next idle frame. If a callback\n     * has already been registered, we do not register a new one.\n     */\n    public idleCallback(callback: Callback) {\n        if (!this.callback) {\n            this.callback = callback;\n            requestIdleCallback(this.handleIdleCallback);\n        }\n    }\n\n    public cancelOutstandingCallback() {\n        delete this.callback;\n    }\n\n    private handleIdleCallback = () => {\n        const callback = this.callback;\n        delete this.callback;\n        Utils.safeInvoke(callback);\n    }\n\n    private mapCurrentObjectKey = (key: string) => {\n        return this.currentObjects[key];\n    }\n\n    private setKeysDifference(\n            a: Record<string, any>,\n            b: Record<string, any>,\n            limit: number,\n    ) {\n        return this.setKeysOperation(a, b, \"difference\", limit);\n    }\n\n    private setKeysIntersection(\n            a: Record<string, any>,\n            b: Record<string, any>,\n            limit: number,\n    ) {\n        return this.setKeysOperation(a, b, \"intersect\", limit);\n    }\n\n    /**\n     * Compares the keys of A from B -- and performs an \"intersection\" or\n     * \"difference\" operation on the keys.\n     *\n     * Note that the order of operands A and B matters for the \"difference\"\n     * operation.\n     *\n     * Returns an array of at most `limit` keys.\n     */\n    private setKeysOperation(\n            a: Record<string, any>,\n            b: Record<string, any>,\n            operation: \"intersect\" | \"difference\",\n            limit: number,\n    ) {\n        const result = [];\n        const aKeys = Object.keys(a);\n        for (let i = 0; i < aKeys.length && (limit < 0 || result.length < limit); i++) {\n            const key = aKeys[i];\n            if (\n                  (operation === \"difference\" && a[key] && !b[key]) ||\n                  (operation === \"intersect\" && a[key] && b[key])\n            ) {\n                result.push(key);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns true of objects `a` and `b` have exactly the same keys.\n     */\n    private setHasSameKeys(a: Record<string, any>, b: Record<string, any>) {\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        for (const aKey of aKeys) {\n            if (b[aKey] === undefined) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"]}