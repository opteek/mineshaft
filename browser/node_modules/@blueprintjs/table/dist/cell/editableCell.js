/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var ReactDOM = require("react-dom");
var core_1 = require("@blueprintjs/core");
var Classes = require("../common/classes");
var utils_1 = require("../common/utils");
var draggable_1 = require("../interactions/draggable");
var cell_1 = require("./cell");
var EditableCell = (function (_super) {
    tslib_1.__extends(EditableCell, _super);
    function EditableCell(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.handleEdit = function () {
            _this.setState({ isEditing: true, dirtyValue: _this.state.savedValue });
        };
        _this.handleCancel = function (value) {
            // don't strictly need to clear the dirtyValue, but it's better hygiene
            _this.setState({ isEditing: false, dirtyValue: undefined });
            _this.invokeCallback(_this.props.onCancel, value);
        };
        _this.handleChange = function (value) {
            _this.setState({ dirtyValue: value });
            _this.invokeCallback(_this.props.onChange, value);
        };
        _this.handleConfirm = function (value) {
            _this.setState({ isEditing: false, savedValue: value, dirtyValue: undefined });
            _this.invokeCallback(_this.props.onConfirm, value);
        };
        _this.handleCellActivate = function (_event) {
            // Cancel edit of active cell when clicking away
            if (!_this.state.isEditing && document.activeElement instanceof HTMLElement && document.activeElement.blur) {
                document.activeElement.blur();
            }
            return true;
        };
        _this.handleCellDoubleClick = function (_event) {
            var cellElement = ReactDOM.findDOMNode(_this);
            if (cellElement == null) {
                return;
            }
            var focusable = cellElement.querySelector(".pt-editable-text");
            if (focusable.focus != null) {
                focusable.focus();
            }
        };
        _this.state = {
            isEditing: false,
            savedValue: props.value,
        };
        return _this;
    }
    EditableCell.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, { exclude: ["style"] })
            || !utils_1.Utils.shallowCompareKeys(this.state, nextState)
            || !utils_1.Utils.deepCompareKeys(this.props, nextProps, ["style"]);
    };
    EditableCell.prototype.componentWillReceiveProps = function (nextProps) {
        var value = nextProps.value;
        this.setState({ savedValue: value, dirtyValue: value });
    };
    EditableCell.prototype.render = function () {
        var _a = this.props, onCancel = _a.onCancel, onChange = _a.onChange, onConfirm = _a.onConfirm, spreadableProps = tslib_1.__rest(_a, ["onCancel", "onChange", "onConfirm"]);
        var _b = this.state, isEditing = _b.isEditing, dirtyValue = _b.dirtyValue, savedValue = _b.savedValue;
        var interactive = spreadableProps.interactive || isEditing;
        return (React.createElement(cell_1.Cell, tslib_1.__assign({}, spreadableProps, { truncated: false, interactive: interactive }),
            React.createElement(draggable_1.Draggable, { onActivate: this.handleCellActivate, onDoubleClick: this.handleCellDoubleClick, preventDefault: !interactive, stopPropagation: interactive },
                React.createElement(core_1.EditableText, { className: Classes.TABLE_EDITABLE_NAME, intent: spreadableProps.intent, minWidth: null, onCancel: this.handleCancel, onChange: this.handleChange, onConfirm: this.handleConfirm, onEdit: this.handleEdit, placeholder: "", selectAllOnFocus: true, value: isEditing ? dirtyValue : savedValue }))));
    };
    EditableCell.prototype.invokeCallback = function (callback, value) {
        // pass through the row and column indices if they were provided as props by the consumer
        var _a = this.props, rowIndex = _a.rowIndex, columnIndex = _a.columnIndex;
        core_1.Utils.safeInvoke(callback, value, rowIndex, columnIndex);
    };
    return EditableCell;
}(React.Component));
exports.EditableCell = EditableCell;

//# sourceMappingURL=editableCell.js.map
