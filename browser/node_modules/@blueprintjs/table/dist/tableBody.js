/**
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var core_1 = require("@blueprintjs/core");
var classNames = require("classnames");
var React = require("react");
var cell_1 = require("./cell/cell");
var batcher_1 = require("./common/batcher");
var Classes = require("./common/classes");
var contextMenuTargetWrapper_1 = require("./common/contextMenuTargetWrapper");
var rect_1 = require("./common/rect");
var renderMode_1 = require("./common/renderMode");
var utils_1 = require("./common/utils");
var menus_1 = require("./interactions/menus");
var selectable_1 = require("./interactions/selectable");
var regions_1 = require("./regions");
/**
 * For perf, we want to ignore changes to the `ISelectableProps` part of the
 * `ITableBodyProps` since those are only used when a context menu is launched.
 */
var UPDATE_PROPS_KEYS = [
    "focusedCell",
    "grid",
    "locator",
    "viewportRect",
    "cellRenderer",
    "rowIndexStart",
    "rowIndexEnd",
    "columnIndexStart",
    "columnIndexEnd",
    "selectedRegions",
];
/**
 * We don't want to reset the batcher when this set of keys changes. Any other
 * changes should reset the batcher's internal cache.
 */
var RESET_CELL_KEYS_BLACKLIST = [
    "columnIndexEnd",
    "columnIndexStart",
    "rowIndexEnd",
    "rowIndexStart",
    "viewportRect",
];
var TableBody = (function (_super) {
    tslib_1.__extends(TableBody, _super);
    function TableBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.batcher = new batcher_1.Batcher();
        _this.isRenderingBatchedCells = false;
        _this.renderContextMenu = function (e) {
            var _a = _this.props, grid = _a.grid, onFocus = _a.onFocus, onSelection = _a.onSelection, renderBodyContextMenu = _a.renderBodyContextMenu, selectedRegions = _a.selectedRegions;
            var numRows = grid.numRows, numCols = grid.numCols;
            if (renderBodyContextMenu == null) {
                return undefined;
            }
            var targetRegion = _this.locateClick(e.nativeEvent);
            var nextSelectedRegions = selectedRegions;
            // if the event did not happen within a selected region, clear all
            // selections and select the right-clicked cell.
            var foundIndex = regions_1.Regions.findContainingRegion(selectedRegions, targetRegion);
            if (foundIndex < 0) {
                nextSelectedRegions = [targetRegion];
                onSelection(nextSelectedRegions);
                // move the focused cell to the new region.
                var nextFocusedCell = tslib_1.__assign({}, regions_1.Regions.getFocusCellCoordinatesFromRegion(targetRegion), { focusSelectionIndex: 0 });
                onFocus(nextFocusedCell);
            }
            var menuContext = new menus_1.MenuContext(targetRegion, nextSelectedRegions, numRows, numCols);
            var contextMenu = renderBodyContextMenu(menuContext);
            return contextMenu == null ? undefined : contextMenu;
        };
        // Cell renderers
        // ==============
        _this.renderNewCell = function (row, col) {
            var _a = _this.props, columnIndexEnd = _a.columnIndexEnd, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd;
            var extremaClasses = grid.getExtremaClasses(row, col, rowIndexEnd, columnIndexEnd);
            var isGhost = grid.isGhostIndex(row, col);
            return _this.renderCell(row, col, extremaClasses, isGhost);
        };
        _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {
            var _a = _this.props, cellRenderer = _a.cellRenderer, loading = _a.loading, grid = _a.grid;
            var baseCell = isGhost ? cell_1.emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);
            var className = classNames(TableBody.cellClassNames(rowIndex, columnIndex), extremaClasses, (_b = {},
                _b[Classes.TABLE_CELL_GHOST] = isGhost,
                _b[Classes.TABLE_CELL_LEDGER_ODD] = (rowIndex % 2) === 1,
                _b[Classes.TABLE_CELL_LEDGER_EVEN] = (rowIndex % 2) === 0,
                _b), baseCell.props.className);
            var key = TableBody.cellReactKey(rowIndex, columnIndex);
            var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);
            var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;
            var style = tslib_1.__assign({}, baseCell.props.style, rect_1.Rect.style(rect));
            return React.cloneElement(baseCell, { className: className, key: key, loading: cellLoading, style: style });
            var _b;
        };
        // Callbacks
        // =========
        _this.handleSelectionEnd = function () {
            _this.activationCell = null; // not strictly required, but good practice
        };
        _this.locateClick = function (event) {
            _this.activationCell = _this.props.locator.convertPointToCell(event.clientX, event.clientY);
            return regions_1.Regions.cell(_this.activationCell.row, _this.activationCell.col);
        };
        _this.locateDrag = function (_event, coords, returnEndOnly) {
            if (returnEndOnly === void 0) { returnEndOnly = false; }
            var start = _this.activationCell;
            var end = _this.props.locator.convertPointToCell(coords.current[0], coords.current[1]);
            return returnEndOnly
                ? regions_1.Regions.cell(end.row, end.col)
                : regions_1.Regions.cell(start.row, start.col, end.row, end.col);
        };
        return _this;
    }
    /**
     * Returns the array of class names that must be applied to each table
     * cell so that we can locate any cell based on its coordinate.
     */
    TableBody.cellClassNames = function (rowIndex, columnIndex) {
        return [
            Classes.rowCellIndexClass(rowIndex),
            Classes.columnCellIndexClass(columnIndex),
        ];
    };
    TableBody.cellReactKey = function (rowIndex, columnIndex) {
        return "cell-" + rowIndex + "-" + columnIndex;
    };
    TableBody.prototype.componentDidMount = function () {
        this.maybeInvokeOnCompleteRender();
    };
    TableBody.prototype.shouldComponentUpdate = function (nextProps) {
        var propKeysWhitelist = { include: UPDATE_PROPS_KEYS };
        return !utils_1.Utils.shallowCompareKeys(this.props, nextProps, propKeysWhitelist);
    };
    TableBody.prototype.componentWillUpdate = function (nextProps) {
        var resetKeysBlacklist = { exclude: RESET_CELL_KEYS_BLACKLIST };
        var shouldResetBatcher = !utils_1.Utils.shallowCompareKeys(this.props, nextProps, resetKeysBlacklist);
        if (shouldResetBatcher) {
            this.batcher.reset();
        }
    };
    TableBody.prototype.componentDidUpdate = function () {
        this.maybeInvokeOnCompleteRender();
    };
    TableBody.prototype.componentWillUnmount = function () {
        this.batcher.cancelOutstandingCallback();
    };
    TableBody.prototype.render = function () {
        var _a = this.props, allowMultipleSelection = _a.allowMultipleSelection, focusedCell = _a.focusedCell, grid = _a.grid, numFrozenColumns = _a.numFrozenColumns, numFrozenRows = _a.numFrozenRows, onFocus = _a.onFocus, onSelection = _a.onSelection, renderMode = _a.renderMode, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;
        var cells = (renderMode === renderMode_1.RenderMode.BATCH)
            ? this.renderBatchedCells()
            : this.renderAllCells();
        var defaultStyle = grid.getRect().sizeStyle();
        var style = {
            height: (numFrozenRows != null) ? grid.getCumulativeHeightAt(numFrozenRows - 1) : defaultStyle.height,
            width: (numFrozenColumns != null) ? grid.getCumulativeWidthAt(numFrozenColumns - 1) : defaultStyle.width,
        };
        return (React.createElement(selectable_1.DragSelectable, { allowMultipleSelection: allowMultipleSelection, focusedCell: focusedCell, locateClick: this.locateClick, locateDrag: this.locateDrag, onFocus: onFocus, onSelection: onSelection, onSelectionEnd: this.handleSelectionEnd, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform },
            React.createElement(contextMenuTargetWrapper_1.ContextMenuTargetWrapper, { className: classNames(Classes.TABLE_BODY_VIRTUAL_CLIENT, Classes.TABLE_CELL_CLIENT), renderContextMenu: this.renderContextMenu, style: style }, cells)));
    };
    // Render modes
    // ============
    TableBody.prototype.renderBatchedCells = function () {
        var _this = this;
        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;
        // render cells in batches
        this.batcher.startNewBatch();
        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
                this.batcher.addArgsToBatch(rowIndex, columnIndex);
            }
        }
        this.batcher.removeOldAddNew(this.renderNewCell);
        if (!this.batcher.isDone()) {
            this.batcher.idleCallback(function () { return _this.forceUpdate(); });
        }
        var cells = this.batcher.getList();
        return cells;
    };
    TableBody.prototype.renderAllCells = function () {
        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;
        var cells = [];
        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
                var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);
                var isGhost = grid.isGhostIndex(rowIndex, columnIndex);
                cells.push(this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost));
            }
        }
        return cells;
    };
    TableBody.prototype.maybeInvokeOnCompleteRender = function () {
        var _a = this.props, onCompleteRender = _a.onCompleteRender, renderMode = _a.renderMode;
        if (renderMode === renderMode_1.RenderMode.BATCH
            && this.isRenderingBatchedCells
            && this.batcher.isDone()) {
            this.isRenderingBatchedCells = false;
            core_1.Utils.safeInvoke(onCompleteRender);
        }
        else if (renderMode === renderMode_1.RenderMode.NONE) {
            core_1.Utils.safeInvoke(onCompleteRender);
        }
    };
    return TableBody;
}(React.Component));
TableBody.defaultProps = {
    loading: false,
    renderMode: renderMode_1.RenderMode.BATCH,
};
exports.TableBody = TableBody;

//# sourceMappingURL=tableBody.js.map
